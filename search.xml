<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring之Bean的生命周期详解</title>
      <link href="2021/03/30/Spring%E4%B9%8BBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/03/30/Spring%E4%B9%8BBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在说Bean的生命周期之前，先来了解一下bean。</p><p>Spring中的Bean和Java中的Bean有什么区别呢？</p><ul><li><p>Bean一定是一个对象，对象不一定是Bean，被spring管理的对象才是Bean</p></li><li><p>传统JavaBean作为值对象传递，不接受任何容器管理其生命周期；spring中的Bean有spring管理其生命周期行为.</p></li></ul><p><img src="https://i.loli.net/2021/03/31/EZ2iFSg6zUdeyNL.png" alt="image-20210330203451119.png"></p><p>对上图的文字说明：假设磁盘上有N个.java文件，首先我们把这些java文件编译成class文件，继而Java虚拟机启动会把这些class文件load到内存，当遇到new关键字的时候会根据类的模板信息实例化这个对象也就是在堆上面分配内存。</p><p>但是spring的bean实例化过程和一个普通java对象的实例化过程还是有区别的，同样用一幅图来说明一下：</p><p><img src="https://i.loli.net/2021/03/31/Anh4JPozjVZTNcB.png" alt="image-20210331121139250.png"></p><h3 id="BeanDefinition概念"><a href="#BeanDefinition概念" class="headerlink" title="BeanDefinition概念"></a>BeanDefinition概念</h3><p>BeanDefinition–&gt;实例化–&gt;属性赋值–&gt;初始化–&gt;销毁</p><p>BeanDefinition 用于保存 Bean 的相关信息，包括属性、构造方法参数、依赖的 Bean 名称及是否单例、延迟加载等，它是实例化 Bean 的原材料，Spring 就是根据 BeanDefinition 中的信息实例化 Bean。</p><p>当spring容器启动的时候会去调用ConfigurationClassPostProcessor这个bean工厂的后置处理器完成扫描，所谓的spring扫描就是把类的信息读取到，但是读取到类的信息存放到哪里呢？比如类的类型(class),比如类的名字，类的构造方法。spring设计了一个BeanDefintion的类用来存储这些信息。故而当spring读取到类的信息之后，会实例化一个BeanDefinition的对象，继而调用这个对象的各种set方法存储信息；每扫描到一个符合规则的类，spring都会实例化一个BeanDefinition对象，然后把根据类的类名生成一个bean的名字。继而<strong>spring会把这个beanDefinition对象和生成的beanName放到一个map当中，key=beanName，value=beanDefinition对象</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> BeanDefinition<span class="token operator">></span> beanDefinitionMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当spring把类所对应的BeanDefinition对象存到map后，spring会调用程序员提供的BeanFactory后置处理器，即BeanFactoryPostProcessor，只要实现这个接口便是一个BeanFactory后置处理器。</p><p><strong>执行程序员提供的<code>BeanFactoryPostProcessor</code>到底有什么意义呢？</strong></p><p><code>BeanFactoryPostProcessor</code>的后置处理器，其实是spring提供的一个扩展点，实现这个接口，可以在bean定义对象没有实例化之前，读取bean定义对象配置元数据，并可以对配置元数据的一些属性修改。也就是说：****BeanFactoryPostProcessor是在spring容器加载了bean的定义文件之后，在bean实例化之前执行的****。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanFactoryPostProcessor</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>ConfigurableListableBeanFactory beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>可以看到BeanFactoryPostProcessor里唯一的方法postProcessBeanFactory中唯一的参数就是一个标准的beanFactory对象——ConfigurableListableBeanFactory；既然spring在调用postProcessBeanFactory方法的时候把已经实例化好的beanFactory对象传过来了，那么自然而然我们可以对这个beanFactory肆意妄为了；</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p><strong>BeanFactoryPostProcessor和BeanPostProcessor区别</strong></p><p>BeanFactoryPostProcessor和BeanPostProcessor，这两个接口，都是Spring初始化bean时对外暴露的扩展点。两个接口名称看起来很相似，但作用及使用场景却不同。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanFactoryPostProcessor</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>ConfigurableListableBeanFactory beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanPostProcessor</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">default</span> Object <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">default</span> Object <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>实现<strong>BeanFactoryPostProcessor</strong>接口，可以在spring的bean创建之前，修改bean的定义属性。也就是说，Spring允许BeanFactoryPostProcessor在容器实例化任何其它bean之前读取配置元数据，并可以根据需要进行修改，例如可以把bean的scope从singleton改为prototype，也可以把property的值给修改掉。可以同时配置多个BeanFactoryPostProcessor，并通过设置’order’属性来控制各个BeanFactoryPostProcessor的执行次序。</p><p><strong>BeanPostProcessor</strong>，可以在spring容器实例化bean之后，在执行bean的初始化方法前后，添加一些自己的处理逻辑。<strong>注意：BeanPostProcessor是在spring容器加载了bean的定义文件并且实例化bean之后执行的。BeanPostProcessor的执行顺序是在BeanFactoryPostProcessor之后。</strong></p><h3 id="Java类-gt-BeanDefinition对象"><a href="#Java类-gt-BeanDefinition对象" class="headerlink" title="Java类-&gt;BeanDefinition对象"></a>Java类-&gt;BeanDefinition对象</h3><p>java类在哪一步变成的BeanDefinition，我们先来看一下Spring中AbstractApplicationContext类中的refresh方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">,</span> IllegalStateException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>startupShutdownMonitor<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//准备工作，包括设置启动时间，是否激活标识位</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//返回一个factory，对工厂进行初始化</span>            ConfigurableListableBeanFactory beanFactory <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">obtainFreshBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//准备工厂</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//这个方法在当前版本的spring是没用任何代码的</span>                <span class="token comment" spellcheck="true">//可能spring期待在后面的版本中去扩展吧</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//执行自定义的ProcessBeanFactory和Spring内部自己定义的</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//注册beanPostProcessor</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerBeanPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//初始化应用事件广播器</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">finishBeanFactoryInitialization</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">finishRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> var9<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> <span class="token operator">+</span> var9<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">destroyBeans</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cancelRefresh</span><span class="token punctuation">(</span>var9<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> var9<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resetCommonCaches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>有关Spring Bean生命周期最主要的方法有三个invokeBeanFactoryPostProcessors、registerBeanPostProcessors和finishBeanFactoryInitialization。</p><p>其中invokeBeanFactoryPostProcessors方法会执行BeanFactoryPostProcessors后置处理器及其子接口BeanDefinitionRegistryPostProcessor，执行顺序先是执行BeanDefinitionRegistryPostProcessor接口的postProcessBeanDefinitionRegistry方法，然后执行BeanFactoryPostProcessor接口的postProcessBeanFactory方法。</p><p>对于BeanDefinitionRegistryPostProcessor接口的postProcessBeanDefinitionRegistry方法，该步骤会扫描到指定包下面的标有注解的类，然后将其变成BeanDefinition对象，然后放到一个Spring中的Map中，用于下面创建Spring bean的时候使用这个BeanDefinition</p><p>其中registerBeanPostProcessors方法根据实现了PriorityOrdered、Ordered接口，排序后注册所有的BeanPostProcessor后置处理器，主要用于Spring Bean创建时，执行这些后置处理器的方法，这也是Spring中提供的扩展点，让我们能够插手Spring bean创建过程。</p><p><strong>AbstractApplicationContext中refresh方法的执行过程：</strong></p><p><img src="https://i.loli.net/2021/03/31/TZhfIcR3HEoDnql.png" alt="image-20210331110118192.png"></p><h3 id="beanDefinition对象-gt-Spring中的bean"><a href="#beanDefinition对象-gt-Spring中的bean" class="headerlink" title="beanDefinition对象 -&gt; Spring中的bean"></a><strong>beanDefinition对象 -&gt; Spring中的bean</strong></h3><p> finishBeanFactoryInitialization是完成非懒加载的Spring bean的创建的工作，你要想说Spring的生命周期，不要整其他没用的，直接告诉他在该步骤中会有8个后置处理的方法4个后置处理器的类贯穿在对象的实例化、赋值、初始化、和销毁的过程中，这4个后置处理器出现的地方分别为：<br><img src="https://img-blog.csdnimg.cn/2020072612595369.png" alt="img"></p><p>这里我们挑重要的讲一下：</p><p><img src="https://i.loli.net/2021/03/31/OSeFA1Egmo9aX58.png" alt="image-20210331115747270.png"></p><h4 id="InstantiationAwareBeanPostProcessor"><a href="#InstantiationAwareBeanPostProcessor" class="headerlink" title="InstantiationAwareBeanPostProcessor"></a>InstantiationAwareBeanPostProcessor</h4><p>InstantiationAwareBeanPostProcessor接口继承BeanPostProcessor接口，它内部提供了3个方法，再加上BeanPostProcessor接口内部的2个方法，所以实现这个接口需要实现5个方法。InstantiationAwareBeanPostProcessor接口的主要作用在于目标对象的实例化过程中需要处理的事情，包括实例化对象的前后过程以及实例的属性设置。</p><p>postProcessBeforeInstantiation在目标对象实例化之前调用，方法的返回值类型是Object，我们可以返回任何类型的值，由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例（一般都是代理对象）。如果该方法的返回值代替原本该生成的目标对象，后续就只有postProcessAfterInstantiation方法会调用，其他方法不再调用；否则按照正常流程走。</p><p>postProcessAfterInstantiation方法在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被赋值，都是null。如果该方法返回false，会忽略属性值的设置，如果返回true，会按照正常流程设置属性值，方法不管postProcessBeforeInstantiation方法的返回值是什么都会执行。</p><p>postProcessPropertyValues方法会完成属性注入，这个类有两个比较重要的实现类：</p><p>AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues：在个方法中对@Autowired、@Values标注的字段、方法注入值</p><p>CommonAnnotationBeanPostProcessor#postProcessPropertyValues：在这个方法中对@Resource标注的字段和方法注入值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InstantiationAwareBeanPostProcessor</span> <span class="token keyword">extends</span> <span class="token class-name">BeanPostProcessor</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">default</span> Object <span class="token function">postProcessBeforeInstantiation</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> beanClass<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">postProcessAfterInstantiation</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">default</span> PropertyValues <span class="token function">postProcessPropertyValues</span><span class="token punctuation">(</span>PropertyValues pvs<span class="token punctuation">,</span> PropertyDescriptor<span class="token punctuation">[</span><span class="token punctuation">]</span> pds<span class="token punctuation">,</span> Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> pvs<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段分为两个过程：</p><p>①如果bean实现了InitializingBean接口，则执行其afterPropertiesSet方法，进行bean的初始化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InitializingBean</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>②调用bean定义的时候指定的初始化方法，有三种方式：</p><ul><li>方式一：xml方式指定初始化方法<bean init-method="bean中方法名称"/></li><li>方式二：@Bean的方式指定初始化方法@Bean(initMethod=“初始化方法”)</li><li>方式三：api的防水指定初始化方法this.beanDefinition.setInitMethodName(methodName);</li></ul><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a><strong>BeanPostProcessor</strong></h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanPostProcessor</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">default</span> Object <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">default</span> Object <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>BeanPostProcessor#postProcessBeforeInitialization</strong>：该方法会在初始化之前进行执行，若返回null，当前方法结束，这个方法也被称为bean初始化前操作。</p><p>这里有两个重要实现类：</p><p>ApplicationContextAwareProcessor和CommonAnnotationBeanPostProcessor</p><p>ApplicationContextAwareProcessor：若bean实现了EnvironmentAware、EmbeddedValueResolverAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware接口，在ApplicationContextAwareProcessor#<strong>postProcessBeforeInitialization</strong>中会依次调用接口中的方法，将Aware前缀对应的对象注入到bean实例中。</p><p>CommonAnnotationBeanPostProcessor#<strong>postProcessBeforeInitialization</strong>中会调用bean中所有标注@PostConstruct注解的方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ApplicationContextAwareProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanPostProcessor</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">public</span> Object <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span><span class="token keyword">final</span> Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        AccessControlContext acc <span class="token operator">=</span> null<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">EnvironmentAware</span> <span class="token operator">||</span> bean <span class="token keyword">instanceof</span> <span class="token class-name">EmbeddedValueResolverAware</span> <span class="token operator">||</span>                        bean <span class="token keyword">instanceof</span> <span class="token class-name">ResourceLoaderAware</span> <span class="token operator">||</span> bean <span class="token keyword">instanceof</span> <span class="token class-name">ApplicationEventPublisherAware</span> <span class="token operator">||</span>                        bean <span class="token keyword">instanceof</span> <span class="token class-name">MessageSourceAware</span> <span class="token operator">||</span> bean <span class="token keyword">instanceof</span> <span class="token class-name">ApplicationContextAware</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            acc <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAccessControlContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>acc <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token punctuation">(</span>PrivilegedAction<span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">invokeAwareInterfaces</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> acc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">invokeAwareInterfaces</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeAwareInterfaces</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">Aware</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//判断该类是否是Aware的子类</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">EnvironmentAware</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                 <span class="token punctuation">(</span><span class="token punctuation">(</span>EnvironmentAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setEnvironment</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">EmbeddedValueResolverAware</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>EmbeddedValueResolverAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setEmbeddedValueResolver</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>embeddedValueResolver<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">ResourceLoaderAware</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>ResourceLoaderAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setResourceLoader</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">ApplicationEventPublisherAware</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>ApplicationEventPublisherAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setApplicationEventPublisher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">MessageSourceAware</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>MessageSourceAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setMessageSource</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//spring帮你set一个applicationContext对象</span>            <span class="token comment" spellcheck="true">//所以当我们自己的一个对象实现了ApplicationContextAware对象只需要提供setter就能得到applicationContext对象</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">ApplicationContextAware</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"IndexDao"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>ApplicationContextAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setApplicationContext</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>BeanPostProcessor# postProcessAfterInitialization</strong></p><p>该后置处理器的执行是在调用init方法后面进行执行，主要是判断该bean是否需要被AOP代理增强，如果需要的话，则会在该步骤返回一个代理对象。</p><h3 id="spring-bean的完整生命周期："><a href="#spring-bean的完整生命周期：" class="headerlink" title="*spring bean的完整生命周期："></a>*<em>spring bean的完整生命周期：</em></h3><p>（1）实例化Bean</p><p>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p><p>（2）设置对象属性（依赖注入）</p><p>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。</p><p>（3）处理Aware接口</p><p>接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：</p><p>①如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；</p><p>②如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身。</p><p>③如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文；</p><p>（4）BeanPostProcessor</p><p>如果想对Bean进行一些自定义的处理，那么可以让Bean实现BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p><p>（5）InitializingBean与init-method</p><p>如果Bean在Spring配置文件中配置了init-method属性，则会自动调用其配置的初始化方法</p><p>（6）如果这个Bean实现了BeanProcessor接口，将会调用postProcessorAfterInitialization（Object obj,String s）方法，由于这个方法是在Bean初始化结束时调用的，所以可以被以用于内存或缓存技术</p><p>（7）现在Bean就可以使用了，context.getBean()</p><p>（8）DisposableBean</p><p>当Bean不再需要的时候，会经过清理阶段，如果Bean实现了DisposableBean接口，会调用其实现的destroy()方法。</p><p>（9）destroy-method</p><p>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Bean生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis设计与实现——跳表</title>
      <link href="2021/03/30/%E8%B7%B3%E8%A1%A8/"/>
      <url>2021/03/30/%E8%B7%B3%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h4><p>Redis对外共有约五种类型的对象：</p><ul><li>字符串（String）</li><li>列表（List）</li><li>哈希（Hash）</li><li>集合（Set）</li><li>有序集合（ZSet）</li></ul><p>由于Redis是基于内存的，在实现这5种数据类型时在底层创建了多种数据结构，在对象底层选择采用哪种结构来实现，需要根据对象大小以及单个元素大小来进行确定，从而提高空间使用率和效率。如图展示了Redis对外使用的数据类型和底层的数据结构：</p><p><img src="https://i.loli.net/2021/03/30/kLKQ7FiswCPREcS.png" alt="image-20210329150437072.png"></p><p>有序集合对象的编码可以是ziplist或者skiplist，在元素小于128并且元素长度小于64Byte时才会选择压缩列表实现，一般使用skiplist跳表实现。</p><p>跳跃表基于有序单链表，在链表的基础上，每个结点不只包含一个指针，还可能包含多个指向后继结点的指针，这样就可以跳过一些不必要的结点，从而加快查找、删除等操作。跳跃表结点包含多少个指向后继元素的指针，是通过一个随机函数生成器得到的。</p><h4 id="跳表的实现细节"><a href="#跳表的实现细节" class="headerlink" title="跳表的实现细节"></a>跳表的实现细节</h4><h5 id="什么是跳跃表"><a href="#什么是跳跃表" class="headerlink" title="什么是跳跃表?"></a>什么是跳跃表?</h5><p>跳跃表是一种概率型的数据结构，<strong>实质是一种可以进行二分查找的有序链表。</strong>它通过在每个节点中维持多个指向其他的节点指针，从而达到快速访问队尾目的。元素的插入层数是随机指定的。跳跃表的效率可以和平衡树想媲美了，最关键是它的实现相对于平衡树来说，代码的实现上简单很多。</p><p>跳跃表 level 层级完全是随机的。一般来说，<strong>层级越多，访问节点的速度越快</strong>。</p><p>**跳表查找任意数据的时间复杂度为O(logn)**，这个查找的时间复杂度和二分查找是一样的；</p><p>**跳表的空间复杂度为O(n)**。</p><h5 id="跳跃表原理"><a href="#跳跃表原理" class="headerlink" title="跳跃表原理"></a>跳跃表原理</h5><p>下图是从William Pugh的论文Skip Lists : A Probabilistic Alternative to Balanced Trees中截取的。</p><p><img src="https://i.loli.net/2021/03/30/UHKFwDymczj4L2R.png" alt="image-20210329144938038.png"></p><p>上图用a,b,c,d,e五种有序链表及其变式说明了跳跃表的motivation.</p><p>[a]单链表：查询时间复杂度O(n)<br>[b]level-2单链表：每隔一个节点为一个level-2节点，每个level-2节点有2个后继指针，分别指向单链表中的下一个节点和下一个level-2节点。查询时间复杂度为O(n/2)<br>[c]level-3单链表：每隔一个节点为一个level-2节点，每隔4个节点为一个level-3节点，查询时间复杂度O(n/4)<br>[d]指数式单链表：每2^i个节点的level为i+1，查询时间复杂度为O(log2N)<br>[e]跳跃表：各个level的节点个数同指数式单链表，但出现的位置随机，查询复杂度是O(logN)！</p><p>对于一个单链表来说，即使链表中的数据是有序的，如果我们想要查找某个数据，也必须从头到尾的遍历链表，很显然这种查找效率是十分低效的，时间复杂度为O(n)。</p><p><img src="https://i.loli.net/2021/03/30/hIvbewk8ozLpumV.png" alt="image-20210329153658642.png"></p><p>那么我们如何提高查找效率呢？我们可以对链表建立一级“索引”，每两个结点提取一个结点到上一级，我们把抽取出来的那一级叫做索引或者索引层，如下图所示，down表示down指针。</p><p><img src="https://i.loli.net/2021/03/30/H2w9YCdlo8ILfym.png" alt="image-20210329153713695.png"></p><p>假设我们现在要查找值为17的这个结点。我们可以先在索引层遍历，当遍历索引层中值为12的时候，通过值为12的结点的指针域发现下一个结点值为19，因为链表本身有序，所以值为17的结点肯定在12和19这两个结点之间。然后我们通过索引层结点的down指针，下降到原始链表这一层，继续往后遍历查找。这个时候我们只需要遍历2个结点（值为12和17的结点），就可以找到值等于17的这个结点了。</p><p>那么我们可以由此得到启发，和上面建立第一级索引的方式相似，在第一级索引的基础上，每两个一级索引结点就抽到一个结点到第二级索引中。再来查找值为17的结点，从而进一步提高了查找效率。</p><p><img src="https://i.loli.net/2021/03/30/DfP3RwAct2GWFK7.png" alt="image-20210329153918830.png"></p><p>上面举得例子中的数据量不大，所以即便加了两级索引，查找的效率提升的也不是很明显，下面通过一个64结点的链表来更加直观的感受下索引提升查找效率，如图所示，建立了五级索引。</p><p><img src="https://img-blog.csdnimg.cn/20181029212022783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bjd2wxMjA2,size_16,color_FFFFFF,t_70" alt="img"></p><p>从图中我们可以看出来，原来没有索引的时候，查找62需要遍历62个结点，现在只需要遍历11个结点即可，速度提高了很多。那么，如果当链表的长度为10000、10000000时，通过构件索引之后，查找的效率就会提升的非常明显。</p><h5 id="跳跃表插入"><a href="#跳跃表插入" class="headerlink" title="跳跃表插入"></a>跳跃表插入</h5><p><strong>跳表插入的时间复杂度为：O(logn)，支持高效的动态插入。</strong></p><p>在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是O(1)。但是为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找的操作就会比较耗时。</p><p>对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是对于跳表来说，查找的时间复杂度为O(logn)，所以这里查找某个数据应该插入的位置的时间复杂度也是O(logn)，如下图所示：<br><img src="https://i.loli.net/2021/03/30/de8BajiKSL9xIgG.png" alt="image-20210329155023617.png"></p><h5 id="跳跃表删除"><a href="#跳跃表删除" class="headerlink" title="跳跃表删除"></a>跳跃表删除</h5><p>跳表的删除操作时间复杂度为：O(logn)，支持动态的删除。</p><p>在跳表中删除某个结点时，如果这个结点在索引中也出现了，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到删除结点的前驱结点，然后再通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点（双向链表除外）。因此跳表的删除操作时间复杂度即为O(logn)。</p><h5 id="跳跃表的动态更新"><a href="#跳跃表的动态更新" class="headerlink" title="跳跃表的动态更新"></a>跳跃表的动态更新</h5><p>当我们不断地往跳表中插入数据时，我们如果不更新索引，就有可能出现某2个索引节点之间的数据非常多的情况，在极端情况下，跳表还会退化成单链表，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20181030160535359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bjd2wxMjA2,size_16,color_FFFFFF,t_70" alt="img"></p><p>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中的结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入和删除操作性能的下降。</p><p>如果你了解红黑树、AVL树这样的平衡二叉树，你就会知道它们是通过左右旋的方式保持左右子树的大小平衡，而跳表是通过随机函数来维护“平衡性”。</p><p>当我们往跳表中插入数据的时候，我们可以通过一个随机函数，来决定这个结点插入到哪几级索引层中，比如随机函数生成了值K，那我们就将这个结点添加到第一级到第K级这个K级索引中。如下图中要插入数据为6，K=2的例子：<br><img src="https://img-blog.csdnimg.cn/20181030161602638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bjd2wxMjA2,size_16,color_FFFFFF,t_70" alt="img"></p><p>随机函数的选择是非常有讲究的，从概率上讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能的过度退化。</p><h5 id="跳表的性质"><a href="#跳表的性质" class="headerlink" title="跳表的性质"></a>跳表的性质</h5><p> (1) 由很多层结构组成，level是通过一定的概率随机产生的；</p><p> (2) 每一层都是一个有序的链表，默认是升序 ；</p><p> (3) 最底层(Level 1)的链表包含所有元素；</p><p> (4) 如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现； </p><p> (5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</p><h4 id="Java简单实现跳表"><a href="#Java简单实现跳表" class="headerlink" title="Java简单实现跳表"></a>Java简单实现跳表</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>yh<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Random<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 跳表中存储的是正整数，并且存储的数据是不重复的</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SkipList</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//跳表层数16层：定义成32层理论上对于2^16-1个元素的查询最优。</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_LEVEL <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//索引的层级数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> levelCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Node head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//头结点</span>    <span class="token keyword">private</span> Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//查找操作</span>    <span class="token keyword">public</span> Node <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Node p <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 从顶层开始查找当前层的链表中是否包含节点node，如果包含node节点，直接返回；否则在下一层中查找是否包含node节点。         * 如果最底层的链表也不包含node节点，则放回false。         */</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>levelCount<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>p<span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">&lt;</span>value<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>p<span class="token punctuation">.</span>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">==</span>value<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> p<span class="token punctuation">.</span>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//找到则返回原始链表中的结点</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//插入操作</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//根据随机函数来决定这个节点到底插入到哪一层</span>        <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token function">randomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Node newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newNode<span class="token punctuation">.</span>data <span class="token operator">=</span> value<span class="token punctuation">;</span>        newNode<span class="token punctuation">.</span>maxLevel <span class="token operator">=</span> level<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//找出每层中待插入节点的前驱节点</span>        Node predecessors<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>level<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            predecessors<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        Node p <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>p<span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">&lt;</span>value<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            predecessors<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//level层以下的每次层都要插入这个节点</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>level<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            newNode<span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> predecessors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            predecessors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>levelCount<span class="token operator">&lt;</span>level<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            levelCount <span class="token operator">=</span> level<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//随机函数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">randomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>MAX_LEVEL<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                level<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> level<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//删除节点</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//先获取前驱节点</span>        Node<span class="token punctuation">[</span><span class="token punctuation">]</span> predecessors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>levelCount<span class="token punctuation">]</span><span class="token punctuation">;</span>        Node p <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>levelCount<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>p<span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">&lt;</span>value<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            predecessors<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果待删除节点在索引层中也出现了，也要删除</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>p<span class="token punctuation">.</span>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">==</span>value<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>levelCount<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>predecessors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>predecessors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">==</span>value<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    predecessors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> predecessors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//节点指向第i层的结点next[i]</span>        <span class="token keyword">private</span> Node next<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>MAX_LEVEL<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> maxLevel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"&amp;#123;data:"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"; levels: "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>maxLevel<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"&amp;#125;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//显示跳表中的节点</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Node p <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="Redis中的跳跃表"><a href="#Redis中的跳跃表" class="headerlink" title="Redis中的跳跃表"></a>Redis中的跳跃表</h4><p>​    Redis使用跳跃表作为有序集合键的底层实现之一，若一个有序集合包含的元素数量比较多，或者有序集合中的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>​    有序集合使用两种数据结构来实现，从而可以使插入和删除操作达到O(log(N))的时间复杂度。这两种数据结构是哈希表和跳跃表。向哈希表添加元素，用于将成员对象映射到分数；同时将该元素添加到跳跃表，以分数进行排序。</p><h4 id="Redis跳表源码"><a href="#Redis跳表源码" class="headerlink" title="Redis跳表源码"></a>Redis跳表源码</h4><p>在redis.h中定义了结构体zskiplistNode表示跳跃表结点，它的定义如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zskiplistNode <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      robj <span class="token operator">*</span>obj<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//obj是该结点的成员对象指针</span>    <span class="token keyword">double</span> score<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//score是该对象的分值，是一个浮点数，跳跃表中的所有结点，都是根据score从小到大来排序的。</span>    <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>backward<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//后退指针，指向的是前面的一个跳表节点</span>    <span class="token keyword">struct</span> zskiplistLevel <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>forward<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//前进指针，指向该节点在本层的后继节点</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这个层跨越的节点数量</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> zskiplistNode<span class="token punctuation">;</span>  </code></pre><p>在redis.h中定义了结构体zskiplist表示跳跃表，它的定义如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zskiplist <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//header和tail指针分别指向跳跃表的表头结点和表尾结点</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//记录结点的数量，在O(1)的时间复杂度内返回跳跃表的长度</span>    <span class="token keyword">int</span> level<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//记录跳跃表的层数</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> zskiplist<span class="token punctuation">;</span> </code></pre><p>通过这<code>*header, *tail</code>两个指针，定位表头结点和表尾结点的复杂度为O(1)。表尾结点是表中最后一个结点。而表头结点实际上是一个伪结点，该结点的成员对象为NULL，分值为0，它的层数固定为32（层的最大值）。</p><p><strong>随机算法</strong></p><p>一个具有k个后继指针的结点称为k层结点。假设k层结点的数量是k+1层结点的P倍，那么其实这个跳跃表可以看成是一棵平衡的P叉树。跳跃表结点的层数，采用随机化算法得到，实现如下：</p><pre class=" language-c++"><code class="language-c++">int zslRandomLevel(void) &#123;      int level = 1;      while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))          level += 1;      return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;  &#125;  </code></pre><p>这里的ZSKIPLIST_P是0.25。上述代码中，level初始化为1，然后，如果持续满足条件：(random()&amp;0xFFFF)&lt; (ZSKIPLIST_P * 0xFFFF)的话，则level+=1。最终调整level的值，使其小于ZSKIPLIST_MAXLEVEL</p><p>random()&amp;0xFFFF形成的数，均匀分布在区间[0,0xFFFF]上，那么这个数小于(ZSKIPLIST_P * 0xFFFF)的概率是多少呢？自然就是ZSKIPLIST_P，也就是0.25了。</p><p>因此，最终返回level为1的概率是1-0.25=0.75，返回level为2的概率为0.25X0.75，返回level为3的概率为0.25X0.25X0.75……因此，如果返回level为k的概率为x，则返回level为k+1的概率为0.25<em>x，换句话说，如果k层的结点数是x，那么k+1层就是0.25</em>x了。这就是所谓的幂次定律（powerlaw），越大的数出现的概率越小。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 跳表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见IO模型</title>
      <link href="2021/03/28/%E5%B8%B8%E8%A7%81IO%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/03/28/%E5%B8%B8%E8%A7%81IO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是I-O？"><a href="#什么是I-O？" class="headerlink" title="什么是I/O？"></a>什么是I/O？</h3><p>为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为用户空间和内核空间，像我们平常运行的应用程序 都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等，也就是说，我们想要进行IO操作，一定是要依赖内核空间的能力。</p><p>并且用户空间的程序不能直接访问内核空间。</p><p>当要执行IO操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p><p>因此，用户进程想要执行IO操作的话，必须通过系统调用来间接访问内核空间。</p><p>我们在平常开发过程中接触最多的就是磁盘IO（读写文件）和网络IO（网络请求和响应）。</p><p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>当程序发起IO调用后，会经历两个步骤：</p><p>①内核等待IO设备准备好数据</p><p>②内核将数据从内核空间拷贝到用户空间。</p><h3 id="常见IO模型"><a href="#常见IO模型" class="headerlink" title="常见IO模型"></a>常见IO模型</h3><p>IO模型一共有5种：<strong>同步阻塞IO、同步非阻塞IO、IO多路复用、信号驱动IO和异步IO。</strong></p><p><img src="https://i.loli.net/2021/03/28/T7scDifw4X8qd6R.png" alt="image-20210328143748177.png"></p><h4 id="同步阻塞BIO"><a href="#同步阻塞BIO" class="headerlink" title="同步阻塞BIO"></a>同步阻塞BIO</h4><p>BIO属于同步阻塞IO模型。</p><p>同步阻塞IO模型中，应用程序发起read调用后，会一直阻塞，直到内核把数据拷贝到用户空间中。</p><p>在客户端连接数量不高的情况下是没问题的，但是并发量高的时候，传统BIO模型是无能为力的。</p><p><strong>流程描述：</strong>当用户进程调用了<code>recv()/recvfrom()</code>这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。第二个阶段：当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><p><strong>优点：</strong>开发简单，在阻塞等待期间，用户线程挂起，在挂起期间不会占用CPU资源；</p><p><strong>缺点：</strong>一个线程维护一个IO，不适合大并发，在并发量法的时候需要创建大量的线程来维护网络连接，内存、线程开销非常大。</p><p><img src="https://i.loli.net/2021/03/28/on3GwdbV12lCkuO.png" alt="image-20210328143338881.png"></p><h4 id="同步非阻塞NIO"><a href="#同步非阻塞NIO" class="headerlink" title="同步非阻塞NIO"></a>同步非阻塞NIO</h4><p>同步非阻塞IO模型中，应用程序会一直发起read调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到内核把数据拷贝到用户空间中。</p><p>相比于同步阻塞IO模型，同步非阻塞IO模型确实有了很大改进，通过轮训操作，避免了一直阻塞。</p><p>但是这种IO模型同样存在问题：应用程序不断进行IO系统调用，轮询数据是否已经准备好的过程是十分消耗CPU资源的。</p><p><strong>流程描述：</strong>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><p><strong>优点：</strong>每次发起IO调用，在内核等待数据的过程中可以立即返回，用户线程不会阻塞，实时性较好。</p><p><strong>缺点：</strong>占用大量CPU时间，一般web服务器不会采用此模式。</p><p><img src="https://i.loli.net/2021/03/28/m9BRtIA4OlGE7CW.png" alt="image-20210328143548723.png"></p><h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>IO多路复用类似于非阻塞，只不过轮询不是由用户线程去执行，而是由内核空间去轮询，内核监听程序监听到数据准备好后，调用内核函数复制到用户态。</p><p>IO多路复用模型中，线程首先发起select调用，询问内核数据是否准备就绪，等内核把数据准备好了， 用户线程再发起read调用，read调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p><p><strong>IO多路复用模型，通过减少无效的系统调用，减少了对CPU资源的消耗。</strong></p><h4 id="知识铺垫"><a href="#知识铺垫" class="headerlink" title="知识铺垫"></a>知识铺垫</h4><p><strong>文件描述符</strong></p><p>创建文件描述符，文件描述符其实就是一个数字代表的数据结构</p><p><strong>普通文件的文件描述符</strong></p><pre class=" language-shell"><code class="language-shell">exec 6< 1.txt # 创建一个文件描述符6，用6这个数字代表对1.txt的读操作exec 7> 1.txt # 创建一个文件描述符6，用6这个数字代表对1.txt的写操作exec 8<> 1.txtlsof -op $$lsof -p $BASHPID # 两个命令都可以查看当前进程正在使用的文件的描述符#以及进到 当前进程的 fd文件夹也可以看到,$$代表当前进程的ID号cd /proc/$$/fdecho "hhh" >& 7 # 往1.txt里边写数据read a  0<&  6 # 就可以读取到第一行数据</code></pre><p>每个进程都有自己的文件描述符，因为进程的隔离，所以不同进程维护的各自的文件描述符可以是重复的，也就是说不同进程的相同的文件描述符可以指向不同的文件</p><p>假如不同进程的相同的文件描述符指向了同一个文件，他们仍然各自维护了自己的偏移量指针，也就是每个进程可以各自访问自己区域</p><p><strong>socket文件描述符</strong></p><pre class=" language-shell"><code class="language-shell"># 创建socket文件描述符exec 8<> /dev/tcp/www.baidu.comlsof -op $$</code></pre><p>socket类型的文件描述符也会有自己的缓存数据的区域，但是这个数据不是要刷盘的，是要通过网卡发走的，中间经历了网络各种层间的协议，包装成数据包发往目标IP地址。</p><pre class=" language-shell"><code class="language-shell">socket() = 3 # socket系统调用返回一个文件描述符，内核开辟一个空间，用该文件描述符指代此空间bind(3, 8090); # 把这个空间与 8090端口绑定，一旦8090端口有数据到达，放到这块内存空间中linsten(3); # 开始监听这个内存区域accept(3,  #BIO阶段 accpet 阻塞，一旦有数据到达，就返回一个新的文件描述符</code></pre><hr><p><strong>目前支持IO多路复用的系统调用：</strong></p><p>①select：<strong>线性扫描</strong>（轮询）所有监听的文件描述符，不管他们是不是活跃的，有最大数量限制。（32位系统1024,64位系统2048）</p><p>②poll：同select，不过数据结构不同，需要分配一个pollfd结构数组，维护在内核中，它没有大小限制。</p><p>③epoll：用于替代poll和select，没有大小限制，使用一个文件描述符管理多个文件描述符，使用红黑树存储，同时使用事件驱动代替了轮询。epoll_ctl中注册的文件描述符在事件触发的时候会通过回调机制激活该文件描述符，epoll_wait便会收到通知。</p><blockquote><p>select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。select或poll调用之后，会阻塞进程，与blocking IO阻塞不同在于，此时的select不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理。</p></blockquote><p><strong>流程描述：</strong>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回`。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><p><strong>优点：</strong>系统不必创建大量线程，只使用一个线程，一个选择器即可同时处理成千上万个连接，大大减少了系统开销。</p><p><strong>缺点：</strong>本质上，select/epoll系统调用是阻塞的，属于同步IO，需要在读写事件就绪后，由系统调用进行阻塞的读写。</p><p><img src="https://i.loli.net/2021/03/28/z2VXjPxbatElUwN.png" alt="image-20210328143630121.png"></p><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>select 函数监视的客户端的文件描述符分3类，分别是writefds、readfds、和exceptfds。<strong>调用后select函数会阻塞，直到有描述符就绪</strong>（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">select</span> <span class="token punctuation">(</span>    <span class="token keyword">int</span> nfds<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前有多少个文件描述符的状态 </span>    fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//监控有读数据到达文件描述符集合</span>    fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//监控写数据到达文件描述符集合</span>    fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//监控异常发生到达文件描述符集合</span>    <span class="token keyword">struct</span> timeval <span class="token operator">*</span>timeout<span class="token comment" spellcheck="true">//定时阻塞监控时间</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>fd_set可以理解为一个集合，这个集合中存放的是文件描述符(file descriptor)，即文件句柄</strong></p><p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p><ol><li><p><strong>select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。</strong></p></li><li><p><strong>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。</strong></p><p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll做的。</p></li><li><p><strong>需要维护一个用来存放大量fd的数据结构（位图bitmap），这样会使得用户空间和内核空间在传递该结构时复制开销大</strong>。</p></li></ol><h5 id="select实现"><a href="#select实现" class="headerlink" title="select实现"></a>select实现</h5><p><img src="https://img-blog.csdnimg.cn/20191225102740357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3OTA3Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//判断fd是否在集合中，在就返回非0值；否则，返回0</span><span class="token keyword">void</span> <span class="token function">FD_CLR</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//将set清空</span><span class="token keyword">void</span> <span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//将fd设置到set集合中去</span><span class="token keyword">void</span> <span class="token function">FD_ZERO</span><span class="token punctuation">(</span>fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//将set清空</span></code></pre><p>上半部分主要做了两件事：创建了socket客户端；创建了5个文件描述符，并把这5个文件描述符放入到了数组中。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//select方法的参数</span><span class="token keyword">int</span> <span class="token function">select</span> <span class="token punctuation">(</span>    <span class="token keyword">int</span> nfds<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//</span>    fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//读文件描述符集合</span>    fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//写文件描述符集合</span>    fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//异常描述符集合</span>    <span class="token keyword">struct</span> timeval <span class="token operator">*</span>timeout <span class="token comment" spellcheck="true">//超时时间</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//我们更关心读文件操作，所以其他可以置为NULL，其中第二个参数&amp;rset是一个bitmap，用于表征哪些文件描述符是被启用的或者说被监听的。这个bitmap大小为1024位</span></code></pre><p>将rset从用户态拷贝到内核态，由内核态直接判断文件描述符是否有数据的操作，这样效率更高；</p><p>以前判断时需要由用户态切换到内核态，所以效率低。</p><p><img src="https://i.loli.net/2021/03/28/2UEct6fNIHXw1sd.png" alt="image-20210328205336927.png"></p><blockquote><p><strong>select函数执行流程：</strong></p><p><strong>select是一个阻塞函数，当没有数据时，会一直阻塞在select那一行；</strong></p><p><strong>当有数据时会将&amp;rset中对应的那一位置为1;</strong></p><p><strong>select函数返回，不再阻塞；</strong></p><p><strong>遍历文件描述符数组fds，和读事件集合rset对比，判断哪个fd被置位了；</strong></p><p><strong>读取数据，然后处理。</strong></p></blockquote><p><strong>select函数的缺点：</strong></p><p>①bitmap默认大小为1024，虽然可以调整，但还是有限度的；</p><p>②rset每次循环都必须重新置位为0，不可重复使用；</p><p>③尽管将rset从用户态拷贝到内核态，由内核态判断是否有数据，但还是有拷贝的开销；</p><p>④当有数据时select就会返回，但是select函数并不知道哪个文件描述符有数据了，后面还需要再次对文件描述符数组进行遍历，效率比较低。</p><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>poll几乎和select原理相同，但是poll并非使用位图（fd_set）来记录每一个文件描述符，而是使用pollfd结构体（多个就采用链表），使得poll支持的文件描述符集合限制远大于select的1024（或2048）.</p><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> pollfd <span class="token operator">*</span>fds<span class="token punctuation">,</span> nfds_t nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> pollfd <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> fd<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 需要被检测或选择的文件描述符</span>        <span class="token keyword">short</span> events<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 对文件描述符fd上感兴趣的事件</span>        <span class="token keyword">short</span> revents<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 文件描述符fd上当前实际发生的事件</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> pollfd_t<span class="token punctuation">;</span></code></pre><p><strong>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：</strong></p><ol><li>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li><li>poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li></ol><h5 id="poll实现"><a href="#poll实现" class="headerlink" title="poll实现"></a>poll实现</h5><p><img src="https://img-blog.csdnimg.cn/20191225104248991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3OTA3Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> pollfd <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> fd<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 文件描述符</span>        <span class="token keyword">short</span> events<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在意的事件是什么，如果在于读就是POLLIN，如果在意写就是POLLOUT</span>        <span class="token keyword">short</span> revents<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对于events的回馈，开始时为0，当有数据可读时就设置为POLLIN，类似于上面的rset</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> pollfd_t<span class="token punctuation">;</span></code></pre><p><img src="https://i.loli.net/2021/03/28/gwqGEMLz9ot3YmD.png" alt="image-20210328211029954.png"></p><blockquote><p><strong>poll的执行流程：</strong></p><p><strong>将五个fd从用户态拷贝到内核态；</strong></p><p><strong>poll为阻塞方法，执行poll方法，如果有数据会将fd对应的revents置为POLLIN；</strong></p><p><strong>poll方法返回；</strong></p><p><strong>循环遍历，查找哪个fd被置为了POLLIN</strong></p><p><strong>将revents重置为0，便于复用；</strong></p><p><strong>对置位的fd进行读取和处理</strong></p></blockquote><p>相对于select，poll解决了bitmap大小的限制，采用了数组；解决了rset不可重用的情况，后面由于二者原理相同，所以没有解决</p><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><p>相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event <span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>1、epoll_create函数先创建一个epoll句柄，参数size表明内核要监听的描述符数量再通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知<br>2、IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数（底层红黑树）来实现的。只有就绪的fd才会执行回调函数。</p><p>epoll优点：</p><ol><li><p>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</p></li><li><p>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p></li><li><p>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p></li></ol><h5 id="epoll实现"><a href="#epoll实现" class="headerlink" title="epoll实现"></a>epoll实现</h5><p><img src="https://img-blog.csdnimg.cn/20191225105244845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3OTA3Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>epoll_create(int size)返回一个文件描述符，该文件描述符描述的是内核中的一块内存区域；</p><p>创建一个红黑树，最多监听size个节点，但是size只是给Linux内核的建议。</p></li><li><p>epoll_ctl()用来操作内核事件表；</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//op: EPOLL_CTL_ADD/MOD/DEL  红黑树的增删改操作</span><span class="token comment" spellcheck="true">//fd：文件描述符</span><span class="token comment" spellcheck="true">//设置event.events=EPOLLIN，监听这个文件描述符是否可读，表示是否客户端通过这个文件描述符向我请求连接</span><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这个event中还包含一个结构体</span><span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    uint32_t u32<span class="token punctuation">;</span>    uint64_t u64<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> epoll_data_t<span class="token punctuation">;</span><span class="token keyword">struct</span> epoll_event<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//events: EPOLLIN/OUT/ERR  读监听/写监听</span>    <span class="token comment" spellcheck="true">//文件描述符可读是说通过这个文件描述符能够从socket中读出数据，表示客户端向socket写数据了</span>    uint32_t events<span class="token punctuation">;</span>     epoll_data_t data<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>epoll_wait()该函数返回就绪文件描述符的个数 。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event <span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><blockquote><p>epoll_create(10)创建一个红黑树；</p><p>epoll_ctl()在红黑树中添加元素，写入五个节点（epoll_event）;</p><p>epoll_event为包含fd和event的结构体，与poll很类似；</p><p>最后得到了epfd传到了下面的方法epoll_wait();</p><p>epoll_wait()返回所监听的文件描述符满足条件的个数，并将满足的文件描述符放入创建的epoll_event数组中</p></blockquote><p>epoll是非阻塞的！！</p><p><strong>Epoll与File Descriptor</strong></p><p><img src="https://i.loli.net/2021/03/28/bIFg4z7AGSrOYxo.png" alt="image-20210328195206897.png"></p><p>比如1976是一个文件或者一个socket，在不同的地方被open了两次，两个描述项分别被两个不同的进程指向，即两个进程都打开了同一个文件。还有，同一个进程中两个描述符都指向了同一个描述项，<code>dup()</code>复制一个描述符，指向同一个描述项。还可以通过fork()，进程A fork 一个子进程B，比如fd2都指向同一个描述项。</p><p><img src="https://static.oschina.net/uploads/img/201604/21145832_RVDK.png" alt="输入图片说明"></p><p><img src="https://static.oschina.net/uploads/img/201604/21145942_TmnB.png" alt="输入图片说明"></p><p><img src="https://static.oschina.net/uploads/img/201604/21150044_PgJT.png" alt="输入图片说明"></p><h4 id="信号驱动式IO"><a href="#信号驱动式IO" class="headerlink" title="信号驱动式IO"></a>信号驱动式IO</h4><p>信号驱动式I/O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。过程如下图所示：</p><p><img src="https://i.loli.net/2021/03/28/GcJUyZWb7EQtPAo.png" alt="image-20210328173351586.png"></p><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><strong>流程描述：</strong>用户进程发起aio_read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它read操作完成了。</p><p><img src="https://i.loli.net/2021/03/28/4qnV9AbBLEwykJ1.png" alt="image-20210328143653337.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> IO模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS源码分析</title>
      <link href="2021/03/23/AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>2021/03/23/AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="AQS基本实现原理"><a href="#AQS基本实现原理" class="headerlink" title="AQS基本实现原理"></a>AQS基本实现原理</h3><p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code> 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p><p>AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:</p><ul><li>getState()</li><li>setState()</li><li>compareAndSetState()</li></ul><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的<strong>双向队列</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/AQS%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="AQS原理图"></p><p>AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p><p>我们也可以从源码中得知这一点：(这里只简单写几个重要属性)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractQueuedSynchronizer</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将每条请求共享资源的线程封装成一个Node结点</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//等待状态</span>        <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//前驱节点</span>        <span class="token keyword">volatile</span> Node prev<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//后继结点</span>        <span class="token keyword">volatile</span> Node next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//请求资源的线程</span>        <span class="token keyword">volatile</span> Thread thread<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//头结点</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//尾结点</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node tail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//共享变量</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p><p>　　不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p><img src="https://i.loli.net/2021/03/24/kCPIxtD75agr4vs.png" alt="image-20210323195730730.png"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h4><p>下面我们以ReentrantLock为例分析AQS的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>ReentrantLock<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestSync</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> ReentrantLock reentrantLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">testSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Thread t2 = new Thread()&amp;#123;</span>        <span class="token comment" spellcheck="true">//    @Override</span>        <span class="token comment" spellcheck="true">//    public void run() &amp;#123;</span>        <span class="token comment" spellcheck="true">//        testSync();</span>        <span class="token comment" spellcheck="true">//    &amp;#125;</span>        <span class="token comment" spellcheck="true">//&amp;#125;;</span>        <span class="token comment" spellcheck="true">//t2.setName("t2");</span>        <span class="token comment" spellcheck="true">//t2.start();</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        reentrantLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            reentrantLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>假设现在只有t1一个线程请求锁，我们来看一个底层是如何进行的。</p><p>首先我们找到lock()方法：</p><p>ReentrantLock的lock()方法是ReentrantLock类中的抽象静态内部类Sync的一个抽象方法，子类实现包括公平锁和非公平锁。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//...</span>        <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>以公平锁为例，lock()方法会调用acquire(1)，我们看一下acquire()方法，acquire是父类AQS中的方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//tryAcquire(arg)尝试加锁，如果加锁失败则会调用acquireQueued方法加入队列去排队，如果加锁成功则不会调用</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>继续，找到tryAcquire()方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>去子类ReentrantLock中找 (FairSync)：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//tryAcquire()尝试直接去获取资源，如果成功则直接返回</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//得到当前线程</span>            <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//获取共享资源的状态，判断这把锁是不是自由状态</span>            <span class="token comment" spellcheck="true">//如果锁是自由状态则=0，如果被上锁则为1，大于1表示重入</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//现在只有一个线程，目前c=0</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//找到hasQueuedPredecessors()方法，见后面。</span>                <span class="token comment" spellcheck="true">//这里得知锁没有被占用时，并没有第一时间去CAS，而是先判断自己是否需要排队！！</span>                <span class="token comment" spellcheck="true">//第一次hasQueuedPredecessors()返回false，然后CAS获取锁</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//设置持有锁的线程为当前线程，方面后面判断是不是重入</span>                    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果c不等于0，而且当前线程不等于拥有锁的线程则不会进else if 直接返回false，加锁失败</span>            <span class="token comment" spellcheck="true">//如果c不等于0，但是当前线程等于拥有锁的线程则表示这是一次重入，那么直接把状态+1表示重入次数+1</span>            <span class="token comment" spellcheck="true">//那么这里也侧面说明了reentrantlock是可以重入的，因为如果是重入也返回true，也能lock成功</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>找到hasQueuedPredecessors()方法：这里只简单说一下这个方法，后面会详细解释。（这个方法其实很复杂）</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//这个方法主要是判断自己是否需要排队</span><span class="token comment" spellcheck="true">//返回false，表示没有先驱结点，即不需要入队</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//此时tail和head都为null</span>        Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>         Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>        Node s<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//返回false</span>        <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><img src="https://i.loli.net/2021/03/24/1jw9vcXCYUAEDPM.png" alt="image-20210323200936540.png"></p><p>最终tryAcquire()方法返回true，一直向上返回，lock()正常返回，t1加锁成功。</p><p>当t1获取到锁后，线程t2请求获取锁，此时情况如何？</p><p>同样是上述流程，这里不再赘述，不一样的地方在于tryAcquire()，t2线程进入tryAcquire()返回false；</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//当前线程为t2</span>            <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//c=1</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果当前线程==当前持有锁的线程 （可重入时进入此代码块）</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//tryAcquire返回false，进入acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>执行到acquireQueued()方法，说明线程需要排队</p><p>需要排队有两种情况：</p><p>①线程1持有了锁，并没有释放，所以线程2来加锁的时候需要排队，但这个时候队列并没有初始化</p><p>②线程1持有了锁，没有释放，线程3来加锁时需要排队，此时队列被初始化了，队列中有人在排队，所以它也去排队。</p><p>我们先看一下addWaiter()方法：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//addWaiter()将该线程加入等待队列的尾部，传进来的参数为Node.EXCLUSIVE，表示设置为独占模式</span>    <span class="token keyword">private</span> Node <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node mode<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将当前线程实例化为一个node</span>        Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//此时tail为null</span>        Node pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//pred不为空表示队列已经初始化了，直接把当前线程封装的node的上一个节点设置成为pred,即原来的对尾</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//这里需要cas，因为防止多个线程加锁，确保node入队的时候是原子操作</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//继而把pred的下一个节点设置为node，这个node自己成为对尾了</span>                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token keyword">return</span> node<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果上面的if不成立就会执行到这里，表示第一种情况队列并没有初始化</span>        <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//自旋</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//第一次循环t=null</span>            <span class="token comment" spellcheck="true">//第二次循环t=空node</span>            Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//这里把队列头结点指向了一个空Node</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    tail <span class="token operator">=</span> head<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//t2结点入队</span>                node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将尾结点设为node</span>                    t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>                    <span class="token keyword">return</span> t<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>第一次循环：</p><p><img src="https://i.loli.net/2021/03/24/zPWa92JnbAmRgOK.png" alt="image-20210323203015695.png"></p><p><strong>队列中的队头结点永远是一个空结点，这里的空指的是Node里的Thread为空！！</strong></p><p>第二次循环：</p><p><img src="https://i.loli.net/2021/03/24/ybGlZ8wFm94dCnP.png" alt="image-20210323203636703.png"></p><p>设置头结点的原因之一：后面的节点可以通过自己的前驱结点是不是头结点来判断自己是不是第一个排队的。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这个node即刚入队的结点</span>        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//自旋</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//获取node的前驱结点</span>                <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果p是头结点，证明自己是第一个排队的，就尝试tryAcquire()一次自旋获取锁</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//如果获取到锁，将node设为头结点</span>                    <span class="token comment" spellcheck="true">//能够执行到这里表示我来加锁的时候，锁被持有了，我去排队，进到队列当中的时候发觉我前面那个人没有park，</span>                <span class="token comment" spellcheck="true">//前面那个人就是当前持有锁的那个人，那么我问问他搞完没有</span>                <span class="token comment" spellcheck="true">//能够进到这个里面就表示前面那个人搞完了；所以这里能执行到的几率比较小；但是在高并发的世界中这种情况真的需要考虑</span>                <span class="token comment" spellcheck="true">//如果我前面那个人搞完了，我得到锁了，那么前面那个人直接出队列，我自己则是队首；这行代码就是设置自己为队首</span>                    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                      p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 方便 GC</span>                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果自旋一次没有获取到锁，则阻塞</span>                <span class="token comment" spellcheck="true">//通过park()进入waiting状态，直到被unpark()。如果不可中断的情况下被中断了，那么会从park()中醒过来，发现拿不到资源，从而继续进入park()等待。</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>如果自旋一次没有获取到锁（因为t1一直占用锁，所以自旋获取不到），则进入shouldParkAfterFailedAcquire(p, node)，此时难点来了：</p><p>看代码，第一次waitStatus=0，直接返回false；acquireQueued()进行第二次自旋，此时再次进入shouldParkAfterFailedAcquire(p, node)方法，return true;</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>Node pred<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注意这里取的是前驱结点的waitStatus！！</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//Node.SIGNAL=-1</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">do</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//注意是将前驱结点的ws设为-1！！</span>            <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>然后往下执行parkAndCheckInterrupt()；</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//park阻塞指定线程</span>        <span class="token keyword">return</span> Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果被唤醒，查看自己是不是被中断的。</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>所以t2线程阻塞在了这里。</p><p>park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。 </p><p>假设此时t3线程请求获取锁，过程不再赘述，t3也会加入到队列：</p><p><img src="https://i.loli.net/2021/03/24/incwSgbG6pelov4.png" alt="image-20210323213238402.png"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//t3的前驱结点为t2</span>                <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//p不是头结点，所以不会尝试自旋</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                      p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                     failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//改上一个节点的状态成功之后，自己park，到此加锁过程说完了</span>                    interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>再次重申：shouldParkAfterFailedAcquire()方法中，waitState每次改的是前驱结点的ws!!</p><p><img src="https://i.loli.net/2021/03/24/LIjG6M1lgmnsSHQ.png" alt="image-20210323214415363.png"></p><p><strong>为什么修改前驱结点的waitState而不修改自己的？</strong></p><p>每个node都有一个状态，默认为0，表示无状态，-1表示在park。AQS中，某个线程入队后，它首先会判断自己的上一个结点是不是正在阻塞休眠，如果是就将其waitState修改为-1，然后自己休眠。自己修改不了自己的，因为自己已经休眠了，改不了。那为什么不在自己休眠前将自己的waitState改为-1呢？因为你得确定你自己park了才是能改为-1，如果是在park前将waitState改为-1的话，如果park 出问题没有休眠就会出错。</p><p>所以只能先park，再改状态，但是问题你自己都park，完全释放CPU资源了，故而没有办法执行任何代码了，         所以只能别人来改，故而可以看到每次都是自己的后一个节点把自己改成-1状态。</p><p>总结一下加锁过程：</p><p><img src="https://i.loli.net/2021/03/24/Gsb8rV2YEDamJeR.png" alt="AQS加锁过程.png"></p><p>接下来看如何释放：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</span><span class="token comment" spellcheck="true">//它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Node h <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//找到头结点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//唤醒等待队列里的下一个线程</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//公平锁的tryRelease，尝试去释放指定量的资源。</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> free<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>这个函数并不复杂。一句话概括：<strong>用unpark()唤醒等待队列中最前边的那个未放弃线程</strong>，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进行下一次循环，然后进入if (p == head &amp;&amp; tryAcquire(arg))的判断，然后s把自己设置成head结点，表示自己已经获取到资源了，acquire()也返回了！</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//此方法用于唤醒等待队列中下一个线程</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//传入的node为头结点</span>        <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将等待状态设为0</span>        Node s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//找到下一个需要唤醒的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果为空，或者ws>0表示当前结点已取消调度</span>            s <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//从后往前找有效结点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                    s <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span>            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//唤醒</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//在被阻塞的地方唤醒</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>ReentrantLocK获取锁的方法除了lock()还有lockInterruptibly();</p><p>lock 与 lockInterruptibly比较区别在于：<br>lock 优先考虑获取锁，待获取锁成功后，才响应中断。<br>lockInterruptibly 优先考虑响应中断，而不是响应锁的普通获取或重入获取。</p><p>详细区别：</p><p>ReentrantLock.lockInterruptibly允许在等待时由其它线程调用等待线程的Thread.interrupt方法来中断等待线程的等待而直接返回，这时不用获取锁，而会抛出一个InterruptedException。 ReentrantLock.lock方法不允许Thread.interrupt中断,即使检测到Thread.isInterrupted,一样会继续尝试获取锁，失败则继续休眠。只是在最后获取锁成功后再把当前线程置为interrupted状态,然后再中断线程。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span>            <span class="token keyword">throws</span> InterruptedException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//判断线程的中断标识，如果为true，则抛出中断异常。</span>        <span class="token comment" spellcheck="true">//即如果程序中在加锁之前当前线程被打断了(Thread.currentThread().interrupt())，会抛出异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// tryAcquire尝试加锁，如果获取失败，则执行doAcquireInterruptibly</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">doAcquireInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><code>tryAcquire</code>方法目的是尝试获取锁，与前面提到的是一致的，不再赘述，直接看<code>tryAcquire</code>失败后执行的<code>doAcquireInterruptibly</code></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//当前线程加入等待队列</span>        <span class="token keyword">final</span> Node node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//自旋</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//获取前驱结点</span>                <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果前驱结点为头结点，并且当前线程能够成功获取锁</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将当前结点设为头结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//判断是否可以阻塞线程并做相应操作</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抛出中断异常</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>这里lock()和lockInterruptibly()有一个明显区别：</p><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">//lockInterruptibly()</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//lock()</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre><p>两个方法的parkAndCheckInterrupt()内容是一样的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//park阻塞指定线程</span>        <span class="token keyword">return</span> Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果被唤醒，查看自己是不是被中断的。</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>我们先来看lock()方法：</p><p>假如t2在等待的过程中被打断，当t1释放锁唤醒t2时，回到<code>LockSupport.park(this)</code>这个位置，然后通过<code>Thread.interrupted()</code>发现自己是被中断的，返回true，然后给<code>interrupted</code>赋值为true，然后再次进入for循环，在<code>if (p == head &amp;&amp; tryAcquire(arg))</code>中直接返回true。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                      p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                     failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里直接返回了true</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                     interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>所以acquireQueued返回true；</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//acquireQueued返回true进入if代码块</span>            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>执行<code>selfInterrupt()</code>又把自己打断了一次</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//注意这里又执行了一次interrupt()方法，这次是清除标志位</span>        <span class="token comment" spellcheck="true">//第一次interrupt后：Thread.interrupt()=true</span>        <span class="token comment" spellcheck="true">//第二次interrupt后：Thread.interrupt()=false</span>        <span class="token comment" spellcheck="true">//因为这里不恢复标志位的话，用户在外面调用Thread.interrupt()时返回的结果是错误的</span>        Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>注意：</p><p><code>Thread.interrupt()</code>只是一个中断标识，不会中断一个正在运行的线程，它的作用是在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞状态。</p><p>我们再来看lockInterruptibly()方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>假如t2在等待的过程中被打断，当t1释放锁唤醒t2时，回到<code>LockSupport.park(this)</code>这个位置，然后通过<code>Thread.interrupted()</code>判断自己是否被中断，发现自己是被中断的，返回true进入if代码块，t2直接抛出中断异常</p><p>上述是以公平锁为例分析的；</p><p>接下来看一看公平锁与非公平锁的区别：</p><p><img src="https://i.loli.net/2021/03/24/iOasURqk5thSwZP.png" alt="公平锁与非公平锁.png"></p><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>上述总结了独占锁的源码，下面我们看一下共享锁：</p><p>此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">doAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：</p><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回；</li><li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Node node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>SHARED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加入队列尾部</span>        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//是否成功标志</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等待过程中是否被中断过的标志</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前驱结点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果当前结点是头结点的下一个</span>                    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//尝试获取指定量的资源</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取成功</span>                        <span class="token comment" spellcheck="true">//将head指向自己，还有剩余资源可以再唤醒之后的线程</span>                        <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                         p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果等待过程中被打断过，此时将中断补上</span>                            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>其实这个方法和acquireQueued()很相似，只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样。</p><p>跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> propagate<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>         <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//head指向自己</span>        <span class="token comment" spellcheck="true">//如果还有剩余量，就继续唤醒下一个邻居线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>propagate <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> h <span class="token operator">==</span> null <span class="token operator">||</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>            <span class="token punctuation">(</span>h <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Node s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//唤醒后继结点，后面会说</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</p><p>至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：</p><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回；</li><li>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。</li></ol><p>其实跟acquire()的流程大同小异，只不过多了个<strong>自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）</strong>。</p><p>接下来看看释放资源：<code>releaseShared()</code></p><p>此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//尝试释放资源</span>            <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//唤醒后继结点</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>　此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//唤醒后继结点</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> ws <span class="token operator">=</span> h<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// loop to recheck cases</span>                    <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//唤醒后继</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                         <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Node<span class="token punctuation">.</span>PROPAGATE<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// loop on failed CAS</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> head<span class="token punctuation">)</span>                   <span class="token comment" spellcheck="true">// loop if head changed</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        AQS是JUC中很多同步组件的构建基础，简单来讲，它内部实现主要是状态变量state和一个FIFO队列来完成，同步队列的头结点是当前获取到同步状态的结点，获取同步状态state失败的线程，会被构造成一个结点（或共享式或独占式）加入到同步队列尾部（采用自旋CAS来保证此操作的线程安全），随后线程会阻塞；释放时唤醒头结点的后继结点，使其加入对同步状态的争夺中。</p><p>　　AQS为我们定义好了顶层的处理实现逻辑，我们在使用AQS构建符合我们需求的同步组件时，只需重写tryAcquire，tryAcquireShared，tryRelease，tryReleaseShared几个方法，来决定同步状态的释放和获取即可，至于背后复杂的线程排队，线程阻塞/唤醒，如何保证线程安全，都由AQS为我们完成了，这也是非常典型的模板方法的应用。AQS定义好顶级逻辑的骨架，并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现。</p><p>​        另外值得注意的是，acquire()和acquireShared()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()。</p>]]></content>
      
      
      
        <tags>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解线程池</title>
      <link href="2021/03/22/%E8%AF%A6%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2021/03/22/%E8%AF%A6%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h3><p>说到线程池，第一个问题便是<strong>为什么要用线程池?</strong></p><p>线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，<strong>如果线程数量超过了最大数量，超出数量的线程排队等候</strong>，等其他线程执行完毕，再从队列中取出任务来执行。</p><p>它的主要特点为：<strong>线程复用;控制最大并发数;管理线程。</strong></p><p>《Java 并发编程的艺术》提到的<strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="线程池如何使用？"><a href="#线程池如何使用？" class="headerlink" title="线程池如何使用？"></a>线程池如何使用？</h3><p>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，<strong>ThreadPoolExecutor</strong>这几个类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadPool</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//一池5个受理线程，类似一个银行有5个受理窗口</span>        <span class="token comment" spellcheck="true">//ExecutorService threadPool = Executors.newFixedThreadPool(5);</span>        <span class="token comment" spellcheck="true">//一池一个工作线程</span>        <span class="token comment" spellcheck="true">//ExecutorService threadPool = Executors.newSingleThreadExecutor();</span>        ExecutorService threadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//模拟有10个顾客来银行办理业务，目前池子里有5个员工提供服务</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t办理业务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//TimeUnit.MILLISECONDS.sleep(400);</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>①Executors.newFixedThreadPool(int)  固定容量</p><p>执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                  0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的是LinkedBlockingQueue</p><p>②Executors.newSingleThreadExecutor() 单例的、单个线程的线程池</p><p>一个任务一个任务的执行，一池一线程</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>newSingleThreadExecutor 创建的线程池corePoolSize和maximumPoolSize值都是1，它使用的是LinkedBlockingQueue</p><p>③Executors.newCachedThreadPool() 缓存的 即超出就自动创建线程的</p><p>执行很多短期异步任务，线程池根据需要创建新线程，但在先前构建的线程可用时将重用它们。可扩容，遇强则强</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                  60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>newCachedThreadPool创建的线程池将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，它使用的是SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p><h3 id="ThreadPoolExecutor底层原理"><a href="#ThreadPoolExecutor底层原理" class="headerlink" title="ThreadPoolExecutor底层原理"></a>ThreadPoolExecutor底层原理</h3><p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 用给定的初始参数创建一个新的ThreadPoolExecutor。     */</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span>                              BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                              ThreadFactory threadFactory<span class="token punctuation">,</span>                              RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>            keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>线程池几个重要参数</strong></p><p>1、corePoolSize：线程池中的常驻核心线程数</p><p>2、maximumPoolSize：线程池中能够容纳同时执行的最大线程数，此值必须大于等于1</p><p>3、keepAliveTime：多余的空闲线程的存活时间，当前池中线程数量超过corePoolSize时，当空闲时间达到keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止</p><p>4、unit：keepAliveTime的单位 </p><p>5、workQueue：任务队列，被提交但尚未被执行的任务</p><p>6、threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认的即可</p><p>7、handler：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略</p><h3 id="线程池的主要处理流程"><a href="#线程池的主要处理流程" class="headerlink" title="线程池的主要处理流程"></a>线程池的主要处理流程</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="图解线程池实现原理"></p><p>1、在创建了线程池后，开始等待请求。</p><p>2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：</p><p>​    ①如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</p><p>​    ②如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</p><p>​    ③如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p><p>​    ④如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</p><p>3、当一个线程完成任务时，它会从队列中取下一个任务来执行。</p><p>4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</p><p>​    ①如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。</p><p>​    ②所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</p><h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><p>ThreadPoolExecutor.AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</p><p>ThreadPoolExecutor.CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</p><p>ThreadPoolExecutor.DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中尝试再次提交当前任务。</p><p>ThreadPoolExecutor.DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><strong>在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多？超级大坑</strong></p><p><strong>答案是一个都不用，我们工作中只能使用自定义的</strong></p><p>Executors中JDK已经给你提供了，为什么不用？</p><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>Executors 返回线程池对象的弊端如下：</p><ul><li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li><li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized常见面试题</title>
      <link href="2021/03/22/synchronized%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/03/22/synchronized%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/interview-questions/synchronized%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="img"></p><h3 id="1、说说自己对于synchronized关键字的了解"><a href="#1、说说自己对于synchronized关键字的了解" class="headerlink" title="1、说说自己对于synchronized关键字的了解"></a>1、说说自己对于synchronized关键字的了解</h3><p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p><p>在Java早期版本中，synchronized属于重量级锁，一个线程获取到锁，其他线程都被阻塞挂起，这是十分消耗性能的，因为挂起或者唤醒一个线程都需要操作系统帮忙完成，而操作系统实现线程之间的切换需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，成本相对较高。</p><p>但是在Java 6 后，官方对synchronized进行了较大的优化，引入 了如自旋锁、偏向锁、轻量级锁等技术（具体不再赘述，详细可以看前面《Java多线程》这篇文章），所以现在synchronized的锁效率已经优化的很不错了。</p><h3 id="2、说说自己是怎么使用synchronized关键字的"><a href="#2、说说自己是怎么使用synchronized关键字的" class="headerlink" title="2、说说自己是怎么使用synchronized关键字的"></a>2、说说自己是怎么使用synchronized关键字的</h3><p>①修饰实例方法：作用于当前对象加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//业务代码</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>②修饰静态方法：也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token keyword">static</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//业务代码</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>注意：</p><p>如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁</strong>。</p><p>③修饰代码块：指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>当前 class 的锁</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//业务代码</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="3、构造方法可以使用synchronized关键字修饰吗？"><a href="#3、构造方法可以使用synchronized关键字修饰吗？" class="headerlink" title="3、构造方法可以使用synchronized关键字修饰吗？"></a>3、构造方法可以使用synchronized关键字修饰吗？</h3><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。所以<strong>构造方法不能使用 synchronized 关键字修饰。</strong></p><h3 id="4、说说JDK1-6后的synchronized关键字底层做了哪些优化？"><a href="#4、说说JDK1-6后的synchronized关键字底层做了哪些优化？" class="headerlink" title="4、说说JDK1.6后的synchronized关键字底层做了哪些优化？"></a>4、说说JDK1.6后的synchronized关键字底层做了哪些优化？</h3><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><p>详细可以参见前面的文章《Java多线程》。</p><h3 id="5、谈谈synchronized和ReentrantLock的区别"><a href="#5、谈谈synchronized和ReentrantLock的区别" class="headerlink" title="5、谈谈synchronized和ReentrantLock的区别"></a>5、谈谈synchronized和ReentrantLock的区别</h3><p>①两者都是可重入锁</p><p>②synchronized依赖于JVM而ReentrantLock依赖于API</p><p>synchronized底层是C++写的，并没有直接暴露给我们，ReentrantLock可以直接查看源代码。</p><p>③ReentrantLock比synchronized增加了一些高级功能</p><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><h3 id="6、若synchronized方法抛出异常，会导致死锁吗？"><a href="#6、若synchronized方法抛出异常，会导致死锁吗？" class="headerlink" title="6、若synchronized方法抛出异常，会导致死锁吗？"></a>6、<strong>若synchronized方法抛出异常，会导致死锁吗？</strong></h3><p>JVM会自动释放锁，不会导致死锁问题</p><h3 id="7、synchronized的锁对象能为空吗？会出现什么情况？"><a href="#7、synchronized的锁对象能为空吗？会出现什么情况？" class="headerlink" title="7、synchronized的锁对象能为空吗？会出现什么情况？"></a>7、<strong>synchronized的锁对象能为空吗？会出现什么情况？</strong></h3><p>锁对象不能为空，否则抛出NPE(NullPointerException)</p><h3 id="8、synchronized的继承问题"><a href="#8、synchronized的继承问题" class="headerlink" title="8、synchronized的继承问题"></a>8、synchronized的继承问题</h3><p>重写父类的synchronized的方法，主要分为两种情况：</p><p>①子类的方法没有被synchronized修饰：</p><p>synchronized的不具备继承性。所以子类方法是线程不安全的。</p><p>②子类的方法被synchronized修饰(这里面试点主要考察锁对象的归属问题)：</p><p>两个锁对象其实是一把锁，而且是<strong>子类对象作为锁</strong>。这也证明了: synchronized的锁是可重入锁。否则将出现死锁问题。</p><h3 id="9、在开发过程中，你经常使用synchronized方法多还是synchronized代码块？and-why"><a href="#9、在开发过程中，你经常使用synchronized方法多还是synchronized代码块？and-why" class="headerlink" title="9、在开发过程中，你经常使用synchronized方法多还是synchronized代码块？and why?"></a>9、<strong>在开发过程中，你经常使用synchronized方法多还是synchronized代码块？and why?</strong></h3><p>synchronized同步的范围是越小越好。因为若该方法耗时很久，那其它线程必须等到该持锁线程执行完才能运行。(黄花菜都凉了都…)<br>而synchronized代码块部分只有这一部分是同步的，其它的照样可以异步执行，提高运行效率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程那些事</title>
      <link href="2021/03/22/%E7%BA%BF%E7%A8%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>2021/03/22/%E7%BA%BF%E7%A8%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>从JVM角度说说进程和线程之间的关系</p><h2 id="图解进程和线程的关系"><a href="#图解进程和线程的关系" class="headerlink" title="图解进程和线程的关系"></a>图解进程和线程的关系</h2><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="img"></p><p>一个进程中可以有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p><p><strong>总结：</strong> <strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p><p>下面来思考这样一个问题：为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p><h3 id="程序计数器为什么是私有的？"><a href="#程序计数器为什么是私有的？" class="headerlink" title="程序计数器为什么是私有的？"></a>程序计数器为什么是私有的？</h3><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><h3 id="虚拟机栈和本地方法栈为什么是私有的？"><a href="#虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的？"></a>虚拟机栈和本地方法栈为什么是私有的？</h3><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h2 id="线程生命周期和状态"><a href="#线程生命周期和状态" class="headerlink" title="线程生命周期和状态"></a>线程生命周期和状态</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。从源码中也可以看到。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java 线程的状态 "></p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java 线程状态变迁 "></p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h4 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h4><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程</title>
      <link href="2021/03/16/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/03/16/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>概念</strong></p><p>多道程序环境下允许多个程序并发执行，进程就是为了更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p><p>进程就是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。系统资源指的是处理机、存储器和其他设备服务于某个进程的时间，例如把处理机资源理解为处理机的时间片才是准确的。因为进程是这些资源分配和调度的独立单位，这就决定了进程一定是一个动态的、过程性的概念。</p><hr><p><strong>结构</strong></p><p>①进程控制块PCB：进程实体的一部分，进程存在的唯一标识，包括进程描述信息、控制和管理信息、资源分配清单和处理机相关信息。</p><p>②程序段：就被进程调度程序调度到CPU执行的程序代码段。</p><p>③数据段：进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p><hr><p><strong>特征</strong></p><p>①动态性 进程是一次程序的执行，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。</p><p>②并发性 指多个进程同时存在于内存中，能在一段时间内同时运行。并发性是进程的重要特征，也是操作系统的重要特征。进入进程的目的就是为了使程序能与其他进程的程序并发执行，提高资源利用率。</p><p>③独立性 指进程实体是一个能独立运行、独立获得自由和独立接受调度的基本单位。</p><p>④异步性 由于进程的相互制约，会使进程具有执行的间断性，即进程按各自独立的，不可预知的速度向前推进。</p><p>⑤结构性 每个进程都配置有一个进程控制块PCB对其进行描述，从结构上看进程实体是由程序段、数据段和PCB组成的。</p><hr><p><strong>进程的状态和转换</strong></p><p>①运行态 进程正在处理机上运行</p><p>②就绪态 进程已处于准备运行的状态，获得了除处理机外的一切资源</p><p>③阻塞态 进程正在等待某一事件而暂停运行，如等待某资源可用或等待输入/输出流</p><p>④创建态 进程正在被创建，尚未转到就绪态</p><p>⑤结束态 进程正从系统中消失，可能是正常结束或其他原因中断退出</p><p>就绪-&gt;运行：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片）</p><p>运行-&gt;就绪：处于运行态的进程在时间片用完后，不得不让出处理机。在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程序将正在执行的进程转为就绪态，让更高优先级的进程执行。</p><p>运行-&gt;阻塞：进程请求某一资源的使用和分配或等待某事件的发生（如IO完成），进程以系统调用的形式请求操作系统提供服务。</p><p>阻塞-&gt;就绪：进程等待的事件到来时，如IO结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞转为就绪态。</p><hr><p><strong>进程控制</strong></p><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><p><strong>进程的创建：</strong></p><p>允许一个进程创建另一个进程，创建者为父进程，被创建者为子进程。子进程可以继承父进程所拥有的资源，当子进程被撤销时，应将父进程的资源归还。撤销父进程时，必须同时撤销所有子进程。</p><p><strong>进程的创建过程：</strong></p><p>①为新进程分配一个唯一的进程标识号，并申请一个空白PCB。②为进程分配资源，为新进程的程序和数据分配必要内存空间。若资源不足不会创建失败而是进入阻塞态。③初始化PCB，包括标志信息，处理机状态信息，进程优先级等。④若进程就绪队列未满，就将新进程插入就绪队列等待被调度。</p><p><strong>进程的终止：</strong></p><p>正常结束，表示进程任务已经完成并准备退出运行。异常结束，表示进程在运行时发生了某种异常，使程序无法继续运行，例如非法指令，IO故障等。外界干预，指进程因为外界请求而终止，例如操作系统干预或父进程请求终止等。</p><p><strong>进程终止过程：</strong></p><p>①根据被终止进程的标识符，检索PCB，读出该进程的状态。②若处于执行状态，终止执行，将处理机资源分配给其他进程。③若进程还有子进程，应将所有子进程终止。④将该进程的全部资源归还给父进程或操作系统。⑤将PCB从所在队列删除。</p><p><strong>进程的阻塞过程：</strong></p><p>①找到将要被阻塞进程的PCB。②如果为运行态，保护现场转为阻塞态，停止运行。③把PCB插入相应事件的等待队列。</p><p><strong>进程的唤醒过程</strong>：</p><p>①在该事件的等待队列中找到进程对应的PCB。②将其从等待队列中移除，设置状态为就绪态。③将PCB插入就绪队列，等待调度程序调度。</p><p><strong>进程的切换过程：</strong></p><p>①保存处理机上下文，包括程序计数器和其他寄存器。②更新PCB信息。③把进程的PCB移入相应的队列。④选择另一个进程执行并更新其PCB。⑤更新内存管理的数据结构。⑥恢复处理机上下文。</p><hr><p><strong>进程通信</strong></p><p>①<strong>共享存储</strong>：在通信的进程之间存在一块可以直接访问的共享空间，共享存储分为两种：低级的共享基于数据结构，高级的共享基于存储区。操作系统只负责为通信进程提供可共享的存储空间和同步互斥工具，数据交换由用户自己安排读写指令完成。</p><p>②<strong>消息传递</strong>：进程间的数据交换以格式化的消息为单位，进程提供系统提供的发送消息和接收消息两个原语进行数据交换。消息传递分为：直接通信方式，把消息挂在接收进程的消息缓存队列上。间接通信方式，发送进程把消息发送到某个中间实体，中间实体一般称作信箱，相应的通信系统为电子邮件系统。</p><p>③<strong>管道通信</strong>：消息传递的一种特殊方式，管道就是连接一个读进程和一个写进程来实现它们通信的一个共享文件。管道可以理解为共享存储的优化和发展，管道通信中存储空间优化为缓冲区，缓冲区只允许一边写入另一边读出，只要缓冲区有数据进程就能从缓冲区读出，只要有数据写进程就不会往缓冲区写数据，因此管道通信是半双工通信。</p><hr><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>概念</strong></p><p>引入进程的目的是为了多道程序更好的并发执行，提高资源利用率和吞吐量；引入线程的目的是为了减少程序在并发执行时的时空开销，提高操作系统的并发性能。</p><p>线程就是一种轻量级的进程，是一个基本的CPU执行单位，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是操作系统独立调度和分配的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它与同一进程下的其他线程共享进程的全部资源。</p><hr><p><strong>线程和进程的区别</strong></p><p>进程是操作系统资源分配的基本单位；线程是处理器任务调度和执行的基本单位。</p><p>①调度：进程是拥有资源的基本单位，而线程是独立调度的基本单位。在同一进程中，线程的切换不会引起进程的切换。在不同进程中线程的切换会引起进程切换。</p><p>②拥有资源：不管是传统操作系统还是有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源，只有一点运行中必不可少的资源。如果线程也是拥有资源的单位，那么切换线程就需要较大的时空开销，它的引入就没有意义。</p><p>③系统开销：创建和撤销进程设计资源的分配和回收，操作系统的开销远大于创建或撤销线程的开销。进程切换也需要涉及CPU环境的保存和新调度到进程CPU环境的设置，但线程切换只需要保存和设置少量的寄存器容量，开销很小。</p><p>④地址空间：进程的地址空间之间互相独立，同一进程的各个线程共享进程的资源，进程内的线程对其他进程不可见。</p><p>⑤通信：进程间通信需要同步和互斥手段的辅助，保证数据一致性。线程可以直接读写进程数据段（全局变量）来进行通信。</p><hr><p><strong>线程的实现方式</strong></p><p>①用户级线程：有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</p><p>②内核级线程：线程管理的所有工作都由操作系统内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态才能完成。</p><p>③组合方式：将n个用户级线程映射到m个内核级线程上（n&gt;=m），操作系统只看得见内核级线程，因此只有内核级线程才是处理机分配的单位。</p><hr><p><strong>多线程模型</strong></p><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了”多线程模型”问题。</p><p>多对一模型：多个用户级线程映射到一个内核级线程，每个用户进程只对应一个内核级线程。</p><p>​        优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。</p><p>​        缺点：当一个用户级线程被堵塞后，整个进程都会被堵塞，并发度不高。</p><p>一对一模型：一个用户级线程映射到一个内核级线程，每个用户进程有与用户线程同数量的内核级线程。</p><p>​        优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。</p><p>​        缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态。</p><p>多对多模型：n个用户级线程映射到m个内核级线程（n&gt;=m)，每个用户级进程对应m个内核级线程。</p><p>​        克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p><h3 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h3><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。</p><p>我们把一个时间段内只允许一个进程使用的资源称为临界资源。</p><p>对临界资源的访问必须互斥地进行，互斥又称为间接制约关系，进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待，当前访问临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>定义</strong></p><p>死锁就是指多个进程因为互相竞争资源而陷入的一种僵局，如果没有外力的作用，这些进程都无法继续向前推进。</p><p><strong>原因</strong></p><p>死锁的原因包含了①不可剥夺资源数量的不足，如果是可剥夺资源是不会造成死锁的。②进程的推进顺序非法，进程请求和释放资源的顺序不当，例如进程P1和P2分别占用资源R1和R2，而此时P1和P2又分别申请资源R2和R1。③信号量的使用不当，彼此等待对方的消息。</p><p>死锁有四个必要条件：</p><p>①互斥条件，进程对资源的占用具有排他性控制，如果进程请求的资源已被占用，请求就会被阻塞。</p><p>②不可剥夺条件，当一个资源没有被使用完成前是不能被其他进程强行获取的，只有占用它的进程主动释放才可以。</p><p>③请求和保持条件，一个进程已经占有了某个资源，又要请求其他资源，而该资源被其他进程占用，请求被阻塞，但进程也不会释放自己已经占有的资源。</p><p>④循环等待条件，存在一个进程资源的循环等待链，链中每个进程已经占有的资源同时是其他进程请求的资源。</p><p><strong>预防</strong></p><p>事先预防，实现起来比较简单，但是条件严格，效率很低。</p><p>①破坏互斥条件，系统中的所有资源都允许共享，但是有的资源不能同时访问，不太现实。</p><p>②破坏不可剥夺条件，允许剥夺其他进程已经占有的资源，可能会造成前段工作的失效，如果频繁发送就会增加系统开销，严重降低系统的吞吐量。</p><p>③破坏请求和保持条件，采用预先资源分配法，一次性分配进程需要的所有资源，缺点是会严重浪费系统资源。</p><p>④破坏循环等待条件，采用顺序资源分配法， 确定是会造成编程不便。</p><p><strong>避免</strong></p><p>同样也是事先预防，不同的是动态地根据情况来避免死锁，性能比较好。</p><p>①系统安全状态，不安全的系统可能会导致死锁，安全的系统状态不会导致死锁，如果资源分配不会进入不安全的系统状态就给进程分配资源。</p><p>②银行家算法，把操作系统视为银行家，操作系统管理的资源视为资金，进程向操作系统申请资源相当于贷款。采用预先资源分配策略，主要的数据结构是可利用的资源向量，分配矩阵，需求矩阵，最大需求矩阵。</p><p><strong>检测</strong></p><p>画出资源分配图，圆圈表示进程，框表示一类资源。进程到资源是请求边，资源到进程是分配边。然后利用死锁定理来简化资源分配图，如果S不可被完全简化那么代表是一个死锁。</p><p><strong>解除</strong></p><p>如果没有采取死锁的预防和避免，就要采用死锁的检测和解除。</p><p>①资源剥夺法：挂起某些死锁进程并剥夺其资源。</p><p>②撤销进程法：撤销一个甚至全部死锁进程并剥夺其资源。</p><p>③进程回退法：让一个或多个进程回到不至于造成死锁的状态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存穿透与缓存雪崩</title>
      <link href="2021/03/16/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
      <url>2021/03/16/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis缓存穿透和雪崩（面试高频）"><a href="#Redis缓存穿透和雪崩（面试高频）" class="headerlink" title="Redis缓存穿透和雪崩（面试高频）"></a>Redis缓存穿透和雪崩（面试高频）</h1><p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题，其中，最要害的问题就是数据的一致性问题，从严格意义上讲，这个问题无解，如果对数据的一致性要求很高，那么就不能使用缓存。</p><p>另外的一些典型问题就是缓存穿透、缓存雪崩和缓存击穿。目前业界也都有比较流行的解决方案。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库中没有，也就是缓存没有命中，于是向持久层数据库查询，发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库，这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>①<strong>布隆过滤器</strong></p><p><strong>布隆过滤器的巨大用处就是，能够迅速判断一个元素是否在一个集合中</strong>。因此他有如下三个使用场景:</p><ol><li>网页爬虫对URL的去重，避免爬取相同的URL地址</li><li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）</li><li>缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。</li></ol><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式储存，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。</p><p>比如：垃圾网站和正常网站加起来全世界据统计也有几十亿个。网警要过滤这些垃圾网站，总不能到数据库里面一个一个去比较吧，这就可以使用布隆过滤器。假设我们存储一亿个垃圾网站地址。可以先有一亿个二进制比特，然后网警用八个不同的随机数产生器（F1,F2, …,F8） 产生八个信息指纹（f1, f2, …, f8）。接下来用一个随机数产生器 G 把这八个信息指纹映射到 1 到1亿中的八个自然数 g1, g2, …,g8。最后把这八个位置的二进制全部设置为一。过程如下：</p><p><img src="https://pics6.baidu.com/feed/21a4462309f79052696269b62519dfcc7acbd52d.jpeg?token=77d2a5fe27c3fd42d7ae7a07d68fadec&s=7DA434729B0A4D495EE195DF000050B3" alt="img"></p><p>有一天网警查到了一个可疑的网站，想判断一下是否是XX网站，首先将可疑网站通过哈希映射到1亿个比特数组上的8个点。如果8个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。</p><p>那这个布隆过滤器是如何解决redis中的缓存穿透呢？很简单首先也是对所有可能查询的参数以hash形式存储，当用户想要查询的时候，使用布隆过滤器发现不在集合中，就直接丢弃，不再对持久层查询。</p><p><img src="https://pics6.baidu.com/feed/d788d43f8794a4c2773846a5251e13d3ac6e3910.jpeg?token=029a90d30125df6852018a7e4e7294ff&s=1AA27423D99E44C80E5CE5DE000080B1" alt="img"></p><p><strong>②缓存空对象</strong></p><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p><p><img src="https://pics6.baidu.com/feed/203fb80e7bec54e7a4ba970397d293564ec26a4d.jpeg?token=0068420533f90cb97750b10ce30053b8&s=9A027C239B9E4DC848DDC4D6000080B2" alt="img"></p><p>但是这种方法会存在两个问题：</p><p>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</p><p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><p>当某个key在过期的瞬间，有大量的请求并发访问，由于缓存过期，会同时访问数据库，并写回缓存，导致数据库压力瞬间增大。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>①设置热点数据永不过期</p><p>②加互斥锁，保证每个key同时只有一个线程去查询后端服务，其他线程等待。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>缓存雪崩是指，缓存层出现了错误，缓存集中失效，不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。 （Redis宕机或者断电）</p><p><img src="https://pics3.baidu.com/feed/9c16fdfaaf51f3dec6606ae3a504f81938297953.jpeg?token=3f9f811a459ba91f1295f1fbaccf5cb7&s=BEAA742387E7490B0A5974C8000030B0" alt="img"></p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>①redis高可用</strong></p><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。   异地多活</p><p><strong>②限流降级</strong></p><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><p><strong>③数据预热</strong></p><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握手与四次挥手</title>
      <link href="2021/03/16/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>2021/03/16/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="TCP的三次握手与四次挥手"><a href="#TCP的三次握手与四次挥手" class="headerlink" title="TCP的三次握手与四次挥手"></a>TCP的三次握手与四次挥手</h3><p>TCP的请求和响应都是数据包，它们之间都是经过由TCP创建的一个从客户端发起，服务端接收的类似连接的通道，这个连接可以一直保持，http请求是在这个连接的基础上发送的。</p><p>在一个TCP连接上是可以发送多个http请求的，不同的版本这个模式不一样。</p><p>在HTTP/1.0中，这个TCP连接是在http请求创建的时候同步创建的，http请求发送到服务器端，服务器端响应了之后，这个TCP连接就关闭了。</p><p>HTTP/1.1中，可以以某种方式声明这个连接一直保持，一个请求传输完之后，另一个请求可以接着传输。这样的好处是：在创建一个TCP连接的过程中需要三次握手的消耗，如果TCP连接保持，第二个请求发送就没有这个三次握手的消耗。</p><p>HTTP/2中同一个TCP连接里还可以并发地传输http请求。</p><p>TCP报文中比较重要的字段：</p><p>（1）<strong>序号（sequence number）</strong>：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p><p>（2）<strong>确认号（acknowledgement number）</strong>：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</p><p>（3）<strong>标志位（Flags）</strong>：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：</p><blockquote><p>URG：紧急指针（urgent pointer）有效。</p><p><strong>ACK：确认序号有效。</strong></p><p>PSH：接收方应该尽快将这个报文交给应用层。</p><p>RST：重置连接。</p><p><strong>SYN：发起一个新连接。</strong></p><p><strong>FIN：释放一个连接。</strong></p></blockquote><p>所谓的三次握手即TCP连接的建立，这个连接必须是一方主动打开，另一方被动打开的。以客户端主动发起连接为例：</p><p><img src="https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>握手之前主动打开连接的客户端结束CLOSED阶段，被动打开的服务器端也结束CLOSED阶段，并进入LISTEN阶段。随后开始“三次握手”：</p><p>（1）首先客户端向服务器端发送一段TCP报文。（SYN=1，Seq=x）</p><p>其中标志位为SYN，表示请求建立新连接；序号为Seq=x（x一般为1）；随后客户端进入SYN-SENT阶段。</p><p>（2）服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段，并返回一段TCP报文。</p><p>其中标志位为SYN与ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接。</p><p>标志位SYN=1，ACK=1，序号Seq=y，确认号Ack=x+1，表示收到客户端的序号Seq并将其加1作为自己的确认号，随后服务器端进入SYN-RCVD阶段。</p><p>（3）客户端收到来自服务器端的确认收到数据的TCP后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段，并返回最后一段TCP报文：</p><p>其中标志位为ACK，表示确认收到服务器端同意连接的信号。序号为Seq=x+1,表示收到服务器的确认号Ack，并将其值加1作为自己的序号值。确认号为Ack=y+1,表示收到服务器端序号Seq,并将其值加1作为自己的确认号Ack值。随后客户端进入ESTABLISHED阶段。</p><p>服务器收到来自客户端的“确认收到服务器数据”的TCP报文之后，明确了从服务器到客户端的数据传输是正常的。结束SYN-SENT阶段，进入ESTABLISHED阶段。</p><p>在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性。一旦出现某一方发出的TCP报文丢失，便无法继续”握手”，以此确保了”三次握手”的顺利完成。</p><p><strong>为什么要进行第三次握手？</strong></p><p>为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>客户端请求连接，如果服务器直接就创建了这个连接，但返回数据包时因为网络原因丢失了，客户端一直没有收到，超时后关闭创建连接的请求，进行超时重传，但服务器不知道客户端收没收到，服务器的端口就一直开着，客户端超时重传后，服务器又重新开启一个端口连接，造成服务器端开销的严重浪费。</p><p>所谓四次挥手即TCP连接的释放。连接的释放必须是一方主动释放，另一方被动释放。以客户端主动发起释放连接为例：</p><p><img src="https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>挥手之前主动释放连接的客户端结束ESTABLISHED阶段。随后开始“四次挥手”：</p><p>（1）首先客户端想要释放连接，向服务器端发送一段TCP报文。</p><p>其中标志位为FIN，表示请求释放连接；序号为Seq=U；随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。</p><p>（2）服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文。</p><p>标志位为ACK，表示接收到客户端发送的释放连接的请求；序号为Seq=V；确认号为Ack=U+1；表示是在收到客户端报文的基础上，将其序号值加1作为本段报文的确认号的值；随后服务器端开始准备释放服务器端到客户端方向上的连接。</p><p>客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段。</p><blockquote><p>前”两次挥手”既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了。</p></blockquote><p>（3）服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接的准备，再次向客户端发出一段TCP报文。</p><p>其中标志位为FIN，ACK，表示已经准备好释放连接了。序号Seq=W；确认号Ack=U+1，表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值。</p><p>随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。</p><p>（4）客户端收到从服务器端发出的TCP报文，确认了服务器端已经做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中：</p><p>标志位ACK，表示接受到服务器准备好释放连接的信号；序号为Seq=U+1，表示是在收到了服务器端报文的基础上，将其确认号Ack值作为本段报文序号的值。确认号为Ack=W+1，表示是在收到了服务器端报文的基础上，将其序号值+1作为本段报文确认号的值。</p><p>随后客户端开始在TIME-WAIT阶段等待2MSL。</p><blockquote><p>后“两次挥手”既让客户端知道了服务器端准备好释放连接了，也让服务器端知道了客户端了解了自己准备好释放连接了。于是，可以确认关闭服务器端到客户端方向上的连接了，由此完成“四次挥手”。</p></blockquote><p><strong>为什么“握手”是三次，“挥手”却要四次？</strong></p><p>TCP建立连接时之所以只需要”三次握手”，是因为在第二次”握手”过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。</p><p>即SYN建立连接报文与ACK确认接收报文是在同一次”握手”当中传输的，所以”三次握手”不多也不少，正好让双方明确彼此信息互通。</p><p>TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次”握手”传输的。为何建立连接时一起传输，释放连接时却要分开传输？</p><blockquote><p>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。</p><p>释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。</p></blockquote><p>所以是“三次握手”，“四次挥手”。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 三次握手 </tag>
            
            <tag> 四次挥手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP与HTTPS</title>
      <link href="2021/03/16/HTTP%E4%B8%8EHTTPS/"/>
      <url>2021/03/16/HTTP%E4%B8%8EHTTPS/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>HTTP是超文本传输协议</strong>，规范了浏览器如何向万维网服务器请求万维网文档，服务器如何向浏览器发送万维网文档。从层次的角度看，HTTP是面向事务的应用层协议，是浏览器和服务器之间的传送数据文件的重要基础。</p><p><strong>HTTP是无状态的</strong>，之所以说无状态是因为HTTP对事务没有记忆性。同一个客户第二次访问同一个服务器，服务器的响应结果和第一次是一样的。HTTP的无状态简化了服务器的设计，允许服务器支持高并发的HTTP请求。如果要解决无状态的问题，可以使用cookie和session。Cookie相当于服务器给浏览器的一个通行证，是一个唯一识别码，服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器，服务器就可以识别是否是同一个客户。Session是服务器的会话技术，是存储在服务器的。区别：①Cookie只能存储ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选Session。②Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密。③对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 </p><hr><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>HTTP报文分为HTTP请求报文和响应报文，请求报文由请求行（请求方法，请求资源的URL和HTTP的版本）、首部行和实体（通常不用）组成。响应报文由状态行（状态码，短语和HTTP版本）、首部行和实体（有些不用）组成。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>GET：主要同于获取资源，用于访问被URI统一资源标识符识别的资源。</p><p>POST：主要用于传递信息给服务器。</p><p>参数：GET和POST的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而POST的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具查看。</p><p>安全性：安全的HTTP方法不会改变服务器状态，也就是说它只是可读的。GET方法是安全的，而POST却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 </p><p>发送数据：XMLHttpRequest是一个 API，在Ajax中大量使用。它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。 </p><p>使用XMLHttpRequest时，GET请求发送一个TCP数据包，浏览器同时发送HTTP header和data，服务器响应状态码200。POST每次发送两个TCP数据包，浏览器先发送HTTP header，服务器收到后返回100（continue），浏览器再继续发送data，服务器响应200。</p><p>PUT 上传文件 DELETE 删除文件 OPTIONS 查看当前URL支持的HTTP方法 HEAD 获取首部</p><hr><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>①先检查输入的URL是否合法，然后查询浏览器的缓存，如果有则直接显示。</p><p>②通过DNS域名解析服务解析IP地址，先从浏览器缓存查询、然后是操作系统和hosts文件的缓存，如果没有查询本地服务器的缓存。</p><p>③通过TCP的三次握手机制建立连接，建立连接后向服务器发送HTTP请求，请求数据包。</p><p>④服务器收到浏览器的请求后，进行处理并响应。</p><p>⑤浏览器收到服务器数据后，如果可以就存入缓存。</p><p>⑥浏览器发送请求内嵌在HTML中的资源，例如css、js、图片和视频等，如果是未知类型会弹出对话框。</p><p>⑦浏览器渲染页面并呈现给用户。</p><p><strong>面试题：在浏览器中输入URL后，执行的全部过程。（一次完整的http请求过程）</strong></p><ol><li><p>域名解析</p></li><li><p>TCP三次握手</p></li><li><p>建立TCP连接后发起http请求</p></li><li><p>服务器收到请求并响应http请求</p></li><li><p>浏览器解析HTML代码，并请求HTML代码中的资源（css、js等）</p></li><li><p>根据是不是长连接来判断是否断开TCP连接（四次挥手）</p></li><li><p>浏览器对页面进行渲染，呈现给用户。</p></li></ol><hr><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><p>HTTP/1.0使用的是非持续连接，每次请求文档就有2倍的RTT开销，另外客户和服务器每一次建立新的TCP连接都要分配缓存和变量，这种非持续连接会给服务器造成很大的压力。</p><p>HTTP/1.1使用的是持续连接，服务器会在发送响应后在一段时间内继续保持这条连接，使同一个浏览器和服务器可以继续在这条连接上传输后续的HTTP请求和响应报文。HTTP1.1的持续连接有两种工作方式，非流水线和流水线方式。非流水线方式就是客户在收到前一个响应后才能发送下一个请求，流水线方式是客户收到响应前就能连着发送新的请求。</p><p>HTTP/2：多路复用，即连接共享，即每个request都是用作连接共享机制的，一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request载归属到各自不同的服务器端请求里面。</p><hr><h3 id="HPPTS"><a href="#HPPTS" class="headerlink" title="HPPTS"></a>HPPTS</h3><p><strong>HTTP有很大的安全隐患：使用明文进行通信，内容可能会被窃听。</strong>不验证通信方的身份，通信方的身份有可能遭遇伪装。无法证明报文的完整性，报文有可能遭篡改。 </p><p><strong>HTTPS是以安全为目标的HTTP通道，</strong>S代表security，让HTTP先和SSL通信，再由SSL和TCP 通信，也就是说 HTTPS使用了隧道进行通信。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><p>HTTPS标准端口443，HTTP标准端口80;</p><p>HTTPS需要用到SSL证书，而HTTP不用;</p><p><strong>流程</strong></p><p>加密算法主要有对称加密和非对称加密，<strong>对称加密的运算速度快，但安全性不高</strong>。</p><p>对称加密算法中，数据发信方将明文（<a href="http://baike.baidu.com/view/3364695.htm">原始数据</a>）和加密<a href="http://baike.baidu.com/view/934.htm">密钥</a>一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的<a href="http://baike.baidu.com/view/934.htm">密钥</a>及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的<a href="http://baike.baidu.com/view/934.htm">密钥</a>只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。</p><p>非对称密钥加密，加密和解密使用不同的密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 </p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。<strong>非对称加密的运算速度慢，但是更安全</strong>。<strong>HTTPS采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。</strong></p><p>①浏览器和服务器建立TCP连接后，会发送一个证书请求，其中包含了自己可以实现的算法列表和一些必要信息，用于商议双方使用的加密算法。</p><p>②服务器收到请求后会选择加密算法，然后返回证书，包含了服务器的信息，域名、申请证书的公司、加密的公钥以及加密的算法等。</p><p>③浏览器收到之后，检查签发该证书的机构是否正确，该机构的公钥签名是否有效，如果有效就生成对称密钥，并利用公钥对其加密，然后发送给服务器。</p><p>④服务器收到密钥后，利用自己的私钥解密。之后浏览器和服务器就可以基于对称加密对数据进行加密和通信。</p><p><strong>HTTPS原理：</strong></p><p>1、客户端请求SSL连接，并将自己支持的加密规则发给网站；</p><p>2、服务器端将自己的身份信息以证书的形式返回给客户端。证书里面包含了网站地址，加密公钥，以及证书的颁发机构；（这里把加密公钥放到证书中，主要证书可信公钥就是可信的，防止了公钥被篡改）</p><p>3、获得证书后，客户端要做以下工作验证证书的合法性，如果证书受信任，客户端会生成一串随机数的密码，并用证书提供的公钥进行加密，将加密好的随机数发给服务器；</p><p>4、获得客户端发的加密了的随机数后，服务器用自己的私钥进行解密，得到这个随机数，把这个随机数作为对称加密的秘钥。</p><p>5、之后服务器与客户之间就可以用随机数对各自的信息进行加密，解密。</p><p>总结：</p><p><strong>客户端请求–&gt;服务端发送证书（公钥）–&gt;客户端验证证书，并生成随机数，通过公钥加密后发送给服务端–&gt;服务端用私钥解密出随机数–&gt;对称加密传输数据。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的IoC与AOP</title>
      <link href="2021/03/16/Spring%E7%9A%84IoC%E4%B8%8EAOP/"/>
      <url>2021/03/16/Spring%E7%9A%84IoC%E4%B8%8EAOP/</url>
      
        <content type="html"><![CDATA[<p><strong>IoC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。</strong>在Java开发中，<strong>IoC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</strong></p><p>在理解IoC之前，我们先来说说程序的耦合与解耦。</p><h4 id="程序的耦合"><a href="#程序的耦合" class="headerlink" title="程序的耦合"></a>程序的耦合</h4><p>耦合是对模块间关联程度的度量，耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。</p><p>模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。<strong>模块间联系越多，其耦合性越强，同时表明其独立性越差。</strong></p><p>在软件工程中，耦合指的是对象之间的依赖性，对象之间的耦合度越高，维护成本就越高，因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准，<strong>划分模块的一个重要准则就是高内聚低耦合。</strong></p><h5 id="内聚与耦合"><a href="#内聚与耦合" class="headerlink" title="内聚与耦合"></a>内聚与耦合</h5><p><strong>内聚标志一个模块内各个元素彼此结合的紧密程度</strong> ，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来衡量模块内的联系。一个好的内聚模块应当恰好做一件事，它描述的是模块内的功能联系。</p><p>耦合是软件结构中各模块之间相互连接的一种度量。</p><p><strong>程度讲究的是高内聚低耦合，就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。</strong></p><p>在实际开发中，有些依赖关系是必须的，有些依赖关系可以通过优化代码来解除的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccountServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">IAccountService</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> IAccountDao accountDao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AccountDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>上面的代码表示业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类，如果此时没有持久层实现类，编译将不能通过，这种编译依赖关系应该在开发中杜绝。</p><h4 id="程序的解耦"><a href="#程序的解耦" class="headerlink" title="程序的解耦"></a>程序的解耦</h4><p>解耦的思路：</p><p>第一步：使用反射创建对象，避免使用new。</p><p>第二步：通过配置文件获取要创建对象的全限定类名。</p><h4 id="工厂模式解耦"><a href="#工厂模式解耦" class="headerlink" title="工厂模式解耦"></a>工厂模式解耦</h4><p>在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件（<strong>反射机制</strong>），把这些对象创建出来并存起来，在接下来使用的时候直接拿过来就好。</p><p>这个读取配置文件，创建和获取三层对象的类就是工厂。</p><h4 id="控制反转IOC"><a href="#控制反转IOC" class="headerlink" title="控制反转IOC"></a>控制反转IOC</h4><h5 id="谁控制谁，控制什么"><a href="#谁控制谁，控制什么" class="headerlink" title="谁控制谁，控制什么"></a>谁控制谁，控制什么</h5><p>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序<strong>主动去创建</strong>依赖对象；而IoC是有专门一个容器（map）来创建这些对象，即由Ioc容器来控制对象的创建；<strong>谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</strong></p><h5 id="为何是反转，哪些方面反转了"><a href="#为何是反转，哪些方面反转了" class="headerlink" title="为何是反转，哪些方面反转了"></a>为何是反转，哪些方面反转了</h5><p>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？<strong>因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</strong></p><p>明确IOC的作用：降低程序间的耦合。</p><h4 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h4><p>依赖注入是IOC的具体实现。</p><p>我们的程序在编写时，通过控制反转，把对象的创建交给了spring，但是代码中不可能没有依赖的情况，IOC的解耦只是降低他们的依赖关系，但不会消除，比如我们的业务层仍会调用持久层的方法。</p><p>那这种业务层和持久层的依赖关系，在使用spring后，就让spring来维护了。</p><p>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p><p>​        ●谁依赖于谁：当然是<strong>应用程序依赖于IoC容器</strong>；</p><p>　　●为什么需要依赖：<strong>应用程序需要IoC容器来提供对象需要的外部资源</strong>；</p><p>　　●谁注入谁：很明显是<strong>IoC容器注入应用程序某个对象，应用程序依赖的对象</strong>；</p><p>　　●注入了什么：就是<strong>注入某个对象所需要的外部资源（包括对象、资源、常量数据）</strong>。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</strong></p><p><strong>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的</strong>。</p><h4 id="面向切面编程AOP"><a href="#面向切面编程AOP" class="headerlink" title="面向切面编程AOP"></a>面向切面编程AOP</h4><p><strong>Aop即面向切面编程，简单地说就是将代码中重复的部分抽取出来，在需要执行的时候使用动态代理的技术，在不修改源码的基础上对方法进行增强。</strong>优点是可以减少代码的冗余，提高开发效率，维护方便。<strong>Spring会根据类是否实现了接口来判断动态代理的方式，如果实现了接口会使用JDK的动态代理，核心是InvocationHandler接口和Proxy类，如果没有实现接口会使用cglib的动态代理，cglib是在运行时动态生成某个类的子类，如果某一个类被标记为final，是不能使用cglib动态代理的。</strong></p><h5 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h5><ul><li><p>Joinpoint(连接点):指那些被拦截到的点，在 spring 中这些点指的是方法，因为 spring 只支持方法类型的连接点。例如业务层实现类中的方法都是连接点。</p></li><li><p>Pointcut(切入点):指我们要对哪些 Joinpoint 进行拦截的定义。例如业务层实现类中被增强的方法都是切入点，切入点一定是连接点，但连接点不一定是切入点。</p></li><li><p>Advice(通知/增强):指拦截到 Joinpoint 之后所要做的事情。</p></li><li><p>Introduction(引介):引介是一种特殊的通知，在不修改类代码的前提下可以在运行期为类动态地添加一些方法或 Field。</p></li><li><p>Weaving(织入):是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。</p></li><li><p>Proxy（代理）:一个类被 AOP 织入增强后，就产生一个结果代理类。</p></li><li><p>Target(目标):代理的目标对象。</p></li><li><p>Aspect(切面):是切入点和通知（引介）的结合。</p></li></ul><h4 id="AOP底层源码分析"><a href="#AOP底层源码分析" class="headerlink" title="AOP底层源码分析"></a>AOP底层源码分析</h4><p>1）在使用ApplicationContext相关实现类加载bean的时候，会针对所有单例且非懒加载的bean，在构造ApplicationContext的时候就会创建好这些bean，而不会等到使用的时候才去创建。这也就是单例bean默认非懒加载的应用</p><p> 2）读者需要了解BeanPostProcessor的相关使用，所有实现BeanPostProcessor接口的类，在初始化bean的时候都会调用这些类的方法，一般用于在bean初始化前或后对bean做一些修改。而AOP的功能实现正式基于此，在bean初始化后创建针对该bean的proxy，然后返回给用户该proxy、</p><p>3）结合以上两点，被代理后的bean，实际在ApplicationContext构造完成之后就已经被创建完成，getBean()的操作直接从singletonObjects中获取即可</p><p>写个简单的例子进行分析。</p><blockquote><p>proxyTargetClass</p><ul><li>true<br>目标对象实现了接口 – 使用CGLIB代理机制<br>目标对象没有接口(只有实现类) – 使用CGLIB代理机制</li><li>false<br>目标对象实现了接口 – 使用JDK动态代理机制(代理所有实现了的接口)<br>目标对象没有接口(只有实现类) – 使用CGLIB代理机制</li></ul></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.yh"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//加了proxyTargetClass=true表示使用Cglib动态代理，原理见后面源码</span><span class="token annotation punctuation">@EnableAspectJAutoProxy</span><span class="token punctuation">(</span>proxyTargetClass<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccountService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">saveAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"saveAccount"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         *    通过下边的源码可以发现，Spring AOP在Spring容器初始化的时候就完成了代理！         *  那究竟是在哪里完成了代理的呢？         */</span>        ApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>App<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这里返回的accountService对象是代理对象，那么问题来了：是什么时候进行代理的呢？</span>        AccountService accountService <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>AccountService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        accountService<span class="token punctuation">.</span><span class="token function">saveAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>我们查看<code>getBean()</code>的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">getBean</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> requiredType<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>requiredType<span class="token punctuation">,</span> <span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>继续找getBean的源码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">getBean</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> requiredType<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    NamedBeanHolder<span class="token operator">&lt;</span>T<span class="token operator">></span> namedBean <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveNamedBean</span><span class="token punctuation">(</span>requiredType<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//下面的代码省略</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        </code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">private</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> NamedBeanHolder<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">resolveNamedBean</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> requiredType<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>requiredType<span class="token punctuation">,</span> <span class="token string">"Required type must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> candidateNames <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span>requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//下面的代码省略</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>candidateNames<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            String beanName <span class="token operator">=</span> candidateNames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NamedBeanHolder</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token function">getBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> requiredType<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>继续往下找到getBean()源码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">getBean</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> requiredType<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>            <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">doGetBean</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> requiredType<span class="token punctuation">,</span> args<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">doGetBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> String name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token keyword">final</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> requiredType<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Nullable</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token keyword">boolean</span> typeCheckOnly<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> String beanName <span class="token operator">=</span> <span class="token function">transformedBeanName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object bean<span class="token punctuation">;</span>        Object sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//下边代码省略</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>下面看一下getSingleton()方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">getSingleton</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> <span class="token keyword">boolean</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从单例池（一级缓存）当中直接拿，singletonObjects是一个Map&lt;String, Object>，缓存一个spring应用中的单例bean</span>        <span class="token comment" spellcheck="true">//这也是为什么getBean("xx")能获取一个初始化好bean的根本代码</span>        Object singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//下面的代码暂不分析</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> singletonFactory <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonFactory <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> singletonObject<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>那究竟是在哪里完成了代理的呢？</p><p>Spring在getBean(“xxx”)前先去单例池中找看有没有bean实例，如果没有的话再去创建bean</p><p>在DefaultSingletonBeanRegistry类中：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addSingleton</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> Object singletonObject<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//这里把代理对象放到单例池中</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>registeredSingletons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>创建bean:  <strong>先创建目标对象，再创建代理对象</strong></p><pre class=" language-java"><code class="language-java">                <span class="token comment" spellcheck="true">// Create bean instance.</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//getSingleton()有两个参数，第二个参数是ObjectFactory&lt;?> singletonFactory</span>                    <span class="token comment" spellcheck="true">//这里用了Lambda表达式，注意ObjectFactory&lt;?>是函数式接口，接口里有一个getObject()方法</span>                    sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            <span class="token keyword">return</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            <span class="token function">destroySingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>sharedInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">getSingleton</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> singletonFactory<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token string">"Bean name must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Object singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonsCurrentlyInDestruction<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationNotAllowedException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span>                            <span class="token string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> <span class="token operator">+</span>                            <span class="token string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Creating shared instance of singleton bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token function">beforeSingletonCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">boolean</span> newSingleton <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">boolean</span> recordSuppressedExceptions <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>suppressedExceptions <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>recordSuppressedExceptions<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>suppressedExceptions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//单例池中没有bean实例，新创建一个bean</span>                    singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//回到上面的Lambda表达式</span>                    newSingleton <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalStateException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeanCreationException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>recordSuppressedExceptions<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Exception suppressedException <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>suppressedExceptions<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            ex<span class="token punctuation">.</span><span class="token function">addRelatedCause</span><span class="token punctuation">(</span>suppressedException<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>recordSuppressedExceptions<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>suppressedExceptions <span class="token operator">=</span> null<span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token function">afterSingletonCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>newSingleton<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token function">addSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> singletonObject<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>createBean();</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">createBean</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> RootBeanDefinition mbd<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>            <span class="token keyword">throws</span> BeanCreationException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Creating instance of bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        RootBeanDefinition mbdToUse <span class="token operator">=</span> mbd<span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> resolvedClass <span class="token operator">=</span> <span class="token function">resolveBeanClass</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolvedClass <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">hasBeanClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> mbd<span class="token punctuation">.</span><span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            mbdToUse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span>mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>            mbdToUse<span class="token punctuation">.</span><span class="token function">setBeanClass</span><span class="token punctuation">(</span>resolvedClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            mbdToUse<span class="token punctuation">.</span><span class="token function">prepareMethodOverrides</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeanDefinitionValidationException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionStoreException</span><span class="token punctuation">(</span>mbdToUse<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    beanName<span class="token punctuation">,</span> <span class="token string">"Validation of method overrides failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Object bean <span class="token operator">=</span> <span class="token function">resolveBeforeInstantiation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbdToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> bean<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbdToUse<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span>                    <span class="token string">"BeanPostProcessor before instantiation of bean failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//在这个方法里面创建的对象！！！！！！！！！！</span>            Object beanInstance <span class="token operator">=</span> <span class="token function">doCreateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbdToUse<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Finished creating instance of bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> beanInstance<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeanCreationException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ImplicitlyAppearedSingletonException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>                    mbdToUse<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Unexpected exception during bean creation"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>doCreateBean();</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">doCreateBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> String beanName<span class="token punctuation">,</span> <span class="token keyword">final</span> RootBeanDefinition mbd<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token annotation punctuation">@Nullable</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>            <span class="token keyword">throws</span> BeanCreationException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Instantiate the bean.</span>        BeanWrapper instanceWrapper <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            instanceWrapper <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>factoryBeanInstanceCache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instanceWrapper <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//这个方法里面完成了对象创建，仅仅是对象，还不是bean</span>            instanceWrapper <span class="token operator">=</span> <span class="token function">createBeanInstance</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这里是目标对象</span>        <span class="token keyword">final</span> Object bean <span class="token operator">=</span> instanceWrapper<span class="token punctuation">.</span><span class="token function">getWrappedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> beanType <span class="token operator">=</span> instanceWrapper<span class="token punctuation">.</span><span class="token function">getWrappedClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>beanType <span class="token operator">!=</span> NullBean<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            mbd<span class="token punctuation">.</span>resolvedTargetType <span class="token operator">=</span> beanType<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Allow post-processors to modify the merged bean definition.</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span>postProcessingLock<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mbd<span class="token punctuation">.</span>postProcessed<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token function">applyMergedBeanDefinitionPostProcessors</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> beanType<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span>                            <span class="token string">"Post-processing of merged bean definition failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                mbd<span class="token punctuation">.</span>postProcessed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Eagerly cache singletons to be able to resolve circular references</span>        <span class="token comment" spellcheck="true">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span>        <span class="token keyword">boolean</span> earlySingletonExposure <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>allowCircularReferences <span class="token operator">&amp;&amp;</span>                <span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Eagerly caching bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span>                        <span class="token string">"' to allow for resolving potential circular references"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token function">addSingletonFactory</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Initialize the bean instance.</span>        Object exposedObject <span class="token operator">=</span> bean<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//在这个方法里面完成代理！！！！！！！！！！！！</span>            exposedObject <span class="token operator">=</span> <span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ex <span class="token keyword">instanceof</span> <span class="token class-name">BeanCreationException</span> <span class="token operator">&amp;&amp;</span> beanName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>BeanCreationException<span class="token punctuation">)</span> ex<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token punctuation">(</span>BeanCreationException<span class="token punctuation">)</span> ex<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>                        mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Initialization of bean failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Object earlySingletonReference <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonReference <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>exposedObject <span class="token operator">==</span> bean<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    exposedObject <span class="token operator">=</span> earlySingletonReference<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>allowRawInjectionDespiteWrapping <span class="token operator">&amp;&amp;</span> <span class="token function">hasDependentBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    String<span class="token punctuation">[</span><span class="token punctuation">]</span> dependentBeans <span class="token operator">=</span> <span class="token function">getDependentBeans</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    Set<span class="token operator">&lt;</span>String<span class="token operator">></span> actualDependentBeans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>dependentBeans<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span>String dependentBean <span class="token operator">:</span> dependentBeans<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">removeSingletonIfCreatedForTypeCheckOnly</span><span class="token punctuation">(</span>dependentBean<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            actualDependentBeans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>dependentBean<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>actualDependentBeans<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCurrentlyInCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span>                                <span class="token string">"Bean with name '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' has been injected into other beans ["</span> <span class="token operator">+</span>                                StringUtils<span class="token punctuation">.</span><span class="token function">collectionToCommaDelimitedString</span><span class="token punctuation">(</span>actualDependentBeans<span class="token punctuation">)</span> <span class="token operator">+</span>                                <span class="token string">"] in its raw version as part of a circular reference, but has eventually been "</span> <span class="token operator">+</span>                                <span class="token string">"wrapped. This means that said other beans do not use the final version of the "</span> <span class="token operator">+</span>                                <span class="token string">"bean. This is often the result of over-eager type matching - consider using "</span> <span class="token operator">+</span>                                <span class="token string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>initializeBean();</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">initializeBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> String beanName<span class="token punctuation">,</span> <span class="token keyword">final</span> Object bean<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> RootBeanDefinition mbd<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token punctuation">(</span>PrivilegedAction<span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">invokeAwareMethods</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token function">getAccessControlContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">invokeAwareMethods</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        Object wrappedBean <span class="token operator">=</span> bean<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isSynthetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            wrappedBean <span class="token operator">=</span> <span class="token function">applyBeanPostProcessorsBeforeInitialization</span><span class="token punctuation">(</span>wrappedBean<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">invokeInitMethods</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> wrappedBean<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>                    <span class="token punctuation">(</span>mbd <span class="token operator">!=</span> null <span class="token operator">?</span> mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">,</span>                    beanName<span class="token punctuation">,</span> <span class="token string">"Invocation of init method failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isSynthetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//在这里完成代理！！！！！！</span>            wrappedBean <span class="token operator">=</span> <span class="token function">applyBeanPostProcessorsAfterInitialization</span><span class="token punctuation">(</span>wrappedBean<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> wrappedBean<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>applyBeanPostProcessorsAfterInitialization();</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">applyBeanPostProcessorsAfterInitialization</span><span class="token punctuation">(</span>Object existingBean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span>            <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//existingBean是传入的原生bean</span>        Object result <span class="token operator">=</span> existingBean<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这里有7个beanProcessor，每个beanProcessor调用自己的postProcessAfterInitialization</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>BeanPostProcessor beanProcessor <span class="token operator">:</span> <span class="token function">getBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Object current <span class="token operator">=</span> beanProcessor<span class="token punctuation">.</span><span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            result <span class="token operator">=</span> current<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>BeanPostProcessor干扰bean的初始化，BeanPostProcessor调用postProcessAfterInitialization对bean进行动态代理！！！</p><p>进行代理的是AnnotationAwareAspectJAutoProxyCreator这个beanProcessor，<strong>之所以有这个beanProcessor是因为加了注解@EnableAspectJAutoProxy()</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Object cacheKey <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCacheKey</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>earlyProxyReferences<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//here！！</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wrapIfNecessary</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> cacheKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bean<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>执行wrapIfNecessary这个方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">wrapIfNecessary</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">,</span> Object cacheKey<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">hasLength</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>targetSourcedBeans<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> bean<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Boolean<span class="token punctuation">.</span>FALSE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>advisedBeans<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> bean<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isInfrastructureClass</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">shouldSkip</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> specificInterceptors <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAdvicesAndAdvisorsForBean</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span>TargetSource<span class="token punctuation">)</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>specificInterceptors <span class="token operator">!=</span> DO_NOT_PROXY<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>advisedBeans<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> Boolean<span class="token punctuation">.</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//here！！！</span>                Object proxy <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createProxy</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> specificInterceptors<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SingletonTargetSource</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>proxyTypes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> proxy<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> proxy<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>advisedBeans<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> Boolean<span class="token punctuation">.</span>FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> bean<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>advisedBeans<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> Boolean<span class="token punctuation">.</span>FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> bean<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>执行到createProxy()方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">createProxy</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> beanClass<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> String beanName<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> specificInterceptors<span class="token punctuation">,</span> TargetSource targetSource<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory <span class="token keyword">instanceof</span> <span class="token class-name">ConfigurableListableBeanFactory</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            AutoProxyUtils<span class="token punctuation">.</span><span class="token function">exposeTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ConfigurableListableBeanFactory<span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> beanClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        ProxyFactory proxyFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        proxyFactory<span class="token punctuation">.</span><span class="token function">copyFrom</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>proxyFactory<span class="token punctuation">.</span><span class="token function">isProxyTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">shouldProxyTargetClass</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                proxyFactory<span class="token punctuation">.</span><span class="token function">setProxyTargetClass</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">evaluateProxyInterfaces</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">,</span> proxyFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        Advisor<span class="token punctuation">[</span><span class="token punctuation">]</span> advisors <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">buildAdvisors</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> specificInterceptors<span class="token punctuation">)</span><span class="token punctuation">;</span>        proxyFactory<span class="token punctuation">.</span><span class="token function">addAdvisors</span><span class="token punctuation">(</span>advisors<span class="token punctuation">)</span><span class="token punctuation">;</span>        proxyFactory<span class="token punctuation">.</span><span class="token function">setTargetSource</span><span class="token punctuation">(</span>targetSource<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">customizeProxyFactory</span><span class="token punctuation">(</span>proxyFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        proxyFactory<span class="token punctuation">.</span><span class="token function">setFrozen</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>freezeProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">advisorsPreFiltered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            proxyFactory<span class="token punctuation">.</span><span class="token function">setPreFiltered</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> proxyFactory<span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getProxyClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>执行proxyFactory.getProxy();</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createAopProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>createAopProxy()创建返回AopProxy，AopProxy接口有两个实现类：CglibAopProxy和JdkDynamicAopProxy，那具体返回哪一个，看getAopProxyFactory().createAopProxy(this);方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//createAopProxy()方法就是决定究竟创建何种类型的proxy</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">synchronized</span> AopProxy <span class="token function">createAopProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>active<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">activate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关键方法createAopProxy()</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAopProxyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createAopProxy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>createAopProxy(this)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AopProxyFactory</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    AopProxy <span class="token function">createAopProxy</span><span class="token punctuation">(</span>AdvisedSupport var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> AopConfigException<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>这个方法里明确了哪些情况使用JDK动态代理哪些情况使用Cglib。</p><p>所以@EnableAspectJAutoProxy(proxyTargetClass=true)，使用Cglib</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> AopProxy <span class="token function">createAopProxy</span><span class="token punctuation">(</span>AdvisedSupport config<span class="token punctuation">)</span> <span class="token keyword">throws</span> AopConfigException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//config.isOptimize()是否使用优化的代理策略，目前适用于Cglib</span>        <span class="token comment" spellcheck="true">//config.isProxyTargetClass()是否目标类本身被代理而不是目标类的接口</span>        <span class="token comment" spellcheck="true">//hasNoUserSuppliedProxyInterfaces()是否存在代理接口</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>config<span class="token punctuation">.</span><span class="token function">isOptimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>config<span class="token punctuation">.</span><span class="token function">isProxyTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hasNoUserSuppliedProxyInterfaces</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AopConfigException</span><span class="token punctuation">(</span><span class="token string">"TargetSource cannot determine target class: Either an interface or a target is required for proxy creation."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果目标类是接口或者代理类，则直接使用JDKProxy，其他情况用cglib</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span>AopProxy<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">!</span>targetClass<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Proxy<span class="token punctuation">.</span><span class="token function">isProxyClass</span><span class="token punctuation">(</span>targetClass<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">ObjenesisCglibAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>createAopProxy()返回一个AopProxy后，回过头来createAopProxy().getProxy(classLoader);</p><p>如果返回的是JDK动态代理：<code>return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Creating JDK dynamic proxy: target source is "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span><span class="token function">getTargetSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> proxiedInterfaces <span class="token operator">=</span> AopProxyUtils<span class="token punctuation">.</span><span class="token function">completeProxiedInterfaces</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">findDefinedEqualsAndHashCodeMethods</span><span class="token punctuation">(</span>proxiedInterfaces<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">,</span> proxiedInterfaces<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>如果返回的是Cglib动态代理:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Creating CGLIB proxy: target source is "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span><span class="token function">getTargetSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> rootClass <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Assert<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span>rootClass <span class="token operator">!=</span> null<span class="token punctuation">,</span> <span class="token string">"Target class must be available for creating a CGLIB proxy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> proxySuperClass <span class="token operator">=</span> rootClass<span class="token punctuation">;</span>            <span class="token keyword">int</span> x<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ClassUtils<span class="token punctuation">.</span><span class="token function">isCglibProxyClass</span><span class="token punctuation">(</span>rootClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                proxySuperClass <span class="token operator">=</span> rootClass<span class="token punctuation">.</span><span class="token function">getSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> additionalInterfaces <span class="token operator">=</span> rootClass<span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Class<span class="token punctuation">[</span><span class="token punctuation">]</span> var5 <span class="token operator">=</span> additionalInterfaces<span class="token punctuation">;</span>                <span class="token keyword">int</span> var6 <span class="token operator">=</span> additionalInterfaces<span class="token punctuation">.</span>length<span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> var6<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> additionalInterface <span class="token operator">=</span> var5<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span><span class="token function">addInterface</span><span class="token punctuation">(</span>additionalInterface<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">validateClassIfNecessary</span><span class="token punctuation">(</span>proxySuperClass<span class="token punctuation">,</span> classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>            Enhancer enhancer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createEnhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>classLoader <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                enhancer<span class="token punctuation">.</span><span class="token function">setClassLoader</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>classLoader <span class="token keyword">instanceof</span> <span class="token class-name">SmartClassLoader</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>SmartClassLoader<span class="token punctuation">)</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isClassReloadable</span><span class="token punctuation">(</span>proxySuperClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    enhancer<span class="token punctuation">.</span><span class="token function">setUseCache</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>proxySuperClass<span class="token punctuation">)</span><span class="token punctuation">;</span>            enhancer<span class="token punctuation">.</span><span class="token function">setInterfaces</span><span class="token punctuation">(</span>AopProxyUtils<span class="token punctuation">.</span><span class="token function">completeProxiedInterfaces</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            enhancer<span class="token punctuation">.</span><span class="token function">setNamingPolicy</span><span class="token punctuation">(</span>SpringNamingPolicy<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">)</span><span class="token punctuation">;</span>            enhancer<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CglibAopProxy<span class="token punctuation">.</span>ClassLoaderAwareUndeclaredThrowableStrategy</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Callback<span class="token punctuation">[</span><span class="token punctuation">]</span> callbacks <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCallbacks</span><span class="token punctuation">(</span>rootClass<span class="token punctuation">)</span><span class="token punctuation">;</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> types <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span>callbacks<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> types<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                types<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> callbacks<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            enhancer<span class="token punctuation">.</span><span class="token function">setCallbackFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CglibAopProxy<span class="token punctuation">.</span>ProxyCallbackFilter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span><span class="token function">getConfigurationOnlyCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fixedInterceptorMap<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fixedInterceptorOffset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            enhancer<span class="token punctuation">.</span><span class="token function">setCallbackTypes</span><span class="token punctuation">(</span>types<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createProxyClassAndInstance</span><span class="token punctuation">(</span>enhancer<span class="token punctuation">,</span> callbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalArgumentException</span> <span class="token operator">|</span> CodeGenerationException var9<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AopConfigException</span><span class="token punctuation">(</span><span class="token string">"Could not generate CGLIB subclass of "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">": Common causes of this problem include using a final class or a non-visible class"</span><span class="token punctuation">,</span> var9<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var10<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AopConfigException</span><span class="token punctuation">(</span><span class="token string">"Unexpected AOP exception"</span><span class="token punctuation">,</span> var10<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> IoC </tag>
            
            <tag> DI </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring三级缓存解决循环依赖</title>
      <link href="2021/03/16/Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>2021/03/16/Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h3 id="循环依赖及三级缓存"><a href="#循环依赖及三级缓存" class="headerlink" title="循环依赖及三级缓存"></a>循环依赖及三级缓存</h3><p>Spring在启动过程中，使用到了三个map，称为三级缓存。</p><p><em>一级缓存，保存singletonBean实例: bean name –&gt; bean instance</em></p><p><em>二级缓存，保存早期未完全创建的Singleton实例: bean name –&gt; bean instance</em></p><p>三级缓存，保存singletonBean生产工厂: bean name –&gt; ObjectFactory</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> B b<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setB</span><span class="token punctuation">(</span>B b<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> A a<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setA</span><span class="token punctuation">(</span>A a<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>Spring三级缓存解决bean循环依赖，为何用三级缓存而非二级</strong></p><p>Spring bean循环依赖即循环引用。是指2个或以上bean 互相持有对方，最终形成闭环。比如A依赖于B，B依赖A。产生循环依赖的方式有两种，一种是通过构造器注入形成的循环依赖，第二种是通过field属性注入形成的循环依赖。Spring通过特殊的bean生成机制解决了第二种方式产生的循环依赖问题，使得循环链的所有bean对象都能正确创建，而构造器注入方式阐释的循环依赖则会抛出异常。两者之间的差异能在bean创建机制中得到解释。</p><p>注意此处讨论的bean皆为单例，prototype的bean循环依赖皆会抛出异常，若是单例与prototype混合的情况，若是先创建单例则能成功，反之则会抛出异常。</p><p>总的来说，Spring解决循环依赖问题是通过结合bean实例化和bean属性填装分离，singletonObjects、earlySingletonObjects 、singletonFactories 三级缓存机制和引用提前暴露机制实现的。下面将详细介绍单例bean创建与获取过程。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//一级缓存，保存singletonBean实例: bean name，这里面拿到的bean，直接可以使用 --> bean instance</span><span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 二级缓存，保存早期未完全创建的Singleton实例: bean name --> bean instance</span><span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> earlySingletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 三级缓存，保存singletonBean生产工厂: bean name --> ObjectFactory</span><span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> singletonFactories <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当Spring容器试图获得单例Bean时，查找位置从一级缓存至三级缓存，注意若三级缓存查找成功，其返回的bean对象并不一定是完全体，而可能是仅完成实例化，还未完成属性装填的提前暴露引用。当三级缓存内都未找到目标，getSingleton方法则会返回null，之后Spring将会执行一系列逻辑，最终将调用以下方法新创建bean对象：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">getSingleton</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> <span class="token keyword">boolean</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 查询一级缓存</span>    Object singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//若一级缓存内不存在，查询二级缓存</span>            singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//若二级缓存内不存在，查询三级缓存</span>                ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> singletonFactory <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonFactory <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//若三级缓存中的，则通过工厂获得对象，并清除三级缓存，提升至二级缓存</span>                    singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">!=</span> NULL_OBJECT <span class="token operator">?</span> singletonObject <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">doCreateBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> String beanName<span class="token punctuation">,</span> <span class="token keyword">final</span> RootBeanDefinition mbd<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token annotation punctuation">@Nullable</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>            <span class="token keyword">throws</span> BeanCreationException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//此处略过  做某些事</span>               <span class="token comment" spellcheck="true">// Eagerly cache singletons to be able to resolve circular references</span>        <span class="token comment" spellcheck="true">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span>        <span class="token comment" spellcheck="true">// 早期缓存单例对象以解决循环引用问题</span>        <span class="token comment" spellcheck="true">// 即使问题是在如BeanFactoryAware的生命周期阶段接口处发生的</span>        <span class="token comment" spellcheck="true">// 允许早期暴露参数</span>        <span class="token keyword">boolean</span> earlySingletonExposure <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>allowCircularReferences <span class="token operator">&amp;&amp;</span>                <span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"Eagerly caching bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span>                        <span class="token string">"' to allow for resolving potential circular references"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将实例化完成但还未填装属性的bean引用暴露出来，方法为将beanName和对应singletonFactory加入第三级缓存Map</span>            <span class="token function">addSingletonFactory</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Initialize the bean instance.</span>        Object exposedObject <span class="token operator">=</span> bean<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 此处省略部分代码</span>                <span class="token comment" spellcheck="true">//填装属性，在此方法内尝试获得循环引用的被引用bean，方法与自身bean获得流程一致</span>        <span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>        exposedObject <span class="token operator">=</span> <span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 此处省略部分代码</span></code></pre><p>以上则是解决循环引用问题的关键：在初次创建Bean对象的过程中，当bean实例化完成后并不直接开始属性装配，而是先检查是否允许提前暴露，若允许则通过将对应SingletonFactory加入第三级Bean缓存使得外界能够提前获得该Bean的未完成引用，之后再进行属性装配工作。通过上述执行流程，循环引用问题得以解决：</p><p>1、设A、B单例对象相互依赖，当我们试图获得A对象时，将首先根据BeanName在三级缓存中查找，显然目前是查询不到的。<br>2、之后将执行doCreateBean方法创建新的A对象，在实例化但未完成属性装配时，方法会通过将对应SingletonFactory将A-Bean的引用提前暴露出去，然后执行属性装配。<br>3、在属性装配方法中，发现A依赖于B，随机尝试获得B-bean，调用getSingleton方法查询三级缓存，结果依然是未找到B-bean，于是和A流程一样调用doCreateBean方法创建一个新的B-bean。<br>4、此处与doCreateBean方法创建A-bean流程一致，成功实例化B-bean但未填装属性，将早期引用暴露，执行属性填装方法，发现B依赖于A，于是试图获得A-bean。<br>5、差异在此处出现，由于第三步已经将A-bean的早期引用通过第三级缓存暴露出来，在此处执行getSingleton方法时将会成功在三级缓存内获得A-bean引用，由此递归地返回，先后完成B-bean的属性装填工作，B-bean的创建工作，A-Bean的属性装填工作，最后完成A-Bean的创建工作。</p><p>由此通过属性注入的循环依赖问题得以解决，同时上述流程也解释了为何通过构造器注入产生的循环依赖问题会抛出异常，因为在A-bean执行构造方法的时候即需要获得B-bean方法。</p><p><strong>为何使用三级缓存而非二级缓存？</strong></p><p>一级缓存的问题在于，就1个map，里面既有完整的已经ready的bean，也有不完整的，尚未设置field的bean。如果这时候，有其他线程去这个map里获取bean来用怎么办？拿到的bean，不完整，怎么办呢？属性都是null，直接空指针了。</p><p>所以，我们就要加一个map，这个map，用来存放那种不完整的bean。如果是把不完整的bean放入二级缓存，仍然可以解决循环依赖问题，但是对于AOP，B注入到A中，注入到A中的是B类型，如果给B加切面，生成B的一个动态代理对象，但是A用的是原始的Bean。</p><p>所以，加个三级缓存，里面不存具体的bean，里面存一个工厂对象。通过工厂对象，是可以拿到最终形态的代理后的对象。</p><p><strong>使用三级缓存而非二级缓存并不是因为只有三级缓存才能解决循环引用问题，其实二级缓存同样也能很好解决循环引用问题。使用三级而非二级缓存并非出于IOC的考虑，而是出于AOP的考虑，即若使用二级缓存，在AOP情形下，注入到其他bean的，不是最终的代理对象，而是原始对象。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 三级缓存 </tag>
            
            <tag> 循环依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码解析——Bean的创建与初始化</title>
      <link href="2021/03/16/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94Bean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>2021/03/16/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94Bean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>本文转载于<a href="https://blog.csdn.net/u014082714/article/details/82388931">https://blog.csdn.net/u014082714/article/details/82388931</a></p><p>Spring提供了很多重载和覆盖的getBean()方法，当我们在执行beanFactory.getBean(“myBean”)时，我们实际上是在调用AbstractBeanFactory中的实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">getBean</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doGetBean</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">(</span>Class<span class="token punctuation">)</span>null<span class="token punctuation">,</span> <span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>doGetBean()方法包含了整个创建和获取bean的过程：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">doGetBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> String name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token keyword">final</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> requiredType<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Nullable</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token keyword">boolean</span> typeCheckOnly<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 获取name对应的真正的beanName         * 因为传入的参数可以是别名，也可能是FactoryBean的name,所以需要进行解析，包含以下内容：         * 1、如果是FactoryBean，则去掉修饰符“&amp;”         * 2、沿着引用链获取别名对应的最终name         */</span>        <span class="token keyword">final</span> String beanName <span class="token operator">=</span> <span class="token function">transformedBeanName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object bean<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 检查缓存或者实例工厂中是否有对应的单例         * 在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖，         * Spring创建bean的原则是不等bean创建完成就会将创建bean的ObjectFactory提前曝光（将对应的ObjectFactory加入到缓存）         * 一旦下一个bean创建需要依赖上一个bean，则直接使用ObjectFactory对象         */</span>        Object sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//实例已经存在</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sharedInstance <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> args <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Returning eagerly cached instance of singleton bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span>                            <span class="token string">"' that is not fully initialized yet - a consequence of a circular reference"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Returning cached instance of singleton bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//返回对应的实例</span>            bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>sharedInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 单例实例不存在</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPrototypeCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//只有在单例模式下才会尝试解决循环依赖问题</span>                <span class="token comment" spellcheck="true">//对于原型模式，如果存在循环依赖，直接抛出异常</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCurrentlyInCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获取parentBeanFactory实例</span>            BeanFactory parentBeanFactory <span class="token operator">=</span> <span class="token function">getParentBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果在beanDefinitionMap中（即所以已经加载的类中）不包含目标bean，则尝试从parentBeanFactory中获取</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parentBeanFactory <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">containsBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 获取name对应的真正beanName</span>                String nameToLookup <span class="token operator">=</span> <span class="token function">originalBeanName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parentBeanFactory <span class="token keyword">instanceof</span> <span class="token class-name">AbstractBeanFactory</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>AbstractBeanFactory<span class="token punctuation">)</span> parentBeanFactory<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doGetBean</span><span class="token punctuation">(</span>                            nameToLookup<span class="token punctuation">,</span> requiredType<span class="token punctuation">,</span> args<span class="token punctuation">,</span> typeCheckOnly<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>args <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//递归到BeanFactory中查找</span>                    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> parentBeanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>nameToLookup<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> parentBeanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>nameToLookup<span class="token punctuation">,</span> requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>typeCheckOnly<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">markBeanAsCreated</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//将存储XML配置的GenericBeanDefinition实例转换为RootBeanDefinition实例，方便后续处理，如果存在父bean，则同时合并父bean的相关属性。</span>                <span class="token keyword">final</span> RootBeanDefinition mbd <span class="token operator">=</span> <span class="token function">getMergedLocalBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//检查bean是否是抽象的，如果是则抛出异常</span>                <span class="token function">checkMergedBeanDefinition</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 加载当前bean依赖的bean</span>                String<span class="token punctuation">[</span><span class="token punctuation">]</span> dependsOn <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getDependsOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dependsOn <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//如果存在依赖，就递归实例化依赖的bean</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span>String dep <span class="token operator">:</span> dependsOn<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDependent</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> dep<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//检查dep是否依赖beanName，从而导致循环依赖</span>                            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span>                                    <span class="token string">"Circular depends-on relationship between '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' and '"</span> <span class="token operator">+</span> dep <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//缓存依赖调用</span>                        <span class="token function">registerDependentBean</span><span class="token punctuation">(</span>dep<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">getBean</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 完成加载依赖的bean后，实例化mbd自身</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//单例</span>                    sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            <span class="token keyword">return</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//清理工作，从单例缓存中移除</span>                            <span class="token function">destroySingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>sharedInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 原型</span>                    Object prototypeInstance <span class="token operator">=</span> null<span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//设置正在创建的状态</span>                        <span class="token function">beforePrototypeCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//创建bean</span>                        prototypeInstance <span class="token operator">=</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token function">afterPrototypeCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//返回对应的实例</span>                    bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>prototypeInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//其他scope</span>                    String scopeName <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">final</span> Scope scope <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scopes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>scopeName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>scope <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"No Scope registered for scope name '"</span> <span class="token operator">+</span> scopeName <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        Object scopedInstance <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            <span class="token function">beforePrototypeCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                                <span class="token keyword">return</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                            <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                                <span class="token function">afterPrototypeCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>scopedInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalStateException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span>                                <span class="token string">"Scope '"</span> <span class="token operator">+</span> scopeName <span class="token operator">+</span> <span class="token string">"' is not active for the current thread; consider "</span> <span class="token operator">+</span>                                <span class="token string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span><span class="token punctuation">,</span>                                ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">cleanupAfterBeanCreationFailure</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 检查需要的类型是否符合bean的实际类型</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>requiredType <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>requiredType<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                T convertedBean <span class="token operator">=</span> <span class="token function">getTypeConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">convertIfNecessary</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>convertedBean <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanNotOfRequiredTypeException</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> requiredType<span class="token punctuation">,</span> bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> convertedBean<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TypeMismatchException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Failed to convert bean '"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"' to required type '"</span> <span class="token operator">+</span>                            ClassUtils<span class="token punctuation">.</span><span class="token function">getQualifiedName</span><span class="token punctuation">(</span>requiredType<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanNotOfRequiredTypeException</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> requiredType<span class="token punctuation">,</span> bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> bean<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><blockquote><p>整个方法的过程可以概括为：</p><ol><li>获取参数 name 对应的真正的 beanName</li><li>检查缓存或者实例工厂中是否有对应的单例，若存在则进行实例化并返回对象，否则继续往下执行</li><li>执行 prototype 类型依赖检查，防止循环依赖</li><li>如果当前 beanFactory 中不存在需要的 bean，则尝试从 parentBeanFactory 中获取</li><li>将之前解析过程返得到的 GenericBeanDefinition 对象合并为 RootBeanDefinition 对象，便于后续处理</li><li>如果存在依赖的 bean，则进行递归加载</li><li>依据当前 bean 的作用域对 bean 进行实例化</li><li>如果对返回 bean 类型有要求，则进行类型检查，并按需做类型转换</li><li>返回 bean 实例</li></ol></blockquote><h3 id="1、获取真正的-beanName"><a href="#1、获取真正的-beanName" class="headerlink" title="1、获取真正的 beanName"></a>1、<strong>获取真正的 beanName</strong></h3><p>我们在调用 getBean 方法的时候传递的 name 可以是 bean 的别名，也可以是获取 factoryBean 实例的 name，所以当我们以 name 为 key 检索 bean 的时候，首先需要获取 name 对应的唯一标识 bean 的真正名称 beanName，这一过程位于 transformedBeanName(String name) 方法中：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> String <span class="token function">transformedBeanName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">canonicalName</span><span class="token punctuation">(</span>BeanFactoryUtils<span class="token punctuation">.</span><span class="token function">transformedBeanName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>上述方法首先会通过 BeanFactoryUtils 工具类方法判断是不是获取 factoryBean，如果是的话就去掉 name 前面的 “&amp;” 字符，然后执行 canonicalName(String name) 逻辑：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">canonicalName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// canonical：权威的</span>    String canonicalName <span class="token operator">=</span> name<span class="token punctuation">;</span>    String resolvedName<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        resolvedName <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>aliasMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>canonicalName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolvedName <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            canonicalName <span class="token operator">=</span> resolvedName<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历寻找真正的name，因为可能存在引用链</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>resolvedName <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> canonicalName<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>为什么这里当 <code>resolvedName != null</code> 的时候需要继续循环呢，这是因为一个别名所引用的不一定是一个最终的 beanName，可以是另外一个别名，这个时候就是一个链式引用的场景，我们需要继续沿着引用链往下寻找最终的 beanName。</p><h3 id="2、尝试从单例集合中获取目标-bean"><a href="#2、尝试从单例集合中获取目标-bean" class="headerlink" title="2、尝试从单例集合中获取目标 bean"></a>2、<strong>尝试从单例集合中获取目标 bean</strong></h3><p>容器首先尝试从单例对象集合中获取 bean 实例，我们都知道单例对象在容器中只会存在一份，所以首先检查单例集合也符合常理，获取单例对象的方法如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">getSingleton</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// true表示允许早期依赖</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>上述方法第二个参数设置为 true，即 <code>allowEarlyReference=true</code>，表示允许对 bean 的早期依赖，Spring 中 bean 的依赖关系由开发者控制，具备极大的自由配置空间，如果配置不当，可能会导致循环依赖的场景，即 A 依赖于 B，而 B 又依赖于 A，当初始化 A 的时候，检测到引用的 B 还没有实例化，就会转去实例 B，实例化 B 的过程中又会发现 A 还没有实例化完成，从而又回来实例化 A，因此陷入死锁。而 allowEarlyReference 则会提前曝光 bean 的创建过程，具体如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">getSingleton</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> <span class="token keyword">boolean</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 检查缓存中是否存在实例</span>    Object singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// singletonObjects以beanName为key存储bean实例</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null <span class="token comment" spellcheck="true">// 缓存中为空</span>            <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// bean正在创建中</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// earlySingletonObjects以beanName为key存储bean实例（这里的实例还处于创建中）</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 当某些方法需要提前初始化的时候，会调用addSingletonFactory将对应的objectFactory初始化策略存储在singletonFactories中</span>                ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> singletonFactory <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// singletonFactories以beanName为key存储创建bean的工厂</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonFactory <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// earlySingletonObjects和singletonFactories互斥</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">!=</span> NULL_OBJECT <span class="token operator">?</span> singletonObject <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>上述方法的逻辑是首先从存放 bean 实例的集合 singletonObjects 中获取实例，如果实例不存在且正在创建中，则尝试从 earlySingletonObjects 中获取正在创建中的 bean 实例，如果仍然不存在并且允许早期依赖，则将 ObjectFactory 提前曝光。</p><blockquote><p><strong>singletonObjects 和 earlySingletonObjects 的区别</strong></p><p>两者都是以 beanName 为 key，bean 实例为 value 进行存储，区别在于 singletonObjects 存储的是实例化完成的 bean 实例，而 earlySingletonObjects 存储的是正在实例化中的 bean，所以两个集合的内容是互斥的。</p></blockquote><h3 id="3、从-bean-实例中获取目标对象"><a href="#3、从-bean-实例中获取目标对象" class="headerlink" title="3、从 bean 实例中获取目标对象"></a>3、<strong>从 bean 实例中获取目标对象</strong></h3><p>如果上一步我们获取到了单例 bean 实例，那么我们需要接着调用 getObjectForBeanInstance 方法，该方法在 doGetBean 的过程中被多次调用，每次我们获取到 bean 实例之后，不管是从单例集合中获取、还是实时生成各个作用域对象，我们都需要调用一次该方法，该方法的主要目的是判断当前 bean 实例是否是 FactoryBean，如果是 FactoryBean 实例，同时用户希望获取的是真正的 bean 实例（即 name 不是以 “&amp;” 开头），此时就需要由 FactoryBean 实例创建目标 bean 实例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>Object beanInstance<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> String beanName<span class="token punctuation">,</span> RootBeanDefinition mbd<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>BeanFactoryUtils<span class="token punctuation">.</span><span class="token function">isFactoryDereference</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>beanInstance <span class="token keyword">instanceof</span> <span class="token class-name">FactoryBean</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取FactoryBean，但是对应的bean并不是FactoryBean类型</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanIsNotAFactoryException</span><span class="token punctuation">(</span><span class="token function">transformedBeanName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> beanInstance<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*     * 一个bean实例，可以是普通的bean，也可能是FactoryBean     * 该bean实例不是FactoryBean or 本来就是希望获取FactoryBean实例     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>beanInstance <span class="token keyword">instanceof</span> <span class="token class-name">FactoryBean</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 不是FactoryBean，直接返回</span>            <span class="token operator">||</span> BeanFactoryUtils<span class="token punctuation">.</span><span class="token function">isFactoryDereference</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 希望仅仅获取FactoryBean实例，直接返回</span>        <span class="token keyword">return</span> beanInstance<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 获取由FactoryBean创建的bean实例</span>    Object object <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 尝试从缓存中获取bean实例</span>        object <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCachedObjectForFactoryBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 处理FactoryBean</span>        FactoryBean<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> factory <span class="token operator">=</span> <span class="token punctuation">(</span>FactoryBean<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> beanInstance<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">containsBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// beanName已经注册</span>            <span class="token comment" spellcheck="true">// 指定merge操作</span>            mbd <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getMergedLocalBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 是否是用户定义的，而不是应用程序自己定义的</span>        <span class="token keyword">boolean</span> synthetic <span class="token operator">=</span> <span class="token punctuation">(</span>mbd <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> mbd<span class="token punctuation">.</span><span class="token function">isSynthetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 核心代码：getObjectFromFactoryBean</span>        object <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getObjectFromFactoryBean</span><span class="token punctuation">(</span>factory<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token operator">!</span>synthetic<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> object<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>方法首先会进行一些基础校验，如果用户希望获取的是 FactoryBean 实例，但是当前的实例明确不是 FactoryBean 实例则抛出异常，否则除非当前实例是 FactoryBean 实例，同时用户又希望获取由 FactoryBean 实例创建的对象，其余情况直接返回 bean 实例。</p><p>接下来就是处理由 FactoryBean 实例创建目标 bean 对象的过程，首先容器会尝试从缓存中获取，因为对于一些单例的 bean 来说，可能之前已经完成了创建，如果缓存不命中则执行创建过程，这里继续调用 getObjectFromFactoryBean 方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">getObjectFromFactoryBean</span><span class="token punctuation">(</span>FactoryBean<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> factory<span class="token punctuation">,</span> String beanName<span class="token punctuation">,</span> <span class="token keyword">boolean</span> shouldPostProcess<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>factory<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">containsSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果是单例，且factoryBean已经实例化</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSingletonMutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 尝试从缓存中获取， factoryBeanObjectCache以factoryBeanName为key存储由FactoryBean创建的实例</span>            Object object <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>factoryBeanObjectCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 调用FactoryBean的getObject方法创建对象</span>                object <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doGetObjectFromFactoryBean</span><span class="token punctuation">(</span>factory<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 尝试获取已经缓存的实例</span>                Object alreadyThere <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>factoryBeanObjectCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>alreadyThere <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    object <span class="token operator">=</span> alreadyThere<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> shouldPostProcess<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 调用后置处理器</span>                            object <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postProcessObjectFromFactoryBean</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token string">"Post-processing of FactoryBean's singleton object failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 缓存，以factoryBeanName为key，由FactoryBean创建的对象为value</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>factoryBeanObjectCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span>object <span class="token operator">!=</span> null <span class="token operator">?</span> object <span class="token operator">:</span> NULL_OBJECT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>object <span class="token operator">!=</span> NULL_OBJECT <span class="token operator">?</span> object <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用FactoryBean的getObject方法创建对象</span>        Object object <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doGetObjectFromFactoryBean</span><span class="token punctuation">(</span>factory<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> shouldPostProcess<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 调用后置处理器</span>                object <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postProcessObjectFromFactoryBean</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token string">"Post-processing of FactoryBean's object failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> object<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>该方法对于单例来说，保证单例在容器中的唯一性，同时触发后置处理器，而我们期望的创建 bean 实例的逻辑位于 doGetObjectFromFactoryBean 方法中，这里才是调用我们在使用 FactoryBean 构造对象所覆盖的 getObject 方法的地方，前面的文章已经介绍过 FactoryBean，并演示了 FactoryBean 的使用方法，再来回顾一下 FactoryBean 的构成：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FactoryBean</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 获取由 FactoryBean 创建的目标 bean 实例*/</span>    T <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 返回目标 bean 类型 */</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 是否是单实例 */</span>    <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>FactoryBean 接口仅仅包含 3 个方法，而 getObject 是用来真正创建对象的地方，当我们在调用 BeanFactory 的 getBean 方法不加 “&amp;” 获取 bean 实例时，这个时候 getBean 可以看做是 getObject 方法的代理方法，而具体调用就在 doGetObjectFromFactoryBean 方法中：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Object <span class="token function">doGetObjectFromFactoryBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> FactoryBean<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> factory<span class="token punctuation">,</span> <span class="token keyword">final</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeanCreationException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Object object<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 需要权限验证</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            AccessControlContext acc <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAccessControlContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                object <span class="token operator">=</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedExceptionAction</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> Object <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> factory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> acc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">PrivilegedActionException</span> pae<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> pae<span class="token punctuation">.</span><span class="token function">getException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 直接调用getObject方法，FactoryBean的getObject方法代理了getBean</span>            object <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FactoryBeanNotInitializedException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCurrentlyInCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> ex<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token string">"FactoryBean threw exception on object creation"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// FactoryBean未成功创建对象，或factoryBean实例正在被创建</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCurrentlyInCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token string">"FactoryBean which is currently in creation returned null from getObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> object<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>上述方法中的 factory.getObject() 是我们一层层剥离外表所触及到的核心，其具体实现则交给了开发者。</p><h3 id="4-创建-bean-实例"><a href="#4-创建-bean-实例" class="headerlink" title="4. 创建 bean 实例"></a><strong>4. 创建 bean 实例</strong></h3><p>如果单例缓存集合中不存在目标 bean 实例，那么说明当前 bean 可能是一个非单例对象，或者是一个单例但却是第一次加载，如果前面的操作是获取对象，那么这里就需要真正创建对象了，在具体创建对象之前，需要做如下几步操作：</p><blockquote><ol><li>对 prototype 对象的循环依赖进行检查，如果存在循环依赖则直接抛出异常，而不尝试去解决循环依赖。</li><li>检测目标 bean 是否属于当前 BeanFactory 的管辖范围，如果不属于，同时又存在父 BeanFactory，则委托给父 BeanFactory 进行处理。</li><li>检测是不是仅仅做类型检查，如果不是则清空 merge 标记，并标记当前 bean 为已创建状态</li><li>将存储XML配置的GenericBeanDefinition实例转换成RootBeanDefinition实例，方便后续处理</li><li>检查依赖的 bean，如果存在且未实例化，则先递归实例化依赖的 bean</li></ol></blockquote><p>完成了上述流程之后，容器针对具体的作用域采取适当的方法创建对应的 bean 实例。</p><h4 id="4-1-创建单例对象"><a href="#4-1-创建单例对象" class="headerlink" title="4.1 创建单例对象"></a><strong>4.1 创建单例对象</strong></h4><p>之前尝试从单例缓存集合中获取单例对象，而能够走到这里说明之前缓存不命中，对应的单例对象还没有创建，需要现在开始实时创建，这个过程位于 getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) 方法中，这是一个重载方法，与前面从缓存中获取单例对象的方法在参数上存在差别：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">getSingleton</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> singletonFactory<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token string">"'beanName' must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// singletonObjects用于缓存beanName与已创建的单例对象的映射关系</span>        Object singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对应的bean没有加载过</span>            <span class="token comment" spellcheck="true">// 开始singleton bean的初始化过程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonsCurrentlyInDestruction<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 对应的bean正在其它地方创建中</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationNotAllowedException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span>                        <span class="token string">"Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Creating shared instance of singleton bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 前置处理，对于需要依赖检测的bean，设置状态为“正在创建中”</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">beforeSingletonCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">boolean</span> newSingleton <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> recordSuppressedExceptions <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>suppressedExceptions <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>recordSuppressedExceptions<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>suppressedExceptions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span>Exception<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>             <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 实例化bean</span>                singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                newSingleton <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalStateException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 异常，再次尝试从缓存中获取</span>                singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeanCreationException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>recordSuppressedExceptions<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span>Exception suppressedException <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>suppressedExceptions<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        ex<span class="token punctuation">.</span><span class="token function">addRelatedCause</span><span class="token punctuation">(</span>suppressedException<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>recordSuppressedExceptions<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>suppressedExceptions <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 后置处理，对于需要依赖检测的bean，移除“正在创建中”的状态</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">afterSingletonCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>newSingleton<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 新实例</span>                <span class="token comment" spellcheck="true">// 加入缓存</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 返回实例</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">!=</span> NULL_OBJECT <span class="token operator">?</span> singletonObject <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>整个方法的逻辑还是很直观的，流程概括如下：</p><blockquote><ol><li>检测 bean 是否正在其它地方被创建，是的话抛异常并中断流程</li><li>标记 bean 的状态为“正在创建中”</li><li>实例化 bean，如果过程中出现异常，则尝试从缓存中获取实例</li><li>移除 bean 的“正在创建中”的状态</li><li>将 bean 实例加入缓存，并返回实例</li></ol></blockquote><p>步骤三中的实例化 bean 是整个流程的关键所在，这里调用了参数 singletonFactory 的 getObject 方法，由前面传入的参数我们可以知道 getObject 中的逻辑如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ObjectFactory</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 清理工作，从单例缓存中移除</span>            <span class="token function">destroySingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>所以创建 bean 的真正逻辑位于 createBean 方法中，该方法的具体实现位于 AbstractAutowireCapableBeanFactory 中：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">createBean</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> RootBeanDefinition mbd<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeanCreationException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Creating instance of bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    RootBeanDefinition mbdToUse <span class="token operator">=</span> mbd<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 1.根据设置的class属性或className来解析得到Class引用</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> resolvedClass <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveBeanClass</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolvedClass <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">hasBeanClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> mbd<span class="token punctuation">.</span><span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        mbdToUse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span>mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>        mbdToUse<span class="token punctuation">.</span><span class="token function">setBeanClass</span><span class="token punctuation">(</span>resolvedClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 2.对override属性进行标记和验证，本质上是处理lookup-method和replaced-method标签</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        mbdToUse<span class="token punctuation">.</span><span class="token function">prepareMethodOverrides</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeanDefinitionValidationException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionStoreException</span><span class="token punctuation">(</span>mbdToUse<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Validation of method overrides failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 3. 处理 InstantiationAwareBeanPostProcessor</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Object bean <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveBeforeInstantiation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbdToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果处理结果不为null，则直接返回，而不执行后续的createBean</span>            <span class="token keyword">return</span> bean<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbdToUse<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"BeanPostProcessor before instantiation of bean failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 4. 创建bean实例</span>    Object beanInstance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doCreateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbdToUse<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Finished creating instance of bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> beanInstance<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>该方法虽然叫 createBean，但仍然不是真正创建 bean 实例的地方，该方法主要还是在做一些前期准备工作，具体的流程参见代码注释，下面针对各个过程来逐一探究。</p><h5 id="4-1-1-获取-class-引用"><a href="#4-1-1-获取-class-引用" class="headerlink" title="4.1.1 获取 class 引用"></a><strong>4.1.1 获取 class 引用</strong></h5><p>不知道你是否还记得，在对标签解析过程的探究中，对于 class 属性的解析，如果参数中传入了类加载器则会尝试获取其 class 引用，否则直接记录类的全称类名，对于前者这里的解析就是直接返回引用，而后者则需要在此对其进行解析得到对应的 class 引用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">resolveBeanClass</span><span class="token punctuation">(</span><span class="token keyword">final</span> RootBeanDefinition mbd<span class="token punctuation">,</span> String beanName<span class="token punctuation">,</span> <span class="token keyword">final</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> typesToMatch<span class="token punctuation">)</span>        <span class="token keyword">throws</span> CannotLoadBeanClassException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">hasBeanClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果之前直接存储的class引用则直接返回</span>            <span class="token keyword">return</span> mbd<span class="token punctuation">.</span><span class="token function">getBeanClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 否则由beanClassName解析得到class引用</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedExceptionAction</span><span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 解析得到bean引用</span>                    <span class="token keyword">return</span> <span class="token function">doResolveBeanClass</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> typesToMatch<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token function">getAccessControlContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 解析得到bean引用</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doResolveBeanClass</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> typesToMatch<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">PrivilegedActionException</span> pae<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        ClassNotFoundException ex <span class="token operator">=</span> <span class="token punctuation">(</span>ClassNotFoundException<span class="token punctuation">)</span> pae<span class="token punctuation">.</span><span class="token function">getException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CannotLoadBeanClassException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">.</span><span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CannotLoadBeanClassException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">.</span><span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">LinkageError</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CannotLoadBeanClassException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">.</span><span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>逻辑很清晰，如果 beanDefinition 实例中记录已经是 class 引用则直接返回，否则进行解析，即 doResolveBeanClass 方法，该方法会验证类全称类名，并利用类加载器解析获取 class 引用，具体不再展开。</p><h5 id="4-1-2-处理-override-属性"><a href="#4-1-2-处理-override-属性" class="headerlink" title="4.1.2 处理 override 属性"></a><strong>4.1.2 处理 override 属性</strong></h5><p>Spring 中并不存在 <code>override-method</code> 的标签，这里的 override 指的是 <lookup-method/> 和 <replaced-method/> 两个标签，之前解析这两个标签时是将这两个标签配置以 MethodOverride 对象的形式记录在 beanDefinition 实例的 methodOverrides 属性中，而这里的处理主要是逐一检查所覆盖的方法是否存在，如果不存在则覆盖无效，如果存在唯一的方法，则覆盖是明确的，标记后期无需依据参数类型以及个数进行推测：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">prepareMethodOverrides</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> BeanDefinitionValidationException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取之前记录的&lt;lookup-method/>和&lt;replaced-method/>标签配置</span>    MethodOverrides methodOverrides <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getMethodOverrides</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>methodOverrides<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>MethodOverride<span class="token operator">></span> overrides <span class="token operator">=</span> methodOverrides<span class="token punctuation">.</span><span class="token function">getOverrides</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>overrides<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>MethodOverride mo <span class="token operator">:</span> overrides<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 逐一处理</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareMethodOverride</span><span class="token punctuation">(</span>mo<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">prepareMethodOverride</span><span class="token punctuation">(</span>MethodOverride mo<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeanDefinitionValidationException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取指定类中指定方法名的个数</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> ClassUtils<span class="token punctuation">.</span><span class="token function">getMethodCountForName</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBeanClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mo<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 无效</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionValidationException</span><span class="token punctuation">(</span><span class="token string">"Invalid method override: no method with name '"</span> <span class="token operator">+</span> mo<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"' on class ["</span> <span class="token operator">+</span> <span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         * 标记MethodOverride暂未被覆盖，避免参数类型检查的开销         *         * 如果一个方法存在多个重载，那么在调用及增强的时候还需要根据参数类型进行匹配来最终确认调用的函数         * 如果方法只有一个，就在这里设置重载为false，后续可以直接定位方法         */</span>        mo<span class="token punctuation">.</span><span class="token function">setOverloaded</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="4-1-3-处理-InstantiationAwareBeanPostProcessor"><a href="#4-1-3-处理-InstantiationAwareBeanPostProcessor" class="headerlink" title="4.1.3 处理 InstantiationAwareBeanPostProcessor"></a><strong>4.1.3 处理 InstantiationAwareBeanPostProcessor</strong></h5><p>接下来主要处理 InstantiationAwareBeanPostProcessor 处理器，我们先来回忆一下该处理器的作用。该处理器的接口定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InstantiationAwareBeanPostProcessor</span> <span class="token keyword">extends</span> <span class="token class-name">BeanPostProcessor</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/** bean实例化前调用，是对bean定义进行修改的最后机会 */</span>    Object <span class="token function">postProcessBeforeInstantiation</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> beanClass<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/** bean实例化后立即调用，位于属性注入之前 */</span>    <span class="token keyword">boolean</span> <span class="token function">postProcessAfterInstantiation</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/** 在将属性注入bean实例前的属性处理 */</span>    PropertyValues <span class="token function">postProcessPropertyValues</span><span class="token punctuation">(</span>PropertyValues pvs<span class="token punctuation">,</span> PropertyDescriptor<span class="token punctuation">[</span><span class="token punctuation">]</span> pds<span class="token punctuation">,</span> Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>由上述说明还是能够清晰的知道这个处理器的功能，接口中定义的方法紧挨着 bean 实例化的过程，如果我们希望在实例化前后对 bean 的定义实施一些修改，可以实现该接口并注册到 BeanFactory 中，不过需要注意一点的是处理器会对所有的 bean 生效，而筛选的逻辑需要我们自己实现。</p><p>回过头来我们继续探究这里的处理逻辑，如下首先会去解析 bean 的真正 class 引用，因为可能存在一些工厂 bean，而具体的 bean 类型还需要通过工厂方法去推测：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">resolveBeforeInstantiation</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> RootBeanDefinition mbd<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Object bean <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Boolean<span class="token punctuation">.</span>FALSE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span>beforeInstantiationResolved<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示尚未被解析</span>        <span class="token comment" spellcheck="true">// mbd是程序创建的且存在后置处理器</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isSynthetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hasInstantiationAwareBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获取最终的class引用，如果是工厂方法则获取工厂所创建的实例类型</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetType <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">determineTargetType</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>targetType <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 调用实例化前置处理器</span>                bean <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">applyBeanPostProcessorsBeforeInstantiation</span><span class="token punctuation">(</span>targetType<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 调用实例化后置处理器</span>                    bean <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">applyBeanPostProcessorsAfterInitialization</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        mbd<span class="token punctuation">.</span>beforeInstantiationResolved <span class="token operator">=</span> <span class="token punctuation">(</span>bean <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bean<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>然后就是我们之前说到的 InstantiationAwareBeanPostProcessor 中的应用实例化前置和后置处理器，代码逻辑分别如下：</p><ul><li><strong>应用实例化前置处理</strong></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">applyBeanPostProcessorsBeforeInstantiation</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> beanClass<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实例化前置处理器</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>BeanPostProcessor bp <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bp <span class="token keyword">instanceof</span> <span class="token class-name">InstantiationAwareBeanPostProcessor</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 逐一调用处理器</span>            InstantiationAwareBeanPostProcessor ibp <span class="token operator">=</span> <span class="token punctuation">(</span>InstantiationAwareBeanPostProcessor<span class="token punctuation">)</span> bp<span class="token punctuation">;</span>            Object result <span class="token operator">=</span> ibp<span class="token punctuation">.</span><span class="token function">postProcessBeforeInstantiation</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ul><li><strong>应用实例化后置处理</strong></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">applyBeanPostProcessorsAfterInitialization</span><span class="token punctuation">(</span>Object existingBean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实例化后置处理器</span>    Object result <span class="token operator">=</span> existingBean<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 依次采用后置处理器处理</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>BeanPostProcessor beanProcessor <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        result <span class="token operator">=</span> beanProcessor<span class="token punctuation">.</span><span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>当然这里的后置处理不是必然调用，而是建立在前置处理实例化了 bean 的前提下，因为真正常规实例化 bean 的过程将在接下来一步进行发生，不过如果这一步已经完成了 bean 的实例化过程，那么也就没有继续执行下去的必要，直接返回即可：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果处理结果不为null，则直接返回，而不执行后续的createBean</span>    <span class="token keyword">return</span> bean<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="4-1-4-实例化-bean"><a href="#4-1-4-实例化-bean" class="headerlink" title="4.1.4 实例化 bean"></a><strong>4.1.4 实例化 bean</strong></h5><p>终于挖到了实例化 bean 的地方，实例化 bean 的逻辑还是挺复杂的，我们先来看一下主体流程，如源码中的注释，我们可以将整个过程概括为 7 个步骤：</p><blockquote><ol><li>如果是单例，尝试从缓存中获取 bean 的包装器 BeanWrapper</li><li>如果不存在对应的 Wrapper，则说明 bean 未被实例化，创建 bean 实例</li><li>应用 MergedBeanDefinitionPostProcessor</li><li>检查是否需要提前曝光，避免循环依赖</li><li>初始化 bean 实例</li><li>再次基于依存关系验证是否存在循环依赖</li><li>注册 DisposableBean</li></ol></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">doCreateBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> String beanName<span class="token punctuation">,</span> <span class="token keyword">final</span> RootBeanDefinition mbd<span class="token punctuation">,</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeanCreationException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     BeanWrapper instanceWrapper <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. 如果是单例，尝试获取对应的BeanWrapper</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        instanceWrapper <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>factoryBeanInstanceCache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 2. bean未实例化，创建 bean 实例</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instanceWrapper <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         * 说明对应的bean还没有创建，用对应的策略（工厂方法、构造函数）创建bean实例，以及简单初始化         *         * 将beanDefinition转成BeanWrapper，大致流程如下：         * 1. 如果存在工厂方法，则使用工厂方法初始化         * 2. 否则，如果存在多个构造函数，则根据参数确定构造函数，并利用构造函数初始化         * 3. 否则，使用默认构造函数初始化         */</span>        instanceWrapper <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createBeanInstance</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从BeanWrapper中获取包装的bean实例</span>    <span class="token keyword">final</span> Object bean <span class="token operator">=</span> <span class="token punctuation">(</span>instanceWrapper <span class="token operator">!=</span> null <span class="token operator">?</span> instanceWrapper<span class="token punctuation">.</span><span class="token function">getWrappedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从BeanWrapper获取包装bean的class引用</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> beanType <span class="token operator">=</span> <span class="token punctuation">(</span>instanceWrapper <span class="token operator">!=</span> null <span class="token operator">?</span> instanceWrapper<span class="token punctuation">.</span><span class="token function">getWrappedClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    mbd<span class="token punctuation">.</span>resolvedTargetType <span class="token operator">=</span> beanType<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 3. 应用 MergedBeanDefinitionPostProcessor</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span>postProcessingLock<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mbd<span class="token punctuation">.</span>postProcessed<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 处理 merged bean，Autowired通过此方法实现诸如类型的解析</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">applyMergedBeanDefinitionPostProcessors</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> beanType<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Post-processing of merged bean definition failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            mbd<span class="token punctuation">.</span>postProcessed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 4. 检查是否需要提前曝光，避免循环依赖，条件：单例 &amp;&amp; 允许循环依赖 &amp;&amp; 当前bean正在创建中</span>    <span class="token keyword">boolean</span> earlySingletonExposure <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>allowCircularReferences <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Eagerly caching bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' to allow for resolving potential circular references"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为避免循环依赖，在完成bean实例化之前，将对应的ObjectFactory加入bean的工厂</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addSingletonFactory</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ObjectFactory</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Object <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 对bean再一次依赖引用，应用SmartInstantiationAwareBeanPostProcessor</span>                <span class="token keyword">return</span> <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 5. 初始化bean实例</span>    Object exposedObject <span class="token operator">=</span> bean<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 对bean进行填充，将各个属性值注入，如果存在依赖的bean则进行递归初始化</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>exposedObject <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 初始化bean，调用初始化方法，比如init-method</span>            exposedObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ex <span class="token keyword">instanceof</span> <span class="token class-name">BeanCreationException</span> <span class="token operator">&amp;&amp;</span> beanName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>BeanCreationException<span class="token punctuation">)</span> ex<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token punctuation">(</span>BeanCreationException<span class="token punctuation">)</span> ex<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Initialization of bean failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 6. 再次基于依存关系验证是否存在循环依赖</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 提前曝光</span>        Object earlySingletonReference <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonReference <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只有在检测到循环引用的情况下才会不为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>exposedObject <span class="token operator">==</span> bean<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// exposedObject没有在初始化中被增强</span>                exposedObject <span class="token operator">=</span> earlySingletonReference<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>allowRawInjectionDespiteWrapping <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hasDependentBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 获取依赖的bean的name</span>                String<span class="token punctuation">[</span><span class="token punctuation">]</span> dependentBeans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getDependentBeans</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                Set<span class="token operator">&lt;</span>String<span class="token operator">></span> actualDependentBeans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>dependentBeans<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>String dependentBean <span class="token operator">:</span> dependentBeans<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 检测依赖，记录未完成创建的bean</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeSingletonIfCreatedForTypeCheckOnly</span><span class="token punctuation">(</span>dependentBean<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        actualDependentBeans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>dependentBean<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/*                 * 因为bean在创建完成之后，其依赖的bean一定是被创建了的                 * 如果actualDependentBeans不为空，则说明bean依赖的bean没有完成创建，存在循环依赖                 */</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>actualDependentBeans<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCurrentlyInCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span>                            <span class="token string">"Bean with name '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' has been injected into other beans ["</span> <span class="token operator">+</span>                                    StringUtils<span class="token punctuation">.</span><span class="token function">collectionToCommaDelimitedString</span><span class="token punctuation">(</span>actualDependentBeans<span class="token punctuation">)</span> <span class="token operator">+</span>                                    <span class="token string">"] in its raw version as part of a circular reference, but has eventually been "</span> <span class="token operator">+</span>                                    <span class="token string">"wrapped. This means that said other beans do not use the final version of the "</span> <span class="token operator">+</span>                                    <span class="token string">"bean. This is often the result of over-eager type matching - consider using "</span> <span class="token operator">+</span>                                    <span class="token string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 7. 注册DisposableBean</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerDisposableBeanIfNecessary</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeanDefinitionValidationException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Invalid destruction signature"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> exposedObject<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>针对上述过程，我们逐一进行探究。</p><p><strong>1. 对于单例，尝试从缓存中获取 BeanWrapper 对象</strong></p><p>单例对象是全局唯一的，一旦创建就常驻内存，如果对应的 bean 已经被实例化过，那么这里获取到的是 BeanWrapper 对象，BeanWrapper 可以看作是偏底层的 bean 包装器，提供了对标准 java bean 的分析和操作方法，包括获取和设置属性值、获取属性描述符，以及属性的读写特性等。</p><p><strong>2. bean 的实例化过程</strong></p><p>如果步骤 1 中没有获取到目标 bean 实例，则说明对应的 bean 还没有被实例化或是非单例的 bean，这个时候就需要创建对象（通过工厂方法或构造函数创建），Spring 创建对象的基本执行流程为：</p><blockquote><ol><li>如果存在工厂方法，则使用工厂方法初始化</li><li>否则，如果存在多个构造函数，则根据参数确定构造函数，并利用构造函数初始化</li><li>否则，使用默认构造函数初始化</li></ol></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> BeanWrapper <span class="token function">createBeanInstance</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> RootBeanDefinition mbd<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> beanClass <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveBeanClass</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 解析class引用</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>beanClass <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Modifier<span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isNonPublicAccessAllowed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Bean class isn't public, and non-public access not allowed: "</span> <span class="token operator">+</span> beanClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*1. 如果工厂方法不为空，则使用工厂方法进行实例化*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getFactoryMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">instantiateUsingFactoryMethod</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*2. 利用构造函数进行实例化，解析并确定目标构造函数*/</span>    <span class="token keyword">boolean</span> resolved <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> autowireNecessary <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>args <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span>constructorArgumentLock<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 一个类可能有多个构造函数，需要根据参数来确定具体的构造函数</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span>resolvedConstructorOrFactoryMethod <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                resolved <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                autowireNecessary <span class="token operator">=</span> mbd<span class="token punctuation">.</span>constructorArgumentsResolved<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果已经解析过，则使用已经确定的构造方法</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolved<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>autowireNecessary<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 依据构造函数注入</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">autowireConstructor</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 使用默认构造函数构造</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">instantiateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 需要根据参数决定使用哪个构造函数</span>    Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> ctors <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">determineConstructorsFromBeanPostProcessors</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ctors <span class="token operator">!=</span> null <span class="token operator">||</span>            mbd<span class="token punctuation">.</span><span class="token function">getResolvedAutowireMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RootBeanDefinition<span class="token punctuation">.</span>AUTOWIRE_CONSTRUCTOR <span class="token operator">||</span> <span class="token comment" spellcheck="true">// 构造函数注入</span>            mbd<span class="token punctuation">.</span><span class="token function">hasConstructorArgumentValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>ObjectUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 存在构造函数配置</span>        <span class="token comment" spellcheck="true">// 构造函数自动注入</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">autowireConstructor</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> ctors<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*3. 使用默认的构造函数*/</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">instantiateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>上述源码是属于框架式的源码，描述了整个实例化的执行流程（如前面所述），接下来我们需要继续往下深入，探究各种实例化过程，以及容器确定目标构造函数的算法。</p><p>如果存在 factory-method 则说明存在工厂方法执行实例化，Spring 通过 instantiateUsingFactoryMethod 方法执行实例化过程：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> BeanWrapper <span class="token function">instantiateUsingFactoryMethod</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> RootBeanDefinition mbd<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> explicitArgs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConstructorResolver</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">instantiateUsingFactoryMethod</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> explicitArgs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> BeanWrapper <span class="token function">instantiateUsingFactoryMethod</span><span class="token punctuation">(</span><span class="token keyword">final</span> String beanName<span class="token punctuation">,</span> <span class="token keyword">final</span> RootBeanDefinition mbd<span class="token punctuation">,</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> explicitArgs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建并初始化 BeanWrapper</span>    BeanWrapperImpl bw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanWrapperImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">.</span><span class="token function">initBeanWrapper</span><span class="token punctuation">(</span>bw<span class="token punctuation">)</span><span class="token punctuation">;</span>     Object factoryBean<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 工厂</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> factoryClass<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 工厂所指代的类</span>    <span class="token keyword">boolean</span> isStatic<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 是不是静态工厂</span>    String factoryBeanName <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getFactoryBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取factory-bean</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>factoryBeanName <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         * 存在factory-bean，说明是非静态工厂         *         * &lt;bean id="my-bean-simple-factory" class="org.zhenchao.factory.MyBeanSimpleFactory"/>         * &lt;bean id="my-bean-1" factory-bean="my-bean-simple-factory" factory-method="create"/>         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>factoryBeanName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionStoreException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"factory-bean reference points back to the same bean definition"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取工厂bean实例</span>        factoryBean <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>factoryBeanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>factoryBean <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"factory-bean '"</span> <span class="token operator">+</span> factoryBeanName <span class="token operator">+</span> <span class="token string">"' (or a BeanPostProcessor involved) returned null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 单例不需要由工厂主动创建</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">.</span><span class="token function">containsSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"About-to-be-created singleton instance implicitly appeared through the creation of the factory bean that its bean definition points to"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        factoryClass <span class="token operator">=</span> factoryBean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        isStatic <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*         * 不存在factory-bean，说明是静态工厂         *         * &lt;bean id="my-bean-2" class="org.zhenchao.factory.MyBeanStaticFactory" factory-method="create"/>         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">hasBeanClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionStoreException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"bean definition declares neither a bean class nor a factory-bean reference"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        factoryBean <span class="token operator">=</span> null<span class="token punctuation">;</span>        factoryClass <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getBeanClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        isStatic <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     Method factoryMethodToUse <span class="token operator">=</span> null<span class="token punctuation">;</span>    ArgumentsHolder argsHolderToUse <span class="token operator">=</span> null<span class="token punctuation">;</span>    Object<span class="token punctuation">[</span><span class="token punctuation">]</span> argsToUse <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>explicitArgs <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// getBean时传递的构造参数</span>        argsToUse <span class="token operator">=</span> explicitArgs<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果没有则需要进行解析</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> argsToResolve <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 尝试从缓存中获取</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span>constructorArgumentLock<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            factoryMethodToUse <span class="token operator">=</span> <span class="token punctuation">(</span>Method<span class="token punctuation">)</span> mbd<span class="token punctuation">.</span>resolvedConstructorOrFactoryMethod<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>factoryMethodToUse <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> mbd<span class="token punctuation">.</span>constructorArgumentsResolved<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 存在已经解析过的工厂方法</span>                argsToUse <span class="token operator">=</span> mbd<span class="token punctuation">.</span>resolvedConstructorArguments<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>argsToUse <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 获取待解析的构造参数</span>                    argsToResolve <span class="token operator">=</span> mbd<span class="token punctuation">.</span>preparedConstructorArguments<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 缓存命中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>argsToResolve <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 解析参数值，必要的话会进行类型转换</span>            argsToUse <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolvePreparedArguments</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> factoryMethodToUse<span class="token punctuation">,</span> argsToResolve<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 缓存未命中，则基于参数来解析决策确定的工厂方法</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>factoryMethodToUse <span class="token operator">==</span> null <span class="token operator">||</span> argsToUse <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取候选的工厂方法</span>        factoryClass <span class="token operator">=</span> ClassUtils<span class="token punctuation">.</span><span class="token function">getUserClass</span><span class="token punctuation">(</span>factoryClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> rawCandidates <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCandidateMethods</span><span class="token punctuation">(</span>factoryClass<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Method<span class="token operator">></span> candidateSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Method<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Method candidate <span class="token operator">:</span> rawCandidates<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Modifier<span class="token punctuation">.</span><span class="token function">isStatic</span><span class="token punctuation">(</span>candidate<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> isStatic <span class="token operator">&amp;&amp;</span> mbd<span class="token punctuation">.</span><span class="token function">isFactoryMethod</span><span class="token punctuation">(</span>candidate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                candidateSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidate<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> candidates <span class="token operator">=</span> candidateSet<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Method</span><span class="token punctuation">[</span>candidateSet<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 对候选方法进行排序，public在前，参数多的在前</span>        AutowireUtils<span class="token punctuation">.</span><span class="token function">sortFactoryMethods</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>         ConstructorArgumentValues resolvedValues <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> autowiring <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResolvedAutowireMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RootBeanDefinition<span class="token punctuation">.</span>AUTOWIRE_CONSTRUCTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minTypeDiffWeight <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>Method<span class="token operator">></span> ambiguousFactoryMethods <span class="token operator">=</span> null<span class="token punctuation">;</span>         <span class="token keyword">int</span> minNrOfArgs<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>explicitArgs <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// getBean时明确指定了参数</span>            minNrOfArgs <span class="token operator">=</span> explicitArgs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 没有指定，则从beanDefinition实例中解析</span>            ConstructorArgumentValues cargs <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getConstructorArgumentValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            resolvedValues <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConstructorArgumentValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获取解析到的参数个数</span>            minNrOfArgs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveConstructorArguments</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> cargs<span class="token punctuation">,</span> resolvedValues<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         LinkedList<span class="token operator">&lt;</span>UnsatisfiedDependencyException<span class="token operator">></span> causes <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历候选方法</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Method candidate <span class="token operator">:</span> candidates<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> paramTypes <span class="token operator">=</span> candidate<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>paramTypes<span class="token punctuation">.</span>length <span class="token operator">>=</span> minNrOfArgs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                ArgumentsHolder argsHolder<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>resolvedValues <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// Resolved constructor arguments: type conversion and/or autowiring necessary.</span>                    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        String<span class="token punctuation">[</span><span class="token punctuation">]</span> paramNames <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 获取参数名称探测去</span>                        ParameterNameDiscoverer pnd <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">.</span><span class="token function">getParameterNameDiscoverer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>pnd <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 获取候选方法的参数名称列表</span>                            paramNames <span class="token operator">=</span> pnd<span class="token punctuation">.</span><span class="token function">getParameterNames</span><span class="token punctuation">(</span>candidate<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 依据参数名称和类型创建参数持有对象</span>                        argsHolder <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createArgumentArray</span><span class="token punctuation">(</span>                                beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> resolvedValues<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> paramTypes<span class="token punctuation">,</span> paramNames<span class="token punctuation">,</span> candidate<span class="token punctuation">,</span> autowiring<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsatisfiedDependencyException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"Ignoring factory method ["</span> <span class="token operator">+</span> candidate <span class="token operator">+</span> <span class="token string">"] of bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"': "</span> <span class="token operator">+</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 异常，尝试下一个候选工厂方法</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>causes <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            causes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>UnsatisfiedDependencyException<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                        causes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>paramTypes<span class="token punctuation">.</span>length <span class="token operator">!=</span> explicitArgs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 参数个数不等于期望的参数个数</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    argsHolder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArgumentsHolder</span><span class="token punctuation">(</span>explicitArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 检测是否有不确定的候选方法存在（比如不同方法的参数存在继承关系）</span>                <span class="token keyword">int</span> typeDiffWeight <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isLenientConstructorResolution</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span>                        argsHolder<span class="token punctuation">.</span><span class="token function">getTypeDifferenceWeight</span><span class="token punctuation">(</span>paramTypes<span class="token punctuation">)</span> <span class="token operator">:</span> argsHolder<span class="token punctuation">.</span><span class="token function">getAssignabilityWeight</span><span class="token punctuation">(</span>paramTypes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 选择最近似的候选方法</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>typeDiffWeight <span class="token operator">&lt;</span> minTypeDiffWeight<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    factoryMethodToUse <span class="token operator">=</span> candidate<span class="token punctuation">;</span>                    argsHolderToUse <span class="token operator">=</span> argsHolder<span class="token punctuation">;</span>                    argsToUse <span class="token operator">=</span> argsHolder<span class="token punctuation">.</span>arguments<span class="token punctuation">;</span>                    minTypeDiffWeight <span class="token operator">=</span> typeDiffWeight<span class="token punctuation">;</span>                    ambiguousFactoryMethods <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>factoryMethodToUse <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> typeDiffWeight <span class="token operator">==</span> minTypeDiffWeight <span class="token operator">&amp;&amp;</span>                        <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isLenientConstructorResolution</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                        paramTypes<span class="token punctuation">.</span>length <span class="token operator">==</span> factoryMethodToUse<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span>                        <span class="token operator">!</span>Arrays<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>paramTypes<span class="token punctuation">,</span> factoryMethodToUse<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>ambiguousFactoryMethods <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        ambiguousFactoryMethods <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span>Method<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        ambiguousFactoryMethods<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>factoryMethodToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    ambiguousFactoryMethods<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidate<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>factoryMethodToUse <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 无法确定具体的工厂方法</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>causes <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                UnsatisfiedDependencyException ex <span class="token operator">=</span> causes<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>Exception cause <span class="token operator">:</span> causes<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">.</span><span class="token function">onSuppressedException</span><span class="token punctuation">(</span>cause<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span> argTypes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>minNrOfArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>explicitArgs <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>Object arg <span class="token operator">:</span> explicitArgs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    argTypes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arg <span class="token operator">!=</span> null <span class="token operator">?</span> arg<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                Set<span class="token operator">&lt;</span>ValueHolder<span class="token operator">></span> valueHolders <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span>ValueHolder<span class="token operator">></span><span class="token punctuation">(</span>resolvedValues<span class="token punctuation">.</span><span class="token function">getArgumentCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                valueHolders<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>resolvedValues<span class="token punctuation">.</span><span class="token function">getIndexedArgumentValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                valueHolders<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>resolvedValues<span class="token punctuation">.</span><span class="token function">getGenericArgumentValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>ValueHolder value <span class="token operator">:</span> valueHolders<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    String argType <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">?</span> ClassUtils<span class="token punctuation">.</span><span class="token function">getShortName</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span>                            <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">?</span> value<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    argTypes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>argType<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            String argDesc <span class="token operator">=</span> StringUtils<span class="token punctuation">.</span><span class="token function">collectionToCommaDelimitedString</span><span class="token punctuation">(</span>argTypes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span>                    <span class="token string">"No matching factory method found: "</span> <span class="token operator">+</span>  <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getFactoryBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">?</span>  <span class="token string">"factory bean '"</span> <span class="token operator">+</span> mbd<span class="token punctuation">.</span><span class="token function">getFactoryBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"'; "</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">+</span>                            <span class="token string">"factory method '"</span> <span class="token operator">+</span> mbd<span class="token punctuation">.</span><span class="token function">getFactoryMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"("</span> <span class="token operator">+</span> argDesc <span class="token operator">+</span> <span class="token string">")'. "</span> <span class="token operator">+</span> <span class="token string">"Check that a method with the specified name "</span> <span class="token operator">+</span>                            <span class="token punctuation">(</span>minNrOfArgs <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">"and arguments "</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"exists and that it is "</span> <span class="token operator">+</span>  <span class="token punctuation">(</span>isStatic <span class="token operator">?</span> <span class="token string">"static"</span> <span class="token operator">:</span> <span class="token string">"non-static"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">==</span> factoryMethodToUse<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Invalid factory method '"</span> <span class="token operator">+</span> mbd<span class="token punctuation">.</span><span class="token function">getFactoryMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"': needs to have a non-void return type!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ambiguousFactoryMethods <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span>                    <span class="token string">"Ambiguous factory method matches found in bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' "</span> <span class="token operator">+</span> <span class="token string">"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): "</span> <span class="token operator">+</span>  ambiguousFactoryMethods<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>explicitArgs <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> argsHolderToUse <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 缓存</span>            argsHolderToUse<span class="token punctuation">.</span><span class="token function">storeCache</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> factoryMethodToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 利用工厂方法创建bean实例</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Object beanInstance<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> Object fb <span class="token operator">=</span> factoryBean<span class="token punctuation">;</span>            <span class="token keyword">final</span> Method factoryMethod <span class="token operator">=</span> factoryMethodToUse<span class="token punctuation">;</span>            <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token operator">=</span> argsToUse<span class="token punctuation">;</span>            beanInstance <span class="token operator">=</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> Object <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> beanFactory<span class="token punctuation">.</span><span class="token function">getInstantiationStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">instantiate</span><span class="token punctuation">(</span>                            mbd<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> beanFactory<span class="token punctuation">,</span> fb<span class="token punctuation">,</span> factoryMethod<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> beanFactory<span class="token punctuation">.</span><span class="token function">getAccessControlContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 基于java反射调用工厂bean的指定方法依据给定的参数进行实例化</span>            beanInstance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">.</span><span class="token function">getInstantiationStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">instantiate</span><span class="token punctuation">(</span>                    mbd<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">,</span> factoryBean<span class="token punctuation">,</span> factoryMethodToUse<span class="token punctuation">,</span> argsToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>beanInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        bw<span class="token punctuation">.</span><span class="token function">setBeanInstance</span><span class="token punctuation">(</span>beanInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bw<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Bean instantiation via factory method failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>方法实现真的很长！不过整个方法主要做了三件事情：</p><blockquote><ol><li>确定当前使用的是静态工厂配置还是一般工厂配置。</li><li>确定用于实例化 bean 的工厂方法。</li><li>调用工厂方法实例化 bean。</li></ol></blockquote><p>其中最复杂的是步骤 2，因为可能存在多个工厂方法的重载版本，所以需要依据给定或配置的参数个数和类型去解析确定的工厂方法，Spring 会对所有的候选工厂方法按照 public 优先，以及参数个数多的方法优先的原则，对候选方法进行排序，然后逐个比对是否满足当前指定的参数列表，依次确定具体使用哪个工厂方法来进行实例化，这个过程与我们后面介绍的通过构造方法进行实例化时确定具体构造方法的过程大同小异，后面你还会看到与此相似的解析过程。</p><p>跳出这个方法，我们继续之前的逻辑往下走，如果一个 bean 没有配置工厂方法则需要通过构造函数进行实例化，如前面所说，一个类也可能存在多个重载的构造方法，所以需要依据给定或配置的构造参数进行决策：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> BeanWrapper <span class="token function">autowireConstructor</span><span class="token punctuation">(</span>        String beanName<span class="token punctuation">,</span> RootBeanDefinition mbd<span class="token punctuation">,</span> Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> ctors<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> explicitArgs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConstructorResolver</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">autowireConstructor</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> ctors<span class="token punctuation">,</span> explicitArgs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> BeanWrapper <span class="token function">autowireConstructor</span><span class="token punctuation">(</span>        <span class="token keyword">final</span> String beanName<span class="token punctuation">,</span> <span class="token keyword">final</span> RootBeanDefinition mbd<span class="token punctuation">,</span> Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> chosenCtors<span class="token punctuation">,</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> explicitArgs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建并初始化BeanWrapper</span>    BeanWrapperImpl bw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanWrapperImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">.</span><span class="token function">initBeanWrapper</span><span class="token punctuation">(</span>bw<span class="token punctuation">)</span><span class="token punctuation">;</span>     Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> constructorToUse <span class="token operator">=</span> null<span class="token punctuation">;</span>    ArgumentsHolder argsHolderToUse <span class="token operator">=</span> null<span class="token punctuation">;</span>    Object<span class="token punctuation">[</span><span class="token punctuation">]</span> argsToUse <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>explicitArgs <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用getBean时明确指定了构造参数explicitArgs</span>        argsToUse <span class="token operator">=</span> explicitArgs<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 尝试从缓存中获取</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> argsToResolve <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span>constructorArgumentLock<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            constructorToUse <span class="token operator">=</span> <span class="token punctuation">(</span>Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> mbd<span class="token punctuation">.</span>resolvedConstructorOrFactoryMethod<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>constructorToUse <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> mbd<span class="token punctuation">.</span>constructorArgumentsResolved<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 找到了缓存的构造方法</span>                argsToUse <span class="token operator">=</span> mbd<span class="token punctuation">.</span>resolvedConstructorArguments<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>argsToUse <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 配置的构造函数参数</span>                    argsToResolve <span class="token operator">=</span> mbd<span class="token punctuation">.</span>preparedConstructorArguments<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果缓存中存在</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>argsToResolve <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 解析参数类型，将字符串值转换为真实的值，缓存中的值可能是原始值也可能是解析后的值</span>            argsToUse <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolvePreparedArguments</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> constructorToUse<span class="token punctuation">,</span> argsToResolve<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 没有缓存则从配置文件中解析</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>constructorToUse <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 需要解析确定具体的构造方法</span>        <span class="token keyword">boolean</span> autowiring <span class="token operator">=</span> <span class="token punctuation">(</span>chosenCtors <span class="token operator">!=</span> null <span class="token operator">||</span>                mbd<span class="token punctuation">.</span><span class="token function">getResolvedAutowireMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RootBeanDefinition<span class="token punctuation">.</span>AUTOWIRE_CONSTRUCTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>        ConstructorArgumentValues resolvedValues <span class="token operator">=</span> null<span class="token punctuation">;</span>         <span class="token keyword">int</span> minNrOfArgs<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录解析到的参数个数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>explicitArgs <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            minNrOfArgs <span class="token operator">=</span> explicitArgs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 提取配置的构造函数参数值</span>            ConstructorArgumentValues cargs <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getConstructorArgumentValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            resolvedValues <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConstructorArgumentValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于承载解析后的构造函数参数的值</span>            <span class="token comment" spellcheck="true">// 解析构造参数</span>            minNrOfArgs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveConstructorArguments</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> cargs<span class="token punctuation">,</span> resolvedValues<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 获取候选的构造方法集合</span>        Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates <span class="token operator">=</span> chosenCtors<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>candidates <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> beanClass <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getBeanClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                candidates <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isNonPublicAccessAllowed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> beanClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> beanClass<span class="token punctuation">.</span><span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Resolution of declared constructors on bean Class ["</span> <span class="token operator">+</span> beanClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"] from ClassLoader ["</span> <span class="token operator">+</span> beanClass<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"] failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 排序构造函数，public在前，参数多的在前</span>        AutowireUtils<span class="token punctuation">.</span><span class="token function">sortConstructors</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> minTypeDiffWeight <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> ambiguousConstructors <span class="token operator">=</span> null<span class="token punctuation">;</span>        LinkedList<span class="token operator">&lt;</span>UnsatisfiedDependencyException<span class="token operator">></span> causes <span class="token operator">=</span> null<span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> candidate <span class="token operator">:</span> candidates<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> paramTypes <span class="token operator">=</span> candidate<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>constructorToUse <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> argsToUse<span class="token punctuation">.</span>length <span class="token operator">></span> paramTypes<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 已经找到目标构造函数，或者已有的构造函数的参数个数已经小于期望的个数</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>paramTypes<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> minNrOfArgs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 参数个数不相等</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>             ArgumentsHolder argsHolder<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolvedValues <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 有参数则根据对应的值构造对应参数类型的参数</span>                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 从注解上获得参数名称</span>                    String<span class="token punctuation">[</span><span class="token punctuation">]</span> paramNames <span class="token operator">=</span> ConstructorPropertiesChecker<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span>candidate<span class="token punctuation">,</span> paramTypes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>paramNames <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 获取参数名称探测器</span>                        ParameterNameDiscoverer pnd <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">.</span><span class="token function">getParameterNameDiscoverer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>pnd <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 获取构造方法的参数名称列表</span>                            paramNames <span class="token operator">=</span> pnd<span class="token punctuation">.</span><span class="token function">getParameterNames</span><span class="token punctuation">(</span>candidate<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 根据数值和类型创建参数持有者</span>                    argsHolder <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createArgumentArray</span><span class="token punctuation">(</span>                            beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> resolvedValues<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> paramTypes<span class="token punctuation">,</span> paramNames<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getUserDeclaredConstructor</span><span class="token punctuation">(</span>candidate<span class="token punctuation">)</span><span class="token punctuation">,</span> autowiring<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsatisfiedDependencyException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"Ignoring constructor ["</span> <span class="token operator">+</span> candidate <span class="token operator">+</span> <span class="token string">"] of bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"': "</span> <span class="token operator">+</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 尝试下一个构造函数</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>causes <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        causes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>UnsatisfiedDependencyException<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    causes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 参数个数不匹配</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>paramTypes<span class="token punctuation">.</span>length <span class="token operator">!=</span> explicitArgs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 构造函数没有参数的情况</span>                argsHolder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArgumentsHolder</span><span class="token punctuation">(</span>explicitArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 探测是否有不确定性的构造函数存在，不如不同构造函数的参数为继承关系</span>            <span class="token keyword">int</span> typeDiffWeight <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isLenientConstructorResolution</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span>                    argsHolder<span class="token punctuation">.</span><span class="token function">getTypeDifferenceWeight</span><span class="token punctuation">(</span>paramTypes<span class="token punctuation">)</span> <span class="token operator">:</span> argsHolder<span class="token punctuation">.</span><span class="token function">getAssignabilityWeight</span><span class="token punctuation">(</span>paramTypes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果当前的不确定性构造函数最接近期望值，则选择作为构造函数</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>typeDiffWeight <span class="token operator">&lt;</span> minTypeDiffWeight<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                constructorToUse <span class="token operator">=</span> candidate<span class="token punctuation">;</span>                argsHolderToUse <span class="token operator">=</span> argsHolder<span class="token punctuation">;</span>                argsToUse <span class="token operator">=</span> argsHolder<span class="token punctuation">.</span>arguments<span class="token punctuation">;</span>                minTypeDiffWeight <span class="token operator">=</span> typeDiffWeight<span class="token punctuation">;</span>                ambiguousConstructors <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>constructorToUse <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> typeDiffWeight <span class="token operator">==</span> minTypeDiffWeight<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ambiguousConstructors <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    ambiguousConstructors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span>Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    ambiguousConstructors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>constructorToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                ambiguousConstructors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidate<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>constructorToUse <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>causes <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                UnsatisfiedDependencyException ex <span class="token operator">=</span> causes<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>Exception cause <span class="token operator">:</span> causes<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">.</span><span class="token function">onSuppressedException</span><span class="token punctuation">(</span>cause<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span>                    <span class="token string">"Could not resolve matching constructor (hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ambiguousConstructors <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isLenientConstructorResolution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span>                    <span class="token string">"Ambiguous constructor matches found in bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' (hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): "</span> <span class="token operator">+</span> ambiguousConstructors<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>explicitArgs <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将解析的构造函数加入缓存</span>            argsHolderToUse<span class="token punctuation">.</span><span class="token function">storeCache</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> constructorToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 依据构造方法进行实例化</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Object beanInstance<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> ctorToUse <span class="token operator">=</span> constructorToUse<span class="token punctuation">;</span>            <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> argumentsToUse <span class="token operator">=</span> argsToUse<span class="token punctuation">;</span>            beanInstance <span class="token operator">=</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> Object <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> beanFactory<span class="token punctuation">.</span><span class="token function">getInstantiationStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">instantiate</span><span class="token punctuation">(</span>                            mbd<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> beanFactory<span class="token punctuation">,</span> ctorToUse<span class="token punctuation">,</span> argumentsToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> beanFactory<span class="token punctuation">.</span><span class="token function">getAccessControlContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 基于反射创建对象</span>            beanInstance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">.</span><span class="token function">getInstantiationStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">instantiate</span><span class="token punctuation">(</span>                    mbd<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">,</span> constructorToUse<span class="token punctuation">,</span> argsToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 将构造的实例加入BeanWrapper</span>        bw<span class="token punctuation">.</span><span class="token function">setBeanInstance</span><span class="token punctuation">(</span>beanInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bw<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Bean instantiation via constructor failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>整个方法的设计思想与前面通过工厂方法实例化对象相同，具体可参考注释，不再展开，而如果没有指定或配置构造参数，容器会采用默认的构造方法创建对象，该过程位于 instantiateBean 方法中：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> BeanWrapper <span class="token function">instantiateBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> String beanName<span class="token punctuation">,</span> <span class="token keyword">final</span> RootBeanDefinition mbd<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Object beanInstance<span class="token punctuation">;</span>        <span class="token keyword">final</span> BeanFactory parent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            beanInstance <span class="token operator">=</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> Object <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token function">getInstantiationStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">instantiate</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token function">getAccessControlContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 利用反射进行实例化</span>            beanInstance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getInstantiationStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">instantiate</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 利用包装器包装bean实例</span>        BeanWrapper bw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanWrapperImpl</span><span class="token punctuation">(</span>beanInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initBeanWrapper</span><span class="token punctuation">(</span>bw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bw<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Instantiation of bean failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>需要知晓的一点是，经过上面的流程，不管是通过通过工厂方法还是构造方法来实例化对象，到这里得到的也仅仅是一个 bean 的最初实例，还不是我们最终期望的 bean，因为后面还需要对 bean 实例进行初始化处理，注入相应的属性值等。</p><p><strong>3. 应用 MergedBeanDefinitionPostProcessor</strong></p><p>如果我们实现并注册了 MergedBeanDefinitionPostProcessor 处理器，希望在对 bean 初始化之前对 beanDefinition 进行处理，那么这些处理器会在这里被逐一调用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">applyMergedBeanDefinitionPostProcessors</span><span class="token punctuation">(</span>RootBeanDefinition mbd<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> beanType<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>BeanPostProcessor bp <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历所有的后置处理器</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bp <span class="token keyword">instanceof</span> <span class="token class-name">MergedBeanDefinitionPostProcessor</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果是 MergedBeanDefinitionPostProcessor 则进行应用</span>            MergedBeanDefinitionPostProcessor bdp <span class="token operator">=</span> <span class="token punctuation">(</span>MergedBeanDefinitionPostProcessor<span class="token punctuation">)</span> bp<span class="token punctuation">;</span>            bdp<span class="token punctuation">.</span><span class="token function">postProcessMergedBeanDefinition</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> beanType<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>4. 检查是否需要提前曝光，避免循环依赖</strong></p><p>对于单例而言，Spring 会通过提前曝光的机制来尝试解决循环依赖导致的死锁问题，循环依赖导致的死锁除了发生在构造方法注入时，也可能发生在 setter 方法注入过程中，对于前者而言，容器是无法解决循环依赖问题的，只能抛出异常，而后者则可以通过提前曝光的机制来达到“先引用，后初始化”的目的，所以不会死锁，这个过程的关键代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> earlySingletonExposure <span class="token operator">=</span> <span class="token punctuation">(</span>            mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 单例</span>                    <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>allowCircularReferences <span class="token comment" spellcheck="true">// 允许循环依赖，需要通过程序设置</span>                    <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前 bean 正在创建中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Eagerly caching bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' to allow for resolving potential circular references"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为避免循环依赖，在完成bean实例化之前，将对应的ObjectFactory加入创建bean的工厂集合中</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addSingletonFactory</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ObjectFactory</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Object <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 对bean再一次依赖引用，应用SmartInstantiationAwareBeanPostProcessor</span>                <span class="token keyword">return</span> <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>方法的逻辑是先判断是否允许提前曝光，如果当前为单例 bean，且程序制定允许循环引用，同时当前 bean 正处于创建中，则会将创建 bean 的 ObjectFactory 对象加入到用于保存 beanName 和创建 bean 的工厂之间的关系的集合中：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addSingletonFactory</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> singletonFactory<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>singletonFactory<span class="token punctuation">,</span> <span class="token string">"Singleton factory must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>registeredSingletons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><blockquote><p>说明一下方法中各个变量的意义</p><ul><li>singletonObjects：用于保存 beanName 和 bean 实例之间的关系</li><li>singletonFactories：用于保存 beanName 和创建 bean 的工厂之间的关系</li><li>earlySingletonObjects：也是保存 beanName 和 bean 实例之间的关系，不同于 singletonObjects，当一个bean的实例放置于其中后，当bean还在创建过程中就可以通过 getBean 方法获取到</li><li>registeredSingletons：用来保存当前所有已注册的 bean</li></ul></blockquote><p>上面这段逻辑位于初始化 bean 实例之前，其用意就是当初始化一个 bean 时，如果引用了另外一个 bean，这个时候就需要转而去创建并初始化另外一个 bean，如果恰好该 bean 引用了之前的 bean 就出现了循环依赖，假设我们令第一个 bean 为 A，第二个 bean 为 B，基于这段代码的逻辑，B 就可以先给自己类型为 A 的属性注入 A 的实例（这个时候 A 还没有被初始化），然后完成初始化，此时继续回到初始化 A 的逻辑，因为都是单例，所以当 A 完成了初始化之后，B 所引用的 A 对象也就是一个完成了初始化过程的对象，而不是之前的刚刚完成对象创建还没有注入属性的实例。</p><h5 id="4-1-5-初始化-bean-实例"><a href="#4-1-5-初始化-bean-实例" class="headerlink" title="4.1.5 初始化 bean 实例"></a>4.1.<strong>5 初始化 bean 实例</strong></h5><p>整个初始化过程包括 <strong>属性注入</strong> 和 <strong>执行初始化方法</strong> 两个步骤。我们先来看属性注入的过程，该过程位于 populateBean 方法中（populate，这个词用的很有想象力~）：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">populateBean</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> RootBeanDefinition mbd<span class="token punctuation">,</span> BeanWrapper bw<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取bean实例的属性值集合</span>    PropertyValues pvs <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bw <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pvs<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// null对象，但是存在填充的属性，不合理</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Cannot apply property values to null instance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// null 对象，且没有属性可以填充，直接返回</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token keyword">boolean</span> continueWithPropertyPopulation <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 给InstantiationAwareBeanPostProcessors最后一次机会在注入属性前改变bean实例</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isSynthetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hasInstantiationAwareBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>BeanPostProcessor bp <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bp <span class="token keyword">instanceof</span> <span class="token class-name">InstantiationAwareBeanPostProcessor</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                InstantiationAwareBeanPostProcessor ibp <span class="token operator">=</span> <span class="token punctuation">(</span>InstantiationAwareBeanPostProcessor<span class="token punctuation">)</span> bp<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 是否继续填充bean</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ibp<span class="token punctuation">.</span><span class="token function">postProcessAfterInstantiation</span><span class="token punctuation">(</span>bw<span class="token punctuation">.</span><span class="token function">getWrappedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    continueWithPropertyPopulation <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果处理器指明不需要再继续执行属性注入，则返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>continueWithPropertyPopulation<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// autowire by name or autowire by type</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResolvedAutowireMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RootBeanDefinition<span class="token punctuation">.</span>AUTOWIRE_BY_NAME            <span class="token operator">||</span> mbd<span class="token punctuation">.</span><span class="token function">getResolvedAutowireMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RootBeanDefinition<span class="token punctuation">.</span>AUTOWIRE_BY_TYPE<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        MutablePropertyValues newPvs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutablePropertyValues</span><span class="token punctuation">(</span>pvs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 根据名称自动注入</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResolvedAutowireMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RootBeanDefinition<span class="token punctuation">.</span>AUTOWIRE_BY_NAME<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">autowireByName</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> newPvs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 根据类型自动注入</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResolvedAutowireMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RootBeanDefinition<span class="token punctuation">.</span>AUTOWIRE_BY_TYPE<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">autowireByType</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> newPvs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        pvs <span class="token operator">=</span> newPvs<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token keyword">boolean</span> hasInstAwareBpps <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hasInstantiationAwareBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> needsDepCheck <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getDependencyCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> RootBeanDefinition<span class="token punctuation">.</span>DEPENDENCY_CHECK_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hasInstAwareBpps <span class="token operator">||</span> needsDepCheck<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        PropertyDescriptor<span class="token punctuation">[</span><span class="token punctuation">]</span> filteredPds <span class="token operator">=</span> <span class="token function">filterPropertyDescriptorsForDependencyCheck</span><span class="token punctuation">(</span>bw<span class="token punctuation">,</span> mbd<span class="token punctuation">.</span>allowCaching<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 在属性注入前应用实例化后置处理器</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hasInstAwareBpps<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>BeanPostProcessor bp <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>bp <span class="token keyword">instanceof</span> <span class="token class-name">InstantiationAwareBeanPostProcessor</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    InstantiationAwareBeanPostProcessor ibp <span class="token operator">=</span> <span class="token punctuation">(</span>InstantiationAwareBeanPostProcessor<span class="token punctuation">)</span> bp<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 调用后置处理器的postProcessPropertyValues方法</span>                    pvs <span class="token operator">=</span> ibp<span class="token punctuation">.</span><span class="token function">postProcessPropertyValues</span><span class="token punctuation">(</span>pvs<span class="token punctuation">,</span> filteredPds<span class="token punctuation">,</span> bw<span class="token punctuation">.</span><span class="token function">getWrappedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pvs <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 处理器中把属性值处理没了，则继续执行属性注入已经没有意义</span>                        <span class="token keyword">return</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 依赖检查，对应depends-on属性，该属性已经弃用</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>needsDepCheck<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkDependencies</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> filteredPds<span class="token punctuation">,</span> pvs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 执行属性注入</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">applyPropertyValues</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> pvs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>该方法中会执行 InstantiationAwareBeanPostProcessor 后置处理器的 postProcessAfterInstantiation 方法逻辑，从而实现对完成实例化且还没有注入属性值的对象进行最后的更改，如果我们在 postProcessAfterInstantiation 指明不需要执行后续的属性注入过程，则方法到此结束。否则方法会检测当前的注入类型，是 byName 还是 byType，并调用相应的注入逻辑获取依赖的 bean，加入属性集合中。然后方法会调用 InstantiationAwareBeanPostProcessor 后置处理器的 postProcessPropertyValues 方法，实现在将属性值应用到 bean 实例之前的最后一次对属性值的更改，同时会依据配置执行依赖检查，以确保所有的属性都被赋值（这里的赋值是指 beanDefinition 中的属性都有对应的值，而不是指最终 bean 实例的属性是否注入了对应的值）。最后将输入值应用到 bean 实例对应的属性上。</p><ul><li><strong>autowireByName</strong></li></ul><p>如果当前注入类型是 byName，则容器会基于 beanName 获取依赖的 bean，并将依赖关系保存在对应的集合中，如果依赖的 bean 未被实例化则需要执行实例化逻辑：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">autowireByName</span><span class="token punctuation">(</span>        String beanName<span class="token punctuation">,</span> AbstractBeanDefinition mbd<span class="token punctuation">,</span> BeanWrapper bw<span class="token punctuation">,</span> MutablePropertyValues pvs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 寻找需要注入的属性</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> propertyNames <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unsatisfiedNonSimpleProperties</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> bw<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String propertyName <span class="token operator">:</span> propertyNames<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">containsBean</span><span class="token punctuation">(</span>propertyName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果依赖的bean没有初始化，则递归初始化相关的bean</span>            Object bean <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>propertyName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 添加到属性集合中</span>            pvs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>propertyName<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 记录依赖关系到集合中</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerDependentBean</span><span class="token punctuation">(</span>propertyName<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Added autowiring by name from bean name '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' via property '"</span> <span class="token operator">+</span> propertyName <span class="token operator">+</span> <span class="token string">"' to bean named '"</span> <span class="token operator">+</span> propertyName <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"Not autowiring property '"</span> <span class="token operator">+</span> propertyName <span class="token operator">+</span> <span class="token string">"' of bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' by name: no matching bean found"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ul><li><strong>autowireByType</strong></li></ul><p>如果当前注入类型是 byType，则容器会依据类型去确定对应的 bean，并将依赖关系保存到对应的集合中，如果依赖的 bean 未被实例化则需要执行实例化逻辑，因为类型注入需要一个推断的过程，所以实现逻辑要复杂很多：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">autowireByType</span><span class="token punctuation">(</span>            String beanName<span class="token punctuation">,</span> AbstractBeanDefinition mbd<span class="token punctuation">,</span> BeanWrapper bw<span class="token punctuation">,</span> MutablePropertyValues pvs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     TypeConverter converter <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCustomTypeConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>converter <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        converter <span class="token operator">=</span> bw<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     Set<span class="token operator">&lt;</span>String<span class="token operator">></span> autowiredBeanNames <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 寻找需要注入的属性</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> propertyNames <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unsatisfiedNonSimpleProperties</span><span class="token punctuation">(</span>mbd<span class="token punctuation">,</span> bw<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String propertyName <span class="token operator">:</span> propertyNames<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            PropertyDescriptor pd <span class="token operator">=</span> bw<span class="token punctuation">.</span><span class="token function">getPropertyDescriptor</span><span class="token punctuation">(</span>propertyName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">!=</span> pd<span class="token punctuation">.</span><span class="token function">getPropertyType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 获取指定属性的set方法</span>                MethodParameter methodParam <span class="token operator">=</span> BeanUtils<span class="token punctuation">.</span><span class="token function">getWriteMethodParameter</span><span class="token punctuation">(</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">boolean</span> eager <span class="token operator">=</span> <span class="token operator">!</span>PriorityOrdered<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>bw<span class="token punctuation">.</span><span class="token function">getWrappedClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                DependencyDescriptor desc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AutowireByTypeDependencyDescriptor</span><span class="token punctuation">(</span>methodParam<span class="token punctuation">,</span> eager<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/*                 * 解析指定beanName的属性所匹配的值，并把解析到的属性存储在autowiredBeanNames中，当属性存在多个封装的bean时，比如：                 *                 * @Autowired                 * private List&lt;A> list                 *                 * 将会找到所有匹配A类型的bean，并将其注入                 */</span>                Object autowiredArgument <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveDependency</span><span class="token punctuation">(</span>desc<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> autowiredBeanNames<span class="token punctuation">,</span> converter<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>autowiredArgument <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    pvs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>propertyName<span class="token punctuation">,</span> autowiredArgument<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>String autowiredBeanName <span class="token operator">:</span> autowiredBeanNames<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 记录bean之间的依赖关系</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerDependentBean</span><span class="token punctuation">(</span>autowiredBeanName<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Autowiring by type from bean name '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' via property '"</span> <span class="token operator">+</span> propertyName <span class="token operator">+</span> <span class="token string">"' to bean named '"</span> <span class="token operator">+</span> autowiredBeanName <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                autowiredBeanNames<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsatisfiedDependencyException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> propertyName<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>上述方法的核心位于 resolveDependency 方法中：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">resolveDependency</span><span class="token punctuation">(</span>        DependencyDescriptor descriptor<span class="token punctuation">,</span> String requestingBeanName<span class="token punctuation">,</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> autowiredBeanNames<span class="token punctuation">,</span> TypeConverter typeConverter<span class="token punctuation">)</span>        <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 获取并初始化参数名称探测器</span>    descriptor<span class="token punctuation">.</span><span class="token function">initParameterNameDiscovery</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getParameterNameDiscoverer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>javaUtilOptionalClass <span class="token operator">==</span> descriptor<span class="token punctuation">.</span><span class="token function">getDependencyType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 支持java8的java.util.Optional</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OptionalDependencyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createOptionalDependency</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">,</span> requestingBeanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ObjectFactory<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">==</span> descriptor<span class="token punctuation">.</span><span class="token function">getDependencyType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> ObjectProvider<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">==</span> descriptor<span class="token punctuation">.</span><span class="token function">getDependencyType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ObjectFactory类注入的特殊处理</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DependencyObjectProvider</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">,</span> requestingBeanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>javaxInjectProviderClass <span class="token operator">==</span> descriptor<span class="token punctuation">.</span><span class="token function">getDependencyType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 支持javax.inject.Provider</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Jsr330ProviderFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createDependencyProvider</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">,</span> requestingBeanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Object result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAutowireCandidateResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLazyResolutionProxyIfNecessary</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">,</span> requestingBeanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 通用处理逻辑</span>            result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doResolveDependency</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">,</span> requestingBeanName<span class="token punctuation">,</span> autowiredBeanNames<span class="token punctuation">,</span> typeConverter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">doResolveDependency</span><span class="token punctuation">(</span>        DependencyDescriptor descriptor<span class="token punctuation">,</span> String beanName<span class="token punctuation">,</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> autowiredBeanNames<span class="token punctuation">,</span> TypeConverter typeConverter<span class="token punctuation">)</span>        <span class="token keyword">throws</span> BeansException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     InjectionPoint previousInjectionPoint <span class="token operator">=</span> ConstructorResolver<span class="token punctuation">.</span><span class="token function">setCurrentInjectionPoint</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 快速处理</span>        Object shortcut <span class="token operator">=</span> descriptor<span class="token punctuation">.</span><span class="token function">resolveShortcut</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>shortcut <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> shortcut<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 如果是@Value注解，获取并返回对应的值</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> type <span class="token operator">=</span> descriptor<span class="token punctuation">.</span><span class="token function">getDependencyType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAutowireCandidateResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSuggestedValue</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                String strVal <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveEmbeddedValue</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                BeanDefinition bd <span class="token operator">=</span> <span class="token punctuation">(</span>beanName <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">containsBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getMergedBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果value是一个表达式，则解析表达式所指代的值</span>                value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">evaluateBeanDefinitionString</span><span class="token punctuation">(</span>strVal<span class="token punctuation">,</span> bd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 类型转换并返回</span>            TypeConverter converter <span class="token operator">=</span> <span class="token punctuation">(</span>typeConverter <span class="token operator">!=</span> null <span class="token operator">?</span> typeConverter <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getTypeConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">?</span>                    converter<span class="token punctuation">.</span><span class="token function">convertIfNecessary</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> type<span class="token punctuation">,</span> descriptor<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span>                    converter<span class="token punctuation">.</span><span class="token function">convertIfNecessary</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> type<span class="token punctuation">,</span> descriptor<span class="token punctuation">.</span><span class="token function">getMethodParameter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 尝试解析数组、集合类型</span>        Object multipleBeans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveMultipleBeans</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> autowiredBeanNames<span class="token punctuation">,</span> typeConverter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>multipleBeans <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> multipleBeans<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 获取匹配类型的bean实例</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> matchingBeans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">findAutowireCandidates</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> type<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>matchingBeans<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span><span class="token function">isRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">raiseNoMatchingBeanFound</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> descriptor<span class="token punctuation">.</span><span class="token function">getResolvableType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         String autowiredBeanName<span class="token punctuation">;</span>        Object instanceCandidate<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 存在多个匹配项</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>matchingBeans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 基于优先级配置来唯一确定注入的bean</span>            autowiredBeanName <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">determineAutowireCandidate</span><span class="token punctuation">(</span>matchingBeans<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>autowiredBeanName <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span><span class="token function">isRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">indicatesMultipleBeans</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> descriptor<span class="token punctuation">.</span><span class="token function">resolveNotUnique</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> matchingBeans<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> null<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            instanceCandidate <span class="token operator">=</span> matchingBeans<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>autowiredBeanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 存在唯一的匹配</span>            Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> entry <span class="token operator">=</span> matchingBeans<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            autowiredBeanName <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            instanceCandidate <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>autowiredBeanNames <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            autowiredBeanNames<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>autowiredBeanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果不是目标bean实例（比如工厂bean），需要进一步获取所指带的实例</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>instanceCandidate <span class="token keyword">instanceof</span> <span class="token class-name">Class</span> <span class="token operator">?</span>                descriptor<span class="token punctuation">.</span><span class="token function">resolveCandidate</span><span class="token punctuation">(</span>autowiredBeanName<span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">:</span> instanceCandidate<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        ConstructorResolver<span class="token punctuation">.</span><span class="token function">setCurrentInjectionPoint</span><span class="token punctuation">(</span>previousInjectionPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>整个解析的过程还是比较清晰的，首先会依次以确定的 <code>@Value</code> 注解和集合类型进行解析，如果不是这些类型，则获取匹配类型的 bean 实例集合，如果存在多个匹配，则尝试以优先级配置（比如 Primary 或 Priority）来确定首选的 bean 实例，如果仅存在唯一的匹配，则无需做推断逻辑，最后会检测当前解析得到的 bean 是不是目标 bean 实例，如果是工厂一类的 bean，则还要继续获取工厂所指代的 bean 实例。</p><ul><li><strong>applyPropertyValues</strong></li></ul><p>在这一步才真正将 bean 的所有属性全部注入到 bean 实例中，之前虽然已经创建了实例，但是属性仍然存在于 beanDefinition 实例中，applyPropertyValues 会将相应属性转换成 bean 中对应属性的真实类型注入到对应属性上：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">applyPropertyValues</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> BeanDefinition mbd<span class="token punctuation">,</span> BeanWrapper bw<span class="token punctuation">,</span> PropertyValues pvs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pvs <span class="token operator">==</span> null <span class="token operator">||</span> pvs<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     MutablePropertyValues mpvs <span class="token operator">=</span> null<span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>PropertyValue<span class="token operator">></span> original<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bw <span class="token keyword">instanceof</span> <span class="token class-name">BeanWrapperImpl</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>BeanWrapperImpl<span class="token punctuation">)</span> bw<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setSecurityContext</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAccessControlContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>pvs <span class="token keyword">instanceof</span> <span class="token class-name">MutablePropertyValues</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        mpvs <span class="token operator">=</span> <span class="token punctuation">(</span>MutablePropertyValues<span class="token punctuation">)</span> pvs<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mpvs<span class="token punctuation">.</span><span class="token function">isConverted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 之前已经被转换为对应的类型，那么可以直接设置到beanWrapper</span>            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                bw<span class="token punctuation">.</span><span class="token function">setPropertyValues</span><span class="token punctuation">(</span>mpvs<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Error setting property values"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 未被转换，记录到original进行转换</span>        original <span class="token operator">=</span> mpvs<span class="token punctuation">.</span><span class="token function">getPropertyValueList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 否则，使用原始的属性获取方法</span>        original <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>pvs<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     TypeConverter converter <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCustomTypeConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>converter <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        converter <span class="token operator">=</span> bw<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 获取对应的解析器</span>    BeanDefinitionValueResolver valueResolver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionValueResolver</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> converter<span class="token punctuation">)</span><span class="token punctuation">;</span>     List<span class="token operator">&lt;</span>PropertyValue<span class="token operator">></span> deepCopy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>PropertyValue<span class="token operator">></span><span class="token punctuation">(</span>original<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> resolveNecessary <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历属性，将属性转换成对应类的属性类型</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>PropertyValue pv <span class="token operator">:</span> original<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pv<span class="token punctuation">.</span><span class="token function">isConverted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            deepCopy<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 执行类型转换</span>            String propertyName <span class="token operator">=</span> pv<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object originalValue <span class="token operator">=</span> pv<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object resolvedValue <span class="token operator">=</span> valueResolver<span class="token punctuation">.</span><span class="token function">resolveValueIfNecessary</span><span class="token punctuation">(</span>pv<span class="token punctuation">,</span> originalValue<span class="token punctuation">)</span><span class="token punctuation">;</span>            Object convertedValue <span class="token operator">=</span> resolvedValue<span class="token punctuation">;</span>            <span class="token keyword">boolean</span> convertible <span class="token operator">=</span> bw<span class="token punctuation">.</span><span class="token function">isWritableProperty</span><span class="token punctuation">(</span>propertyName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>PropertyAccessorUtils<span class="token punctuation">.</span><span class="token function">isNestedOrIndexedProperty</span><span class="token punctuation">(</span>propertyName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>convertible<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 转换</span>                convertedValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">convertForProperty</span><span class="token punctuation">(</span>resolvedValue<span class="token punctuation">,</span> propertyName<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> converter<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>resolvedValue <span class="token operator">==</span> originalValue<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 转换后的value等于原始值</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>convertible<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    pv<span class="token punctuation">.</span><span class="token function">setConvertedValue</span><span class="token punctuation">(</span>convertedValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                deepCopy<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>convertible <span class="token operator">&amp;&amp;</span> originalValue <span class="token keyword">instanceof</span> <span class="token class-name">TypedStringValue</span> <span class="token operator">&amp;&amp;</span>                    <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TypedStringValue<span class="token punctuation">)</span> originalValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isDynamic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token operator">!</span><span class="token punctuation">(</span>convertedValue <span class="token keyword">instanceof</span> <span class="token class-name">Collection</span> <span class="token operator">||</span> ObjectUtils<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>convertedValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 转换后的类型是集合或数组</span>                pv<span class="token punctuation">.</span><span class="token function">setConvertedValue</span><span class="token punctuation">(</span>convertedValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                deepCopy<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 未解析完全，标记需要解析</span>                resolveNecessary <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                deepCopy<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PropertyValue</span><span class="token punctuation">(</span>pv<span class="token punctuation">,</span> convertedValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mpvs <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>resolveNecessary<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        mpvs<span class="token punctuation">.</span><span class="token function">setConverted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 标记为已全部转换</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 深拷贝</span>        bw<span class="token punctuation">.</span><span class="token function">setPropertyValues</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MutablePropertyValues</span><span class="token punctuation">(</span>deepCopy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Error setting property values"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>完成了属性注入，接下来容器会执行我们所熟知的 init-method 方法，不过 Spring 并不是单纯的调用一下对应的初始化方法，在整一个初始化方法 initializeBean 中，容器主要做了 4 件事情：</p><blockquote><ol><li>激活 bean 实现的 Aware 类：BeanNameAware, BeanClassLoaderAware, BeanFactoryAware</li><li>应用 BeanPostProcessor 的 postProcessBeforeInitialization</li><li>激活用户自定义的 init-method 方法，以及常用的 afterPropertiesSet 方法</li><li>应用 BeanPostProcessor 的 postProcessAfterInitialization</li></ol></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">initializeBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> String beanName<span class="token punctuation">,</span> <span class="token keyword">final</span> Object bean<span class="token punctuation">,</span> RootBeanDefinition mbd<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. 激活bean实现的Aware类：BeanNameAware, BeanClassLoaderAware, BeanFactoryAware</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Object <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">invokeAwareMethods</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token function">getAccessControlContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">invokeAwareMethods</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 2. 应用 BeanPostProcessor 的 postProcessBeforeInitialization</span>    Object wrappedBean <span class="token operator">=</span> bean<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isSynthetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        wrappedBean <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">applyBeanPostProcessorsBeforeInitialization</span><span class="token punctuation">(</span>wrappedBean<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 3. 激活用户自定义的 init-method 方法，以及常用的 afterPropertiesSet 方法</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">invokeInitMethods</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> wrappedBean<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span><span class="token punctuation">(</span>mbd <span class="token operator">!=</span> null <span class="token operator">?</span> mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token string">"Invocation of init method failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 4. 应用 BeanPostProcessor 的 postProcessAfterInitialization</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isSynthetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        wrappedBean <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">applyBeanPostProcessorsAfterInitialization</span><span class="token punctuation">(</span>wrappedBean<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> wrappedBean<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>6. 基于依存关系验证是否存在循环依赖</strong></p><p>存在循环依赖会导致容器中存在残缺的 bean，这对于使用 Spring 框架的系统来说是一个极大的隐患，所以在这里最后再检测一次，确保所有需要实例化的 bean 都完成了对象的创建和初始化过程，否则系统不应该正常启动。</p><p><strong>7. 注册 DisposableBean</strong></p><p>Spring 允许单例或自定义作用域的 bean 实现 DisposableBean 接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DisposableBean</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**     * Invoked by a BeanFactory on destruction of a singleton.     *     * @throws Exception in case of shutdown errors.     *                   Exceptions will get logged but not rethrown to allow     *                   other beans to release their resources too.     */</span>    <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>从而在销毁对应的 bean 时能够回调实现的 destroy 方法，从而为销毁前的处理工作提供了入口，容器会利用一个 Map 集合来记录所有实现了 DisposableBean 接口的 bean：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">registerDisposableBeanIfNecessary</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> Object bean<span class="token punctuation">,</span> RootBeanDefinition mbd<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    AccessControlContext acc <span class="token operator">=</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">?</span> <span class="token function">getAccessControlContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">requiresDestruction</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 非原型，且需要执行销毁前的处理工作</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 单例，注册bean到disposableBeans集合</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerDisposableBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DisposableBeanAdapter</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 自定义的scope</span>            Scope scope <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scopes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">getScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>scope <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"No Scope registered for scope name '"</span> <span class="token operator">+</span> mbd<span class="token punctuation">.</span><span class="token function">getScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            scope<span class="token punctuation">.</span><span class="token function">registerDestructionCallback</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DisposableBeanAdapter</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> <span class="token function">getBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>当我们在调用 destroySingleton 销毁 bean 的时候，容器就会尝试从 DisposableBean 集合中获取当前待销毁 bean 对应的 DisposableBean 实例，如果存在则调用 destroy 方法，执行其中的自定义逻辑。</p><h4 id="4-2-创建原型对象"><a href="#4-2-创建原型对象" class="headerlink" title="4.2 创建原型对象"></a><strong>4.2 创建原型对象</strong></h4><p>创建和初始化过程调用的 createBean 方法同单例对象，不再重复撰述。</p><h4 id="4-3-创建其它作用域对象"><a href="#4-3-创建其它作用域对象" class="headerlink" title="4.3 创建其它作用域对象"></a><strong>4.3 创建其它作用域对象</strong></h4><p>创建和初始化过程调用的 createBean 方法同单例对象，不再重复撰述。</p><h3 id="5-类型检查和转换"><a href="#5-类型检查和转换" class="headerlink" title="5. 类型检查和转换"></a><strong>5. 类型检查和转换</strong></h3><p>我们在 getBean 的时候可以指定我们期望的返回类型 <code>getBean(String name, Class&lt;T&gt; requiredType)</code>，如果我们指定了那么容器在创建和初始化 bean 的最后一步需要执行类型校验，并尝试将不是期望类型的 bean 实例转换成期望类型：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 检查需要的类型是否符合bean的实际类型，对应getBean时指定的requireType</span><span class="token keyword">if</span> <span class="token punctuation">(</span>requiredType <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> bean <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>requiredType<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行类型转换，转换成期望的类型</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getTypeConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">convertIfNecessary</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TypeMismatchException</span> ex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Failed to convert bean '"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"' to required type '"</span> <span class="token operator">+</span> ClassUtils<span class="token punctuation">.</span><span class="token function">getQualifiedName</span><span class="token punctuation">(</span>requiredType<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanNotOfRequiredTypeException</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> requiredType<span class="token punctuation">,</span> bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>这个转换的过程还是比较复杂的，鉴于本篇已经写的够长了，就不再展开啦。</p><p>至此我们已经完成了探究 getBean 的完整过程，接下去就可以使用 bean 实例了，回顾过去的几篇文章，我们探究了容器加载、解析配置文件得到 beanDefinition 实例，并基于该实例来创建、初始化得到目标 bean 实例的过程，虽然 Spring 暴露给我的使用方式只有短短几行，但是背后却隐藏着复杂的逻辑。实际中我们一般不会直接使用 BeanFactory 来操作容器，我们使用更多的是 ApplicationContext，下一篇中我们将继续探究基于 ApplicationContext 的 bean 的加载和初始化过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bean生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解MVCC</title>
      <link href="2021/03/16/%E8%AF%A6%E8%A7%A3MVCC/"/>
      <url>2021/03/16/%E8%AF%A6%E8%A7%A3MVCC/</url>
      
        <content type="html"><![CDATA[<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>原文链接：<a href="https://blog.csdn.net/weixin_30342639/article/details/107552255">https://blog.csdn.net/weixin_30342639/article/details/107552255</a></p><p>Multi-Version Concurrency Control 多版本并发控制</p><p>InnoDB事务分为四个隔离级别，默认的隔离级别为REPETABLE READ，需要两个不同的事务相互之间不能影响，而且还能支持并发，这点悲观锁是达不到的，所以REPETABLE READ采用的就是乐观锁，而乐观锁的实现采用的就是MVCC。</p><p>在MySQL中，MVCC只在读已提交和可重复读两个事务级别下有效。底层是通过undo日志中的版本链和ReadView一致性视图来实现的。MVCC就是在多个事务同时存在时，select语句找寻到具体是版本链上的哪个版本，然后在找到的版本上返回其中所记录的数据的过程。</p><p><strong>InnoDB存储引擎MVCC的实现策略</strong></p><p>在每一行数据中额外保存两个隐藏的列：<strong>两个隐藏字段为：trx_id 事务ID字段和roll pointer回滚指针字段，记录上一个版本的地址</strong></p><h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p>所有版本的数据都只会存一份，然后通过回滚指针连接起来，之后就是通过一定的规则找到具体是哪个版本上的数据就行了。假设现在有一张account表，其中有id和name两个字段，那么版本链的示意图如下：</p><p><img src="https://img-blog.csdnimg.cn/20200725023723438.png" alt="img"></p><p>而具体版本链的比对规则如下，首先从版本链中拿出最上面第一个版本的事务ID开始逐个往下进行比对：</p><p><img src="https://img-blog.csdnimg.cn/20200725024356278.png" alt="img"></p><p>如果落在绿色区间，这个版本比min_id还小，说明这个版本在select之前就提交了，这个数据是可见的。</p><p>如果落在红色区间，表示这个版本是由将来启动的事务来生成的，当前还未开始，是不可见的。</p><p>如果落在黄色区间，分两种情况：如果这个版本的事务ID在ReadView的未提交事务数组中，表示这个版本是由还未提交的事务生成的，那么就是不可见的；如果这个版本的事务ID不再ReadView的未提交事务数组中，表示这个版本是已经提交了的事务生成的，是可见的。</p><p>如果在上述判断中发现当前版本不可见，那就从版本链中通过回滚指针拿取下一个版本来进行上述判断。</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>ReadView一致性视图主要是由两部分组成：所有未提交事务的ID数组和已经创建的最大事务ID组成。</p><p>比如[100,200],300,事务100和200是当前未提交的事务，而事务300是当前创建的最大事务了（已经提交了）。当执行SELECT语句的时候会创建ReadView，但是在读取已提交和可重复读两个事务级别下，生成ReadView的策略是不一样的：<strong>读取已提交级别是每执行一次SELECT语句就会重新生成一份ReadView，而可重复读级别是只会在第一次SELECT语句执行的时候会生成一份，后续的SELECT语句会沿用之前生成的ReadView</strong>（即使后面有更新语句的话，也会继续沿用）。</p><h3 id="演示过程"><a href="#演示过程" class="headerlink" title="演示过程"></a>演示过程</h3><table><thead><tr><th></th><th><strong>Transaction 100</strong></th><th><strong>Transaction 200</strong></th><th><strong>Transaction 300</strong></th><th>无事务ID</th><th>无事务ID</th></tr></thead><tbody><tr><td>1</td><td>begin</td><td>begin</td><td>begin</td><td>begin</td><td>begin</td></tr><tr><td>2</td><td>UPDATE test SET a=’1’ WHERE id = 1;</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td></td><td>UPDATE test SET a=’2’ WHERE id = 2;</td><td></td><td></td><td></td></tr><tr><td>4</td><td></td><td></td><td>UPDATE account SET name = ‘monkey301’ WHERE id = 1;</td><td></td><td></td></tr><tr><td>5</td><td></td><td></td><td>commit</td><td></td><td></td></tr><tr><td>6</td><td></td><td></td><td></td><td>SELECT name FROM account WHERE id = 1;</td><td></td></tr><tr><td>7</td><td>UPDATE account SET name = ‘monkey101’ WHERE id = 1;</td><td></td><td></td><td></td><td></td></tr><tr><td>8</td><td>UPDATE account SET name = ‘monkey102’ WHERE id = 1;</td><td></td><td></td><td></td><td></td></tr><tr><td>9</td><td></td><td></td><td>SELECT name FROM account WHERE id = 1;</td><td></td><td></td></tr><tr><td>10</td><td>commit</td><td>UPDATE account SET name = ‘monkey201’ WHERE id = 1;</td><td></td><td></td><td></td></tr><tr><td>11</td><td></td><td>UPDATE account SET name = ‘monkey202’ WHERE id = 1;</td><td></td><td></td><td></td></tr><tr><td>12</td><td></td><td></td><td></td><td>SELECT name FROM account WHERE id = 1;</td><td>SELECT name FROM account WHERE id = 1;</td></tr><tr><td>13</td><td></td><td>commit</td><td></td><td></td><td></td></tr></tbody></table><p>下面通过一个示例来具体演示MVCC的执行过程（假设是在可重复读事务级别下），当前account表中已经有了一条初始数据（id=1,name=monkey）：</p><p>首先来看一下初始状态时的版本链和ReadView（ReadView此时还未生成）：</p><p><img src="https://img-blog.csdnimg.cn/20200725040907721.png" alt="img"></p><p>其中事务1在account表中创建了一条初始数据。</p><p>之后在第1时刻点，五个事务分别开启了事务（如上所说，这个时候还没有生成事务ID）。</p><p>在第2时刻点，第一个事务执行了一条UPDATE语句，生成了事务ID为100。</p><p>在第3时刻点，第二个事务执行了一条UPDATE语句，生成了事务ID为200。</p><p>在第4时刻点，第三个事务执行了一条UPDATE语句，将account表中id为1的name改为了monkey301。同时生成了事务ID为300。</p><p>在第5时刻点，事务300也就是上面的事务执行了commit操作。</p><p>在第6时刻点，第四个事务执行了一条SELECT语句，想要查询一下当前id为1的数据（如上所说，该事务没有生成事务ID）。此时的版本链和ReadView如下：<br><img src="https://img-blog.csdnimg.cn/20200725041117521.png" alt="img"></p><p>因为在第5时刻点，事务300已经commit了，所以ReadView的未提交事务数组中不包含它。此时根据上面所说的比对规则，拿版本链中的第一个版本的事务ID为300进行比对，首先当前这条SELECT语句没有在事务300中进行查询，然后发现是落在黄色区间，而且事务300也没有在ReadView的未提交事务数组中，所以是可见的。即此时在第6时刻点，第四个事务所查找到的结果是monkey301。</p><p>在第7时刻点，事务100执行了一条UPDATE语句，将account表中id为1的name改为了monkey101。</p><p>在第8时刻点，事务100又执行了一条UPDATE语句，将account表中id为1的name改为了monkey102。</p><p>在第9时刻点，第四个事务执行了一条SELECT语句，想要查询一下当前id为1的数据。此时的版本链和ReadView如下：<br><img src="https://img-blog.csdnimg.cn/20200725042802345.png" alt="img"></p><p>注意，因为当前是在可重复读的事务级别下，所以此时的ReadView沿用了在第6时刻点生成的ReadView（如果是在读取已提交的事务级别下，此时就会重新生成一份ReadView了）。然后根据上面所说的比对规则，拿版本链中的第一个版本的事务ID为100进行比对，首先当前这条SELECT语句没有在事务100中进行查询，然后发现是落在黄色区间，而且事务100是在ReadView的未提交事务数组中，所以是不可见的。此时通过回滚指针拿取下一个版本，发现事务ID仍然为100，经过分析后还是不可见的。此时又拿取下一个版本：事务ID为300进行比对，首先当前这条SELECT语句没有在事务300中进行查询，然后发现是落在黄色区间，但是事务300没有在ReadView的未提交事务数组中，所以是可见的。即此时在第9时刻点，第四个事务所查找到的结果仍然是monkey301（这也就是可重复读的含义）。</p><p>在第10时刻点，事务100commit提交事务了。同时事务200执行了一条UPDATE语句，将account表中id为1的name改为了monkey201。</p><p>在第11时刻点，事务200又执行了一条UPDATE语句，将account表中id为1的name改为了monkey202。</p><p>在第12时刻点，第四个事务执行了一条SELECT语句，想要查询一下当前id为1的数据。此时的版本链和ReadView如下：<br><img src="https://img-blog.csdnimg.cn/202007250510202.png" alt="img"></p><p>跟第9时刻点一样，在可重复读的事务级别下，ReadView沿用了在第6时刻点生成的ReadView。然后根据上面所说的比对规则，拿版本链中的第一个版本的事务ID为200进行比对，首先当前这条SELECT语句没有在事务200中进行查询，然后发现是落在黄色区间，而且事务200是在ReadView的未提交事务数组中，所以是不可见的。此时通过回滚指针拿取下一个版本，发现事务ID仍然为200，经过分析后还是不可见的。此时又拿取下一个版本：事务ID为100进行比对，首先当前这条SELECT语句没有在事务100中进行查询，然后发现是落在黄色区间内，同时在ReadView的未提交数组中，所以依然是不可见的。此时又拿取下一个版本，发现事务ID仍然为100，经过分析后还是不可见的。此时再拿取下一个版本：事务ID为300进行比对，首先当前这条SELECT语句没有在事务300中进行查询，然后发现是落在黄色区间，但是事务300没有在ReadView的未提交事务数组中，所以是可见的。即此时在第12时刻点，第四个事务所查找到的结果仍然是monkey301。</p><p>同时在第12时刻点，第五个事务执行了一条SELECT语句，想要查询一下当前id为1的数据。此时的版本链和ReadView如下：<br><img src="https://img-blog.csdnimg.cn/20200725052100541.png" alt="img"></p><p>注意，此时第五个事务因为是该事务内的第一条SELECT语句，所以会重新生成在当前情况下的ReadView，即上图中所示的内容。可以看到，和第四个事务生成的ReadView并不一样，因为在之前的第10时刻点，事务100已经提交事务了。然后根据上面所说的比对规则，拿版本链中的第一个版本的事务ID为200进行比对，首先当前这条SELECT语句没有在事务200中进行查询，然后发现是落在黄色区间，而且事务200是在ReadView的未提交事务数组中，所以是不可见的。此时通过回滚指针拿取下一个版本，发现事务ID仍然为200，经过分析后还是不可见的。此时又拿取下一个版本：事务ID为100进行比对，发现是在绿色区间，所以是可见的。即此时在第12时刻点，第五个事务所查找到的结果是monkey102（可以看到，即使是同一条SELECT语句，在不同的事务中，查询出来的结果也可能是不同的，究其原因就是因为ReadView的不同）。</p><p>在第13时刻点，事务200执行了commit操作，整段分析过程结束。</p><p>以上演示的就是MVCC的具体执行过程，在多个事务下，版本链和ReadView是如何配合进行查找的。上面还遗漏了一种情况没有进行说明，就是如果是DELETE语句的话，也会在版本链上将最新的数据插入一份，然后将事务ID赋值为当前进行删除操作的事务ID。但是同时会在该条记录的信息头（record header）里面的deleted_flag标记位置为true，以此来表示当前记录已经被删除。所以如果经过版本比对后发现找到的版本上的deleted_flag标记位为true的话，那么也不会返回，而是继续寻找下一个。</p><p>另外，如果当前事务执行rollback回滚的话，会把版本链中属于该事务的所有版本都删除掉。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MVCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制</title>
      <link href="2021/03/16/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>2021/03/16/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在Class文件中描述的各类信息，最终都需要加载到虚拟机只后才能被运行和使用。</p><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称为虚拟机的类加载机制。</p><p>与其他在编译时需要连接的语言不同，在Java中类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为Java应用提供了极高的扩展性和灵活性，Java可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类，用户可以通过Java预置的或自定义类加载器，让某个本地应用程序在运行时从网络或其他地方加载一个二进制流作为其程序代码的一部分。</p><hr><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>一个类型从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期将会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、解析和初始化三个部分统称为链接。</p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言地运行时绑定特性（动态绑定）。</p><p>关于何时需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有强制约束，这点可以交给虚拟机具体实现自由把握。但对于初始化阶段，《Java虚拟机规范》严格规定了有且只有6种情况必须立即对类进行初始化：</p><ul><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：<ul><li>使用new关键字实例化对象。</li><li>读取或设置一个类型的静态字段（被final修饰，在编译器把结果放入常量池的静态字段除外）的时候。</li><li>调用一个类型的静态方法。</li></ul></li><li>使用java.lang.reflect包的方法对类型进行反射调用时，如果类型没有进行过初始化则需要先触发初始化。</li><li>当初始化类时，如果其父类没有初始化则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的类），虚拟机会先初始化该类。</li><li>当使用JDK7新加入的动态语言支持时，如果MethodHandle实例的解析结果为指定的4种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li><li>当一个接口定义了默认方法时，如果该接口的实现类发生了初始化，那接口要在其之前初始化。</li></ul><p>除了这6种情况外，其余所有引用类型的方式都不会触发初始化，称为被动引用。</p><p>被动引用的实例：</p><ul><li>子类使用父类的静态字段时，只有直接定义这个字段的父类会被初始化。</li><li>通过数组定义来使用类。</li><li>常量在编译期会存入调用类的常量池，因此不会初始化定义常量的类。</li></ul><p>接口的加载过程和类加载过程真正有所区别的是6种初始化场景种的第3种，当初始化类时，如果其父类没有初始化则需要先触发其父类的初始化，但在一个接口初始化时并不要求其父接口全部完成了初始化，只有在真正使用到父接口时（如引用接口中定义的常量）才会初始化。</p><hr><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><ul><li><p><strong>加载</strong></p><p>加载是类加载的第一个阶段，在加载阶段，虚拟机需要完成三件事：</p><ul><li>通过一个类的全限定类名来获取定义此类的二进制字节流。由于《Java虚拟机规范》没有具体要求，所以这一步的实现多种多样，例如从ZIP压缩包中读取、从网络中获取、运算时动态代理生成、从数据库中读取、从加密文件中获取等。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据区结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>对于非数组类型，加载阶段既可以使用虚拟机内置的引导类加载器完成也可以由用户自定义的类加载器完成，可以通过定义自己的类加载器去控制字节流的获取方式（重写类加载器的findClass或loadClass方法）。</p><p>数组类本身不通过类加载器创建，它是由虚拟机直接在内存中动态构造出来的。但数组类与类加载器仍然密切相关，因为数组类的元素类型（数组去掉所有维度的类型）最终还是要依靠类加载器来完成加载：</p><ul><li>如果是数组的组件类型（数组去掉一个维度的类型）是引用类型就递归采用加载过程去加载这个组件类型，数组将被标识在加载该组件类型的类加载器的命名空间上。</li><li>如果不是引用类型（例如int[]数组的组件类型为int），虚拟机会把数组标记为与引导类加载器相关联。</li><li>数组类的可访问性与它的组件类型可访问性一致，如果组件类型不是引用类型，数组类的可访问性默认public。</li></ul><p>加载阶段结束后，虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区中了，方法区中的数据存储格式完全由虚拟机自定义实现。类型数据安置在方法区之后，会在Java堆中实例化一个java.lang.Class对象，这个对象将作为程序员访问方法区中类型数据的外部接口。</p><p>加载阶段与连接阶段的部分动作是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。</p></li><li><p><strong>验证</strong></p><p>验证是连接阶段的第一步，这一阶段的目的就是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>Java语言本身是安全的，纯粹的Java代码无法做到诸如访问数组边界之外的数据、将一个对象转型为它并未实现的类型等，但如果虚拟机不检查输入的字节流，对其完全信任的话，很可能因为载入了有错误或者有恶意企图的字节码流而导致整个系统受攻击甚至崩溃，所以验证字节码是Java虚拟机保护自己的一项必要措施。</p><p>验证阶段主要包含了四个阶段：</p><ul><li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范并且能被当前版本的虚拟机处理。</li><li><strong>元数据验证：</strong>对字节码描述的信息进行语义分析，保证其描述信息符合《Java虚拟机规范》的要求。</li><li><strong>字节码验证：</strong>验证中最复杂的阶段，主要目的是通过数据流分析和控制流分析确定程序语义是合法的。</li><li><strong>符号引用验证：</strong>发生在虚拟机将符合引用转为直接引用时（在连接的第三阶段解析中发生），符号引用验证可以看作是对类自身以外的各类信息进行匹配性校验，通俗地说就是该类是否缺少或被禁止访问它依赖的某些外部类、方法、字段等资源。</li></ul><p>验证阶段对于虚拟机的类加载机制来说是一个非常重要但非必需的阶段，因为验证只有通过与否的区别，只要通过了验证其后就对程序运行期没有任何影响了。如果程序运行的全部代码都已被反复使用和验证过，在生产环境的实施阶段就可以考虑用<code>-Xverify:none</code>参数来关闭大部分类验证措施以缩短虚拟机类加载的时间。</p></li><li><p><strong>准备</strong></p><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置为类变量初始值的阶段，在JDK7之前类变量在方法区中分配，JDK8之后类变量会随着Class对象一起存放在Java堆中。</p><p>该阶段进行的内存分配仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中，其次这里说的初始值通常情况下是数据类型的零值，如果是数值类型则是0，如果是布尔类型则是false，如果是char类型则是<code>\u0000</code>，如果是引用类型则是null。</p><p>通常情况是指变量不存在ConstantValue属性的情况，如果变量被final修饰，编译时Javac会为变量生成ConstantValue属性，那么在准备阶段虚拟机就会将该变量的值设为程序员指定的值。</p></li><li><p><strong>解析</strong></p><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ul><li><strong>符号引用：</strong>符合引用以一组符号来描述所引用的目标，符合可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机的内存布局无关，引用目标并不一定是已经加载到虚拟机内存中的内容。各种虚拟机实现的内存布局可以不同，但是接受的符号引用必须都是一致的。</li><li><strong>直接引用：</strong>直接引用是可以直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。直接引用和虚拟机的内存布局直接相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不同，如果有了直接引用，那引用目标必须已经在虚拟机的内存中存在。</li></ul><p>解析部分主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符合引用进行。</p></li><li><p><strong>初始化</strong></p><p>类的初始化是类加载过程的最后一个步骤，直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p><p>准备阶段时变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码指定的主观计划去初始化类变量和其他资源。初始化阶段就是指向类构造器&lt;client&gt;方法的过程，该方法是Javac编译器的自动生成物。</p></li></ul><hr><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的”通过一个类的全限定名来获取描述该类的二进制字节流“这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类，实现这个动作的代码称为类加载器。</p><ul><li><p><strong>比较两个类是否相等</strong></p><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p><p>只有在这两个类是由同一个类加载器加载的前提下才有意义，否则即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><p>相等的含义包括了代表类的Class对象的equals方法、isAssignableFrom方法、isInstance方法的返回结果，也包括了使用instance of关键字做对象所属关系判定等各种情况。</p></li><li><p><strong>双亲委派模型</strong></p><p>从Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器，这个类加载器使用C++语言实现（限于HotSpot虚拟机），是虚拟机自身的一部分；另一种是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全部继承自抽象类<code>java.lang.ClassLoader</code>。</p><p>自JDK1.2起Java一直保持着三层类加载器、双亲委派的类加载结构。</p><ul><li><p><strong>类加载器</strong></p><ul><li><strong>启动类加载器</strong>：负载加载存放在<code>JAVA_HOME/lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定路径中存放的而且能够被虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，如果用户需要把加载请求委派给启动类加载器，直接使用null代替即可。</li><li><strong>扩展类加载器</strong>：负载加载<code>JAVA_HOME/lib/ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库。这种扩展机制在JDK9之后被模块化带来的天然扩展能力所取代，由于扩展类加载器是由Java代码编写的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。</li><li><strong>应用程序类加载器</strong>：也称系统类加载器，它负载加载用户类路径上的所有类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过类加载器，一般情况下该类加载器就是程序中默认的类加载器。</li></ul></li><li><p><strong>双亲委派模型</strong></p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承关系来实现的，而通常使用组合关系来复用父加载器的代码。</p><p>如果一个类加载器收到了类加载请求，它不会自己去尝试加载这个类，而首先将该请求委派给自己的父加载器完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成该请求时，子加载器才会尝试自己去完成加载。</p><p>双亲委派机制的好处是Java中的类跟随它的类加载器一起具备了一种带有优先级的层次关系，可以保证某个类在程序的各个类加载器环境中都是同一个类，对于保证Java程序的稳定运行极为重要。</p></li><li><p><strong>破坏双亲委派模型</strong></p><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者的类加载器实现方式。大部分类加载器都遵循该模型，但也有例外情况，直到Java模块化出现为止，双亲委派模型经历过3次较大规模”被破坏“的情况。</p><ul><li><p>第一次被破坏发生在双亲委派模型出现之前，由于该模型在JDK1.2之后才被引入，而类加载器的概念和抽象类ClassLoader在Java的第一个版本就已存在，因此在模型引入时不得不做一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类重写的可能性，只能增加一个新的protected方法findClass()，并引导用户编写类加载逻辑时尽可能去重写这个findClass()方法。按照loadClass()方法的逻辑，如果父类加载失败会调用自己的findClass()方法，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出的类加载器是符合双亲委派规则的。</p></li><li><p>第二次被破坏是由模型自身缺陷造成的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题，越基础的类由越上层的类加载器加载，但假如基础类型要调用回用户的代码就会存在问题（例如JNDI服务，它的代码由启动类加载器完成加载，但它存在的目的就是对资源进行查找和集中管理，需要调用其他厂商实现的并部署在应用程序的ClassPath下的JNDI服务提供者接口中的代码，而启动类加载器是不可能认识、加载这些代码的）。</p><p>为解决该问题，Java引入了线程上下文类加载器。这个类加载器可以通过Thread类的<code>setContextClassLoader</code>方法进行设置，如果创建线程时还未设置，将从父线程继承一个，如果再应用的全局范围都没设置过的话，将默认是应用程序类加载器。JNDI使用线程上下文类加载器去加载所需的SPI服务代码，这是一种父加载器委托子加载器完成加载的行为，违背了双亲委派模型的一般性原则。Java中涉及SPI的加载基本都采用该方式，例如JNDI、JDBC、JCE、JXAB等。在JDK6时，提供了ServiceLoader类，辅以责任链模式，给SPI的加载提供了相对合理的解决方案。</p></li><li><p>第三次被破坏是由于用户对程序动态性的追求导致的，动态性是指代码热替换、模块热部署等。</p></li></ul></li></ul></li><li><p><strong>Java模块化系统</strong></p><p>JDK9引入了模块化系统，为了实现模块化的关键目标即可配置的封装隔离机制，Java虚拟机对类加载架构也做出了相应的变动调整。模块化下的类加载器变动主要包括：</p><ul><li>扩展类加载器被平台类加载器取代，因为整个JDK都基于模块化构建，Java类库已经天然满足可扩展需求，因此<code>JAVA_HOME/lib/ext</code>目录也无需保留，加载这部分的类加载器也自然不需要了。类似地，在新版JDK中也取消了<code>JAVA_HOME/jre</code>目录，因为随时可以组合构建出程序运行所需的JRE来。</li><li>平台类加载器和应用程序类加载器都不在派生自<code>URLClassLoader</code>，如果程序直接依赖了这种继承关系或者依赖了<code>URLClassLoader</code>类的特定方法，那代码很可能在JDK9及更高版本崩溃。限制启动类加载器、平台类加载器、应用程序类加载器全部继承于<code>BuiltinClassLoader</code>，该类实现了新的模块化架构下来如何从模块加载的逻辑，以及模块中资源可访问性的处理。</li><li>JDK9中虽然仍然维持着三层类加载器和双亲委派架构，但类加载的委派关系发生了变化。在平台类加载器和应用程序类加载器收到类加载请求时，要先判断该类是否能够归属到某个系统模块中，如果可以就优先委派给负责那个模块的加载器完成。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 类加载机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收</title>
      <link href="2021/03/16/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>2021/03/16/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于Java内存运行时区域的各部分，程序计数器、虚拟机栈和本地方法栈3个区域的生命周期和线程相同，栈中的栈帧随着方法的进入和退出而有规律地执行出栈和入栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（运行期会由即时编译器优化但大体上可认为是编译器已知的），因此这几个区域地内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收问题，当方法或线程结束时，内存自然就跟着回收了。</p><p>而Java堆和方法区这两个区域则有显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建对象的数量，这部分内存的分配和回收是动态的。垃圾收集器关注的正是这部分内存的管理问题。</p><hr><h3 id="判断对象是否是垃圾"><a href="#判断对象是否是垃圾" class="headerlink" title="判断对象是否是垃圾"></a>判断对象是否是垃圾</h3><p>在堆中存放着所有对象实例，垃圾收集器在对堆进行回收前，首先要判断对象是否还存活着。</p><ul><li><p><strong>引用计数算法</strong></p><p>在对象中添加一个引用计数器，如果有一个地方引用它计数器就加1，引用失效时计数器就减1，如果计数器为0则该对象就是不再被使用的。</p><p>该算法原理简单，效率也高，但是在Java中很少使用，因为它存在对象之间互相循环引用的问题，导致计数器无法清零。</p></li><li><p><strong>可达性分析算法</strong></p><p>当前主流语言的内存管理子系统都是使用可达性分析算法来判断对象是否存活的。这个算法的基本思路就是通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链，如果某个对象到GC Roots之间没有任何引用链相连，则此对象是不可能再被使用的。</p><p>可作为GC Roots的对象包括以下几种：</p><ul><li>本地代码缓存等。</li></ul></li><li><p><strong>再谈引用</strong></p><p>无论通过引用计数算法还是可达性分析算法判断对象是否存活，都和引用离不开关系。在JDK1.2之前，Java对引用的定义是：如果reference类型数据存储的数值代表另外一块内存的起始地址，那么就称该reference数据是代表某块内存、某个对象的引用。在JDK1.2之后Java对引用的概念进行了扩充，按引用强度分为：</p><ul><li><strong>强引用</strong>：最传统的引用定义，指程序代码中普遍存在的引用赋值。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li><li><strong>软引用</strong>：描述一些还有用但非必需的对象。只被软引用关联的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存才会抛出OOM异常。</li><li><strong>弱引用</strong>：描述非必需对象，但引用强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器开始工作时无论当前内存是否足够，都会回收只被弱引用关联的对象。</li><li><strong>虚引用</strong>：也称幽灵引用或幻影引用，它是最弱的引用关系。一个对象是否有虚引用存在，完全不会对其生存时间造成应用，也无法通过虚引用来取得一个对象实例。该引用的唯一目的就是为了能在这个对象被垃圾收集器回收时收到一个系统通知。</li></ul></li><li><p><strong>finalize方法</strong></p><p>要宣告一个对象死亡至少要经过两次标记过程，如果对象在进行可达性分析后发现没有与GC Roots连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法。假如对象没有重写finalize方法或者该方法已经被虚拟机调用过，那么虚拟机将这两种情况视为没有必要执行。</p><p>如果这个对象被判断为有必要执行finalize方法，就会被放置在一个叫做F-Queue的队列中，并由一条虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize方法。虚拟机会触发该方法但不保证它会运行结束，这是为了防止某个对象的finalize方法执行缓慢或者发生死循环而影响整个内存回收子系统。只要对象在finalize方法中重新与引用链上的任何一个对象建立关联关系就会在第二次标记时被移出即将回收集合，否则就会被真正回收。</p><p>注意：finalize方法由于运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法，因此它并不适合释放资源，释放资源完全可以使用try-finally代码块。</p></li><li><p><strong>回收方法区</strong></p><p>方法区垃圾收集的”性价比“通常较低，主要回收两部分内容：废弃的常量和不再使用的类型。回收废弃常量与回收Java堆中的对象非常类似，判断一个常量是否废弃相对简单，而判断一个类型是否属于不再使用的类需要同时满足以下三个条件：</p><ul><li>该类的所有实例都已经被回收，堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收。</li><li>该类对象的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机被允许对满足这三个条件的无用类进行回收，没有引用了不一定会必然回收，是否回收通过<code>-Xnoclassge</code>参数进行控制。还可以通过<code>-verbose:class</code>和<code>-XX:+TraceClassLoading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息。</p><p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，保证不会对方法区造成过大内存压力。</p></li></ul><hr><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul><li><p><strong>分代收集理论</strong></p><p>当前商业虚拟机的垃圾收集器大多数都遵循了分代收集理论进行设计，分代收集建立在两个假说上：</p><ul><li>弱分代假说：绝大多数对象都是朝生夕灭的。</li><li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</li></ul><p>这两个分代假说共同奠定了多款垃圾收集器的一致设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据年龄分配到不同的区域之中。</p><p>把分代收集理论放到商用虚拟机中，设计者一般至少会把Java堆划分为新生代和老年代两个区域。在新生代每次垃圾回收都有大批对象灭亡，而每次回收后存活的少量对象将会逐步晋升到老年代中。</p><p>为了解决跨代引用问题，引入了第三条经验法则：</p><ul><li>跨代引用假说：跨代引用相对于同代引用仅占极少数。</li></ul><p>依据这条假说，我们不该再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（记忆集），这个结构把老年代划分为若干小块，标记出老年代的哪一块内存会存在跨代引用。此后发生MinorGC时，只有包含了跨代引用的小块内存中的对象才会被加入到GC Roots进行扫描。</p><p>垃圾收集名词：</p><ul><li>MinorGC：目标只是新生代的垃圾收集。</li><li>MajorGC：目标只是老年代的垃圾收集，目前只有CMS会单独收集老年代。</li><li>MixedGC：混合收集，目前只有G1会有这种行为。</li><li>FullGC：收集整个Java堆和方法区。</li></ul></li><li><p><strong>标记-清除算法</strong></p><ul><li><p><strong>原理</strong></p><p>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成之后，统一回收掉所有被标记的对象，或者标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。</p></li><li><p><strong>特点</strong></p><p>① 执行效率不稳定，如果堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除动作，导致效率随对象数量增长而降低。</p><p>② 内存空间碎片化问题，标记、清楚之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行中需要分配较大对象时无法找出足够的连续内存而不得不提前触发另一次垃圾收集。</p></li></ul></li><li><p><strong>标记-复制算法</strong></p><ul><li><p><strong>原理</strong></p><p>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的空间用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。</p></li><li><p><strong>特点</strong></p><p>① 实现简单、运行高效，解决了内存空间碎片问题。</p><p>② 代价是将可用内存缩小为原来的一半，浪费了过多空间。</p></li><li><p><strong>HotSpot的新生代划分</strong></p><p>把新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另一块Survivor上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1，即每次新生代中可用空间为整个新生代的90%。</p></li></ul></li><li><p><strong>标记-整理算法</strong></p><ul><li><p><strong>原理</strong></p><p>标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。并且如果不想浪费空间，就需要有额外的空间进行分配担保，以应对被使用内存中所有对象都100%存活的极端情况，所以老年代一般不使用此算法。</p><p>老年代使用标记-整理算法，其中标记过程与标记-清除算法一样，只是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p></li><li><p><strong>特点</strong></p><p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险策略：</p><p>如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，是一种极为负重的操作，而且这种对象移动必须全程暂停用户应用程序才能进行。但如果不移动对象就会导致空间碎片化问题，只能依赖更复杂的内存分配器和内存访问器来解决。所以是否移动对象都存在弊端，移动则内存回收时更复杂，不移动则内存分配时更复杂。</p></li></ul></li></ul><hr><h3 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h3><p>经典的垃圾收集器指JDK11之前的全部可用垃圾收集器。</p><ul><li><p><strong>Serial</strong></p><p>Serial收集器是最基础、历史最悠久的收集器，该收集器是一个使用复制算法的单线程工作收集器，单线程的意义不仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调它进行垃圾收集时必须暂停其他所有工作线程直到收集结束。</p><p>Serial是虚拟机运行在客户端模式下的默认新生代收集器，优点是简单且高效，对于内存受限的环境，它是所有收集器中最小的；对于单核处理器或处理器核心较少的环境来说，Serial收集器由于没有线程交互开销，因此可获得最高的单线程收集效率。</p></li><li><p><strong>ParNew</strong></p><p>ParNew实质上是Serial的多线程版本，除了使用多线程进行垃圾收集外其余行为完全一致。</p><p>ParNew是虚拟机运行在服务端模式下的默认新生代收集器，一个重要原因是除了Serial收集器外，只有它能与CMS收集器配合工作。</p><p>自从JDK9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了，官方希望他能被G1完全取代，甚至取消了Serial加CMS和ParNew加Serial Old这两组收集器组合。</p></li><li><p><strong>Parallel Scavenge</strong></p><p>Parallel Scavenge也是新生代收集器，同样基于标记-复制算法，也是可以并行的多线程收集器，与ParNew十分类似。</p><p>它的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，吞吐量就是处理器用于运行用户代码的时间与处理器消耗总时间的比值。自适应调节策略也是Parallel Scavenge区别于ParNew的一个重要特性。</p></li><li><p><strong>Serial Old</strong></p><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p><p>Serial Old是虚拟机在客户端模式下的默认老年代收集器，如果用于服务端，它可能有两种用途：一种是JDK5及之前与Parallel Scavenge搭配使用，另外一种是作为CMS收集器发生失败时的后备预案。</p></li><li><p><strong>Parellel Old</strong></p><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程收集，基于标记-整理算法实现。这个收集器直到JDK6才开始提供，在注重吞吐量优先的场景可以有效考虑Parallel Scavenge加Parallel Old组合。</p></li><li><p><strong>CMS</strong></p><p>CMS是一种以获取最短回收时间停顿时间为目标的收集器，如果希望系统停顿时间尽可能短给用户带来更好的交互体验，就可以使用CMS收集器。</p><p>CMS是基于标记-清除算法实现的，但过程相对复杂，整个过程分为四个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>重新标记</strong></li><li><strong>并发清除</strong></li></ul><p>其中初始标记和重新标记仍然需要STW（Stop The World，表示系统停顿），初始标记仅是标记一下GC Roots能直接关联到的对象，速度很快；并发标记就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程并发运行；重新标记阶段则是为了修正并发标记期间，因用户程序运作而导致标记产生变动的那一部分对象的标记记录，该阶段停顿时间比初始标记稍长，但远比并发标记短；最后是并发清除阶段，清理删除标记阶段判断的已死亡对象，由于不需要移动存活对象，因此该阶段也是可以与用户线程并发的。</p><p>由于整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器都可以和用户线程一起工作，所以从总体上说，CMS收集器的内存回收过程是与用户线程并发执行的。</p><p>CMS是HotSpot虚拟机追求低停顿的第一次成功尝试，但它还存在三个明显的缺点：</p><ul><li><p>对处理器资源非常敏感，在并发阶段虽然不会导致用户线程暂停，但会降低总吞吐量。</p></li><li><p>无法处理浮动垃圾，有可能出现并发失败而导致另一次FullGC的产生。</p></li><li><p>由于CMS基于标记-清除算法，因此会产生大量空间碎片，给大对象分配带来很大麻烦。</p><p><strong>浮动垃圾：</strong></p><blockquote><p>在CMS的并发标记和并发清理阶 段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分 垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集 时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p></blockquote><blockquote><p>重新标记 的作用只是修改之前 并发标记 所获得的不可达对象，所以是没有办法处理 “浮动垃圾” 的。</p></blockquote></li></ul></li><li><p><strong>G1</strong></p><p>G1开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。G1是一款主要面向服务端应用的垃圾收集器，最初的设计目标是替换JDK5中发布的CMS。</p><p>G1收集器之前的其他收集器，包括CMS，垃圾收集的目标要么是整个新生代，要么是整个老年代，或者整个堆。而G1跳出了这个樊笼，可以面向堆内存任何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收受益最大，这就是G1的MixedGC模式。</p><p>G1不再坚持固定大小以及固定数量的分代区域划分，而是把Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要扮演新生代的Eden空间、Survivor空间或老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p><p>G1跟踪各个Region里面的垃圾堆积的价值大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先处理回收价值收益最大的那些Region。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1在有限的时间内获取尽可能高的收集效率。</p><p>G1收集器的运作过程：</p><ul><li><strong>初始标记：</strong>仅仅标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的指，让下一阶段用户线程并发运行时，能正确地在可用Region中分配新对象。该阶段需要STW，但耗时很短，是借用进行MinorGC的时候同步完成的。</li><li><strong>并发标记：</strong>从GC Roots开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出需要回收的对象。该阶段耗时长，但可与用户程序并发执行，当对象图扫描完成后还要重新处理SATB记录下的在并发时有引用变动的对象。</li><li><strong>最终标记：</strong>对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li><li><strong>筛选回收：</strong>负责更新Region的统计数据，对各个Region的回收价值和成本排序，根据用户期望的停顿时间指定回收计划，可自由选择任意多个Region构成回收集然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧的Region的全部空间。该操作涉及对象的移动必须暂停用户线程，由多条收集器线程并行完成。</li></ul><p>可以由用户指定期望的停顿时间是G1的一个强大功能，但该值不能设得太低，一般设置为100~300毫秒比较合适。G1不会存在内存空间碎片的问题，但G1为了垃圾收集产生的内存占用和程序运行时的额外执行负载都高于CMS。</p></li></ul><hr><h3 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h3><p>指Shenandoah和ZGC，这两个收集器几乎整个工作过程全部都是并发的，只有初始标记、最终标记这些阶段有短暂的停顿，这部分停顿的时间基本上都是固定的，与堆的容量、堆中对象的数量没有正比例关系。</p><ul><li><p><strong>Shenandoah</strong></p><p>相比G1，内存布局同样基于Region，默认的回收策略也是优先处理回收价值最大的Region。但在管理堆内存方面，它与G1有一些不同之处：①支持并发的整理算法，G1的回收阶段是多线程并行的但是不能与用户线程并发。②默认不使用分代收集，不会有专门的新生代Region或老年代Region的存在。③摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为连接矩阵的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。</p></li><li><p><strong>ZGC</strong></p><p>一款JDK11中新加入的具有实验性质的低延迟垃圾收集器，和Shenandoah的目标高度相似，都希望在尽可能对吞吐量影响不大的前提下实现在任意堆大小下都可以把垃圾收集器的停顿时间限制在10ms以内的低延迟。</p><p>ZGC是一款基于Region内存布局的，不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。</p><p>ZGC的内存布局与Shenandoah和G1一样，ZGC也采用基于Region的堆内存布局，但不同的是ZGC的Region具有动态性，是动态创建和销毁的，并且区容量大小也是动态变化的。</p></li></ul><hr><h3 id="垃圾收集器的选择"><a href="#垃圾收集器的选择" class="headerlink" title="垃圾收集器的选择"></a>垃圾收集器的选择</h3><ul><li><p><strong>影响因素</strong></p><ul><li>如果是数据分析、科学计算类的任务，目标是尽快算出结果，那吞吐量就是主要关注点；如果是SLA应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，那延迟就是主要关注点；如果是客户端应用或嵌入式应用，那垃圾收集的内存占用就是主要关注点。</li><li>运行应用的基础设施，例如硬件规格，处理器数量的多少，分配内存的大小，选择的操作系统等。</li><li>使用JDK的发行商及版本号，对应的《Java虚拟机规范》版本等。</li></ul></li><li><p><strong>虚拟机和垃圾收集日志</strong></p><p>阅读分析虚拟机和垃圾收集日志是处理Java虚拟机内存问题必备的基础技能。</p><p>日志级别从低到高包括Trace、Debug、Info、Warning、Error、Off六种级别，默认为Info。</p><p>以G1收集器为例，一些常用参数如下（JDK9之前/JDK9后）：</p><ul><li>查看GC基本信息：<code>-XX:+PrintGC</code>/<code>-Xlog:gc</code></li><li>查看GC详细信息：<code>-XX:+PrintGCDetails</code>/<code>-X-log:gc*</code></li><li>查看GC前后堆、方法区可用容量的变化：<code>-XX:+PrintHeapAtGC</code>/<code>-Xlog:gc+heap=debug</code></li><li>查看GC过程中用户线程并发时间以及停顿时间：<code>-XX:+PrintGCApplicationConcurrentTime</code>和<code>-XX:+PrintGCApplicationStoppedTime</code>/<code>-Xlog:safepoint</code></li><li>查看熬过收集后剩余对象的年龄分布信息：<code>-XX:+PrintTenuringDistribution</code>/<code>-Xlog:gc+age=trace</code></li></ul></li></ul><hr><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p>Seial+Serial Old客户端默认收集器组合下的内存分配和回收策略：</p><ul><li><p><strong>对象优先在Eden区分配</strong></p><p>大多数情况下对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。</p><p>可通过<code>-XX:Xms</code>和<code>-XX:Xmx</code>设置堆大小，通过<code>-Xmn</code>设置新生代的大小，通过<code>-XX:SurvivorRatio</code>设置新生代中Eden区和Survivor区的比例。</p></li><li><p><strong>大对象直接进入老年代</strong></p><p>大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。大对象容易导致内存明明还有不少空间时就提前触发垃圾收集，以获得足够的连续空间才能安置好它们，当复制对象时，大对象就意味着高额内存复制开销。HotSpot提供了<code>-XX:PretenureSizeThreshold</code>参数（只有Serial和ParNew支持），大于该值的对象直接在老年代分配，避免在Eden和Survivor区之间来回复制产生大量内存复制操作。</p></li><li><p><strong>长期存活对象进入老年代</strong></p><p>虚拟机给每一个对象定义了一个对象年龄计数器，存储在对象头。对象通常在Eden区诞生，如果经历过第一次MinorGC仍然存活，并且能被Survivor容纳的话，该对象就会被移动到Survivor中并将年龄设置为1岁。对象在Survivor中每熬过一次MinorGC，年龄就增加1岁，当增加到一定程度（默认15）就会被晋升到老年代中。对象晋升老年代的年龄阈值，可通过参数<code>-XX:MaxTenuringThreshold</code>设置。</p></li><li><p><strong>动态对象年龄判定</strong></p><p>为了更好适应不同程序的内存状况，虚拟机并不是永远要求对象年龄达到晋升阈值才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，年龄大于等于该年龄的对象就可以直接进入老年代，无需等到<code>-XX:MaxTenuringThreshold</code>中要求的年龄。</p></li><li><p><strong>空间分配担保</strong></p><p>在发生MinorGC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果这个条件成立，那这一次MinorGC可以确定是安全的。</p><p>如果不成立，虚拟机会先查看<code>-XX:HandlePromotionFailure</code>参数的设置值是否允许担保失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将冒险尝试一次MinorGC；如果小于或者不允许担保失败，那么就会改成一次FullGC。</p><p>冒险的说明：新生代使用复制收集算法，但为了内存利用率只使用其中一个Survivor空间作为轮换备份，因此当出现大量对象在MinorGC后仍然存活的情况，需要老年代进行分配担保，把Survivor无法容纳的对象直接送入老年代。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GC垃圾回收 </tag>
            
            <tag> 垃圾回收器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机内存结构</title>
      <link href="2021/03/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>2021/03/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="内存区域与内存回收异常"><a href="#内存区域与内存回收异常" class="headerlink" title="内存区域与内存回收异常"></a>内存区域与内存回收异常</h2><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机的进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》，Java虚拟机所管理的内存将包括以下几个运行时数据区：</p><ul><li><p><strong>程序计数器</strong></p><p>程序计数器是一块较小的内存空间，它可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。在Java虚拟机的概念模型中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存区域。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何内存溢出情况的区域。</p></li><li><p><strong>Java虚拟机栈</strong></p><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个帧栈用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个帧栈在虚拟机中从入栈到出栈的过程。</p><p>局部变量表存放了编译器可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）表示，其中64位长度的long和double类型数据会占用两个变量槽，其余数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小（大小指槽的数量）。</p><p>该区域有两类异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常（HotSpot虚拟机栈容量不可以动态扩展，不存在此问题）。</p></li><li><p><strong>本地方法栈</strong></p><p>本地方法栈与虚拟机栈的作用非常相似，不同的是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则是为虚拟机栈用到的本地（Native）方法服务。</p><p>《Java虚拟机规范》对本地方法栈中方法所用的语言、使用方式与数据结构无强制规定，因此具体的虚拟机可根据需要自由实现，甚至有的虚拟机（例如HotSpot）直接将虚拟机栈和本地方法栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度异常和栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p></li><li><p><strong>Java堆</strong></p><p>Java堆是虚拟机所管理的内存中最大的一块。堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例，Java里几乎所有的对象实例都在这里分配内存。</p><p>Java堆是垃圾收集器管理的内存区域，从内存回收的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现”新生代“，”老年代“等名词，这些区域划分其实是不够准确的。这些区域划分只是一部分垃圾收集器的共同特性或设计风格，并非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》中的划分。由于垃圾收集技术已经发生了很大的改变，HotSpot中也出现了不采用分代设计的新垃圾收集器，因此把堆分代划分的说法就有许多需要商榷的地方。</p><p>Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。但对于大对象（例如数组），多数虚拟机实现出于简单、存储高效的考虑，很可能会要求连续的内存空间。</p><p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，虚拟机将抛出OutOfMemoryError异常。</p></li><li><p><strong>方法区</strong></p><p>方法区和Java堆一样，是各个线程共享的内存区域，<strong>它用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做”非堆“，目的是与堆区分开来。</p><p>JDK8之前使用永久代来实现方法区，这种设计导致了Java应用更容易遇到内存溢出问题，因为永久代有<code>-XX:MaxPermSize</code>的上限，即使不设置也有默认大小。JDK6时HotSpot的开发团队就准备放弃永久代，改用本地内存来实现方法区，JDK7时已经把原本放在永久代的字符串常量池、静态变量等移出，到了JDK8时永久代被完全废弃了，改用与JRockit一样在本地内存中实现的元空间来代替，把JDK7中永久代剩余内容（主要是类型信息）全部移到元空间。</p><p>《Java虚拟机规范》对方法区的约束很宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾回收。垃圾回收行为在该区域出现较少，主要回收目标是针对常量池的回收和对类型的卸载，一般来说该区域的回收效果比较难令人满意，尤其是类型的卸载，条件十分苛刻。</p><p>根据《Java虚拟机规范》如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</p></li><li><p><strong>运行时常量池</strong></p><p><strong>运行时常量池是方法区的一部分</strong>，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。一般来说，除了保存Class文件中描述的符号引用外，还会把符号引用翻译出来的直接引用也存储在运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被利用的较多的是String类的intern()方法。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p></li><li><p><strong>直接内存</strong></p><p>直接内存不是Java虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，但是这部分内存也被频繁使用，而且也可能导致内存溢出异常。</p><p>JDK1.4中新加入了NIO类，引入了一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，避免了在Java堆和Native堆中来回复制数据。</p><p>本机直接内存的分配不会收到Java堆大小的限制，但还是会收到本机总内存大小以及处理器寻址空间的限制，一般配置虚拟机参数时会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。</p></li></ul><hr><h3 id="HotSpot虚拟机对象揭秘"><a href="#HotSpot虚拟机对象揭秘" class="headerlink" title="HotSpot虚拟机对象揭秘"></a>HotSpot虚拟机对象揭秘</h3><ul><li><p><strong>对象的创建</strong></p><p>当Java虚拟机遇到一条字节码new指令时，首先将检查该指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有就必须先执行相应的类加载过程。</p><p>在类加载检查通过后虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上等同于把一块确定大小的内存块从Java堆中划分出来。假设Java堆内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分结点的指示器，那分配内存就仅是把该指针向空闲方向挪动一段与对象大小相等的距离，这种分配方式叫做“<strong>指针碰撞</strong>”。</p><p>但如果Java堆中的内存不是规整的，已被使用的内存和空闲内存相互交错，那么虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式叫做“<strong>空闲列表</strong>”。</p><p><strong>选择哪种分配方式由Java堆是否规整决定，Java堆是否规整又由所采用的垃圾回收器是否带有空间压缩整理能力决定</strong>。因此当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法时指针碰撞，既简单又高效；当使用CMS这种基于清除算法的垃圾收集器时，理论上只能采用较复杂的空间列表来分配内存。</p><p><strong>除了划分可用空间外还必须考虑分配内存的线程安全问题</strong>：对象创建在虚拟机中是十分频繁的，即使仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决该问题有两个方法：①对分配内存空间的动作进行同步处理，即虚拟机采用CAS加失败重试的方式保证更新操作的原子性。②把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，叫做本地线程分配缓冲TLAB，哪个线程要分配内存就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了分配新缓冲区时才需要同步锁定。虚拟机是否使用TLAB，通过<code>-XX:+/-UseTLAB</code>参数设定。</p><p>内存分配完成后虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值，如果使用了TLAB也可以在TLAB分配时提前进行该工作。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型对应的零值。</p><p>之后虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的GC分代年龄等信息。这些信息存放在对象头中，根据虚拟机运行状态的不同，对象头有不同的设置方式。</p><p>至此从虚拟机的视角来看一个新的对象已经产生了，但是从Java程序的角度来说，对象创建才刚刚开始。此时构造方法，即Class文件中的init方法还没有执行，所有字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说new指令后会接着执行init方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p><p>总结：</p><blockquote><p>【1】判断对象对应的类是否加载、链接、初始化</p></blockquote><blockquote><p>【2】为对象分配内存</p></blockquote><blockquote><p>【3】处理并发安全问题</p></blockquote><blockquote><p>【4】初始化分配到的空间（所有属性设置默认值，保证对象实例字段在不赋值时可直接使用）</p></blockquote><blockquote><p>【5】设置对象的对象头</p></blockquote><blockquote><p>【6】执行init方法进行初始化</p></blockquote></li><li><p><strong>对象的内存布局</strong></p><p>在HotSpot虚拟机中，对象在堆内存中的存储布局可分为三个部分。</p><ul><li><p><strong>对象头</strong></p><p>对象头包括两类信息，第一类是用于存储对象自身的运行时数据，<strong>如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据叫做“Mark Word”</strong>。对象需要存储的运行时数据很多，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计为一个有动态定义的数据结果，以便在极小的空间内存储更多的数据，根据对象的状态复用自己的存储空间。</p><p>对象头的另一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过该指针来确定对象是哪个类的实例。并非所有虚拟机实现都必须在对象数据上保留类型指针，查找对象的元数据不一定要经过对象本身。此外如果对象是一个Java数组，在对象头还必须有一块用于记录数组长度的数据。</p></li><li><p><strong>实例数据</strong></p><p>实例数据部分是对象真正存储的有效信息，即程序员在代码里所定义的各种类型的字段内容，无论是从父类继承的还是在子类定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。相同宽度的字段总是被分配到一起存放，在满足该前提条件的情况下父类中定义的变量会出现在子类之前。如果虚拟机的<code>+XX:CompactFields</code>参数值为true（默认值），那子类中较窄的变量也允许插入父类变量的空隙以节省内存空间。</p></li><li><p><strong>对齐填充</strong></p><p>这部分不是必然存在的，也没有特别含义，仅仅起占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象的起始地址必须是8字节的整数倍即任何对象的大小都必须是8字节的整数倍，而对象头已经被设为正好是8字节的整数倍，因此如果对象实例数据部分没有对齐，就需要对齐填充来补全。</p></li></ul></li><li><p><strong>对象的访问定位</strong></p><p>Java程序会通过栈上的reference数据来操作堆上的具体对象，而具体对象访问方式是由虚拟机决定的，主流的访问方式主要有使用句柄和直接指针两种。</p><ul><li><p><strong>使用句柄</strong></p><p>如果使用句柄访问的话，Java堆中将可能会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p><p>使用句柄访问最大的优点就是reference中存储的是稳定句柄地址，在对象被移动（处于垃圾收集过程中）时只会改变句柄中的示例数据指针，而reference本身不需要被修改。</p></li><li><p><strong>直接指针</strong></p><p>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话就不需要多一次间接访问的开销。</p><p>使用直接指针最大的优点就是速度更快，节省了一次指针定位的时间开销。HotSpot主要使用的就是直接指针来进行对象访问。</p></li></ul></li></ul><hr><h3 id="OutOfMemoryError异常"><a href="#OutOfMemoryError异常" class="headerlink" title="OutOfMemoryError异常"></a>OutOfMemoryError异常</h3><p>在《Java虚拟机规范》中除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM异常的可能。</p><ul><li><p><strong>Java堆溢出</strong></p><ul><li><p><strong>异常产生</strong></p><p>Java堆用于存储对象实例，我们只要不断创建对象，并且保证GC Roots到对象有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆容量的限制后就会产生OOM异常。</p><p>可通过<code>-Xms</code>参数将堆的最小值与<code>-Xmx</code>参数将堆的最大值设置为一样来避免堆自动扩展，通过<code>-XX:+HeapDumpOnOutOfMemoryError</code>可以让虚拟机在出现OOM时Dump出当前的内存堆转储快照以便进行事后分析。</p></li><li><p><strong>异常处理</strong></p><p>Java堆内存的OOM是实际应用中最常见的OOM情况，常规的处理方法是先通过内存映像分析工具对Dump出来的堆转储快照进行分析，确认内存中导致OOM的对象是否是必要的，也就是先分清楚到底是出现了内存泄漏还是内存溢出。</p><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄露对象是通过怎样的引用路径、与哪些GC Roots相关联才导致垃圾收集器无法回收它们，根据泄露对象的类型信息以及它到GC Roots引用链的信息，一般可以准确定位到对象创建的位置进而找出产生内存泄漏代码的具体位置。</p><p>如果不是内存泄漏，即内存中的对象确实都是必须存活的那就应当检查Java虚拟机的堆参数设置，与机器的内存相比是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。</p></li></ul></li><li><p><strong>虚拟机栈和本地方法栈溢出</strong></p><p>由于HotSpot虚拟机不区分虚拟机和本地方法栈，因此<code>-Xoss</code>（设置本地方法栈大小）的参数没有意义，栈容量只能由<code>-Xss</code>参数来设定关于虚拟机栈和本地方法栈，存在两种异常：</p><ul><li><p><strong>StackOverflowError</strong></p><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</p><ul><li><p><strong>异常产生</strong></p><p>使用<code>-Xss</code>参数减少栈内存容量，也可以定义大量本地变量增大方法帧中本地变量表的长度。</p></li><li><p><strong>异常处理</strong></p><p>无论由于帧栈太大还是虚拟机栈容量太小，当新的帧栈内存无法分配的时候虚拟机都会抛出StackOverflowError异常。该异常有明确错误堆栈可供分析，容易定位到问题所在。</p></li></ul></li><li><p><strong>OutOfMemoryError</strong></p><p>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。HotSpot虚拟机不支持虚拟机栈的扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现OOM异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。</p><ul><li><p><strong>异常产生和处理</strong></p><p>建立过多线程导致内存耗尽抛出OOM异常，在不能减少线程数量或者更换64位虚拟机的情况下，只能通过减少最大堆和减少栈容量来换取更多的线程。</p></li></ul></li></ul></li><li><p><strong>方法区和运行时常量池</strong></p><ul><li><p><strong>引入</strong></p><p>String类的intern方法是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p></li><li><p><strong>运行时常量池OOM</strong></p><ul><li><p><strong>异常产生</strong></p><p>在JDK6及之前常量池都分配在永久代，因此可以通过<code>-XX:PermSize</code>和<code>-XX:MaxPermSize</code>限制永久代的大小，间接限制常量池的容量。在while死循环中不断调用intern方法，之后将导致运行时常量池溢出。</p></li><li><p><strong>异常处理</strong></p><p>在JDK7及之后版本不会导致该问题，因为存放在永久代的字符串常量池已经被移至Java堆中。此时如果使用-Xmx限制堆大小会导致堆溢出。</p></li></ul></li><li><p><strong>方法区OOM</strong></p><ul><li><p><strong>异常产生</strong></p><p>方法区的主要职责是用于存放类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。只要不断在运行时产生大量的类去填满方法区，就会导致溢出。可以使用JDK的反射或CGLib直接操作字节码在运行时生成大量的类来导致溢出。当前的很多主流框架如Spring、Hibernate等对类增强是都会使用CGLib这类字节码技术，增强的类越多，就需要越大的方法区保证动态生成的新类型可以载入内存，也就更容易导致方法区溢出。</p></li><li><p><strong>异常处理</strong></p><p>方法区溢出也是常见的OOM，一个类如果要被垃圾回收器回收，条件是很苛刻的。在经常运行时生成大量动态类的应用场景中应该特别关注这些类的回收情况，除了CGLib字节码增强外，还有大量JSP或动态生成JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的类加载器加载也会视为不同的类）等。</p><p>JDK8之后永久代完全被废弃，取而代之的是元空间。HotSpot提供了一些参数作为元空间的防御措施：</p><p><code>-XX:MaxMetaspaceSize</code>：设置元空间的最大值，默认-1，表示不限制即只受限于本地内存大小。</p><p><code>-XX:MetaspaceSize</code>：指定元空间的初始大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量空间就适当降低该值，如果释放了很少的空间就适当提高该值。</p><p><code>-XX:MinMetaspaceFreeRatio</code>：作用是在垃圾收集之后控制最小的元空间剩余容量百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有<code>-XX:MinMetaspaceFreeRatio</code>，用于控制最大的元空间剩余容量百分比。</p></li></ul></li></ul></li><li><p><strong>本机直接内存溢出</strong></p><p>直接内存的容量大小可通过-XX:MaxDirectMemorySize指定，如果不去指定则默认与Java堆的最大值一致。</p><p>由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况，如果发现内存溢出后产生的Dump文件很小，而程序中又直接或间接使用了直接内存（典型的间接使用就是NIO），那么就可以考虑重点检查一下直接内存方面的原因了。</p></li></ul><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="2021/03/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/03/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java和线程"><a href="#Java和线程" class="headerlink" title="Java和线程"></a>Java和线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件IO等），又可以独立调度。目前线程是Java中进行处理器资源调度的最基本单位。</p><p>主流的操作系统都提供了线程实现，Java则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经调用过start方法且还未结束的java.lang.Thread类的实例就代表着一个线程。Thread类的所有关键方法都被声明为native，一个native方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现（也有可能是为了执行效率而使用native方法，通常最高效率的手段都是平台相关的手段）。</p><p>实现线程主要有三种方式：</p><ul><li><p><strong>使用内核线程实现（1:1实现）</strong></p><p>使用内核线程实现的方式也被称为1:1实现，内核线程（Kernel-Level Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为一个内核的分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核。</p><p>程序一般不会直接使用内核线程，而是使用内核线程的另一种高级接口即轻量级进程（Light Weight Process，LWP），轻量级进程就是通常所说的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程，这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。</p><p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程已经在系统调用中被阻塞了，也不会影响整个进程继续工作。轻量级进程也具有它的局限性：首先由于是基于内核线程实现的，所以各种线程操作，如创建、析构和同步等，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态和内核态中来回切换。其次每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。</p></li><li><p><strong>使用用户线程实现（1:N实现）</strong></p><p>使用用户线程实现的方式被称为1:N实现，从广义上说，一个线程只要不是内核线程就可以认为是用户线程（User Thread，UT）的一种，因此从该定义上来说轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用因此效率会受到限制，并不具备通常意义上的用户线程的优点。</p><p>狭义上的用户线程是指完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持更大规模的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1:N的关系称为一对多的线程模型。</p><p>用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核支援，所有的线程操作都需要用户程序自己去处理。线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”等问题变得难以解决。因为基于用户线程的实现的程序一般比较复杂，除了有明确的需求外一般的应用程序都不倾向使用用户线程，Java曾经使用过但最终又放弃了它。今年来许多新的以高并发为卖点的编程语言又普遍支持了用户线程，如Golang、Erlang等，使用户线程的使用率有所回升。</p></li><li><p><strong>使用用户线程加轻量级进程混合实现（N:M实现）</strong></p><p>线程除了依赖内核线程实现和用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式，被称为N:M实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然消耗低并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程和轻量级进程的数量比是不定的，是N:M的关系。</p><p>许多UNIX系列的操作系统都提供了这种混合的线程模型实现。</p></li></ul><hr><h3 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h3><p>Java线程如何实现并不受Java虚拟机规范的约束 ，这是一个与具体虚拟机相关的问题。Java线程早期在Classic虚拟机（JDK1.2之前）上是基于一种被称为绿色线程的用户线程实现的，但从JDK1.3开始，主流平台上的主流商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现。即采用1:1的线程模型。</p><p>以HotSpot为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot自己不会去干涉线程调度（可以设置线程优先级供操作系统调度参考），全权交给底层的操作系统处理。所以何时冻结或唤醒线程、该给线程分配多少CPU时间片、该把线程安排给哪个CPU核心去执行等都是由操作系统完成的，也都是由操作系统全权决定的。</p><p>还有一些例外的情况，例如用于JavaME的CLDC虚拟机，它同时支持两种线程模型，默认使用1:N的用户线程实现的线程模型，所有Java线程都映射到一个内核线程上；但它也可以使用另一种特殊的混合模型，Java线程依旧全部映射到一个内核线程上但是当Java线程要执行一个阻塞调用时，CLDC会为该调用单独开一个内核线程并且调度执行其他Java线程，等到那个阻塞调用完成之后再重新调度之前的Java线程继续执行。</p><p>另外一个例子时Solaris平台上的HotSpot虚拟机，由于操作系统的现场特性本来就可以同时支持1:1和N:M的线程模型，因此该平台上的虚拟机也对应提供了两个平台专有的虚拟机参数来明确指定虚拟机使用哪种线程模型。</p><p>操作系统支持怎样的线程模型，在很大程度上会影响上面的Java虚拟机的线程的是怎样映射的，这一点在不同平台上很难达成一致，因此《Java虚拟机规范》中没有限定Java线程实现的线程模型，线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编程和运行过程来说这些差异都是完全透明的。</p><hr><h3 id="Java线程的调度"><a href="#Java线程的调度" class="headerlink" title="Java线程的调度"></a>Java线程的调度</h3><p><strong>线程调度是指系统为线程分配处理器使用权的过程，调度方式主要有两种，分别是协同式线程调度和抢占式线程调度。</strong></p><p>如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完成之后，要主动通知系统切换到另一个线程上去。协同式多线程最大的好处就是实现简单，由于线程要把自己的事情干完之后才会进行线程切换，切换操作对线程自身是可知的，所以一般没有线程同步问题。它的缺点也很明显：线程执行的时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞。</p><p>如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程切换不由线程本身来决定。例如Java中的yield方法可以主动让出执行时间，但是如果想要主动获取执行时间，线程自身是没有什么办法的。这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程甚至整个系统阻塞的问题。<strong>Java使用的线程调度方式就是抢占式调度</strong>。</p><p>虽然Java线程调度是系统自动完成的，但我们依旧可以<strong>通过setPriority方法为线程设置优先级来为系统提供建议</strong>，为某些线程多分配一些时间，其他的一些线程可以少分配一些时间。Java中一共设置了10个级别的线程优先级，在两个线程同时处于可运行状态时优先级高的线程容易被操作系统选择执行。</p><p>不过线程优先级并不是一项稳定的调节手段，因为主流虚拟机上的Java线程是被映射到系统的原生线程上来实现的，所以线程调度最终的决定权还是在操作系统。尽管现代操作系统基本都提供了线程优先级的概念，但是并不见得能和Java线程的优先级一一对应，如Solaris中线程有2147483648种线程优先级，而Windows系统中就只有7种。如果操作系统的线程优先级比Java线程优先级更多，问题还比较容易处理，但如果比Java的优先级少，就不得不出现几个线程优先级对应一个操作系统优先级的情况了，在Windows种设置线程优先级1和2、3和4、6和7、8和9的效果是完全一样的。</p><hr><h3 id="Java线程的通信"><a href="#Java线程的通信" class="headerlink" title="Java线程的通信"></a>Java线程的通信</h3><p>通信是指线程之间以何种机制来交换信息，在命令式编程中线程之间的通信机制有两种，共享内存和消息传递。在共享内存的并发模型里线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。在消息传递的并发模型里线程之间没有公共状态，线程之间必须通过发送消息来显示通信。</p><p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制，在共享内存的并发模型里同步是显示进行的，程序员必须显示指定某个方法或代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在接受之前，同步是隐式进行的。</p><p><strong>Java并发采用共享内存模型，线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。JMM</strong></p><hr><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul><li><p><strong>NEW：</strong>初始状态，创建后还没有启动的线程处于这种状态，此时还没有调用start()方法。</p></li><li><p><strong>RUNNABLE：</strong>运行状态，Java线程将操作系统中的就绪（Ready）和运行（Running）两种状态统称为运行中，此时线程有可能正在等待操作系统分配CPU时间片，也有可能正在执行。</p></li><li><p><strong>BLOCKED：</strong>阻塞状态，阻塞状态与等待状态的区别是阻塞状态在等待一个排它锁，在程序等待进入同步区域时线程将进入这种状态。</p></li><li><p><strong>WAITING：</strong>等待状态，表示线程进入等待状态，处于该状态的线程不会被分配CPU时间片，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p>会导致线程陷入等待状态的方法：</p><ul><li>没有设置timeout参数的wait方法。</li><li>没有设置timeout参数的join方法。</li><li>LockSupport的park方法。</li></ul></li><li><p><strong>TIME_WAITING：</strong>限期等待状态，该状态不同于WAITING，可以在指定时间内自行返回。</p><p>会导致线程陷入限期等待状态的方法：</p><ul><li>设置了timeout参数的wait方法。</li><li>设置了timeout参数的join方法。</li><li>LockSupport的parkNanos方法。</li><li>LockSupport的parkUntil方法。</li></ul></li><li><p><strong>TERMINATED：</strong>终止状态，表示当前线程已经执行完毕。</p></li></ul><hr><h2 id="线程安全与锁"><a href="#线程安全与锁" class="headerlink" title="线程安全与锁"></a>线程安全与锁</h2><h3 id="Java中的线程安全"><a href="#Java中的线程安全" class="headerlink" title="Java中的线程安全"></a>Java中的线程安全</h3><p>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外地同步，或者在调用方进行任何其他地协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。</p><p>这个定义要求线程安全的代码都必须具备一个共同特征：代码本身封装了所有必要的正确性保障手段，令调用者无须关心多线程下的调用问题，更无须自己实现任何措施来保证多线程环境下的正确调用。</p><p>在Java中，按照线程安全的“安全程度”由强到弱，可以把Java中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><ul><li><p><strong>不可变</strong></p><p><strong>在Java中，不可变对象一定是线程安全的，</strong>无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全的保障措施。只要一个不可变的对象被正确地构建出来（即没有发生this引用逃逸的情况），那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程中处于不一致的状态。“不可变”带来的安全性是最直接、最纯粹的。</p><p><strong>在Java中，如果多线程共享的数据是一个基本类型数据，那么只要定义时使用final关键字修饰就可以保证它是不可变的。</strong>如<strong>果共享的数据是一个对象，需要保证对象自身的行为不会对其状态产生任何影响，才能保证这个对象的不可变性，例如可以将对象中带有状态的变量都声明为final类型</strong>，这样在构造器执行结束后它就是不可变的，例如Integer类将自己的成员变量使用fianl修饰保证不可变性。</p><p>不可变类型还有String、常用的枚举类型以及Long、Double等包装器类型、BigInterger和BigDecimal大数据类型，但不包括AtomicInteger和AtomicLong类型。</p></li><li><p><strong>绝对线程安全</strong></p><p>绝对线程安全的定义很严格，大部分Java API中标注自己是线程安全的类都不是绝对线程安全的，例如Vector容器，虽然它的方法都被synchronized修饰，保证了原子性、可见性和有序性、但是并不意味着调用它时就永远不需要同步手段了，例如多线程同时执行对Vector对象的get和remove操作，如果一个线程恰好在错误的时间删除了一个元素，导致get操作中遍历的索引不可用，那么get操作就会抛出索引越界异常。</p></li><li><p><strong>相对线程安全</strong></p><p>相对线程安全就是通常意义上讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用时不需要进行额外地保障措施，但是对于一些特定顺序地连续调用，就可能需要在调用端使用额外地同步手段来保证调用的正确性。</p><p>在Java中，大部分声称线程安全的类都属于这种类型，例如Vector、HashTable、Colletcions的synchronizedCollection()方法包装的集合等。</p></li><li><p><strong>线程兼容</strong></p><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。我们常说的一个类不是线程安全的通常就是这种情况，Java类库API中大部分的类都是线程兼容的，例如ArrayList和HashMap等。</p></li><li><p><strong>线程对立</strong></p><p>线程对立是指不管调用端是否采取了同步措施都无法在多线程环境中并发使用代码。由于Java语言天生支持多线程特性，线程对立这种排斥多线程的代码很少出现，而且通常都是有害的，应当尽量避免。</p><p>一个线程对立的例子就是Thread类的suspend和resume方法，如果有两个线程同时持有一个线程对象，一个尝试去中断，另一个尝试去恢复，在并发进行的情况下无论调用时是否进行了同步，目标线程都存在死锁风险：假如suspend中断的线程就是即将要执行resume的那个线程，那肯定就会产生死锁。因此这两个方法都已经被废弃了，常见线程对立的操作还有System.setIn()、System.setOut()等方法。</p></li></ul><hr><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><ul><li><p><strong>互斥同步</strong></p><p>互斥同步是一种最常见的也是最主要的并发正确性保障手段。<strong>同步是指多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用</strong>。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。互斥是方法，同步是目的。</p><p>在Java中最基本的互斥同步手段就是synchronized关键字，它是一种块结构的同步语法。synchronized关键字经过Javac编译后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。这两个字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象，如果代码中指定了对象参数，那么就以该对象作为锁定对象，如果没有明确指定，那么根据synchronized修饰的是方法类型（实例方法或类方法）来决定锁对象是实例对象还是类型对应的Class对象。</p><p>根据《Java虚拟机规范》的要求，在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经持有了那个对象的锁，那么就把锁的计数器的值增加1，而在执行monitorexit指令时会将锁计数器的值减1。一旦计数器的值为0，锁随即就被释放了。如果获取锁对象失败，那当前线程就应该被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。</p><p>根据《Java虚拟机规范》对monitorenter和monitorexit的行为描述，可以得出两个关于synchronized的直接推论：</p><ul><li>被synchronized修饰的同步块对一条线程来说是可重入的，这意味同一条线程反复进入同步块也不会出现将自己锁死的情况。</li><li>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库的锁那样强制已获得锁的线程释放锁，也无法强制正在等待锁的线程中断等待或超时退出。</li></ul><p>从执行成本的角度看，持有锁是一个重量级的操作。在主流Java虚拟机实现中，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免陷入用户态到核心态的转换中，进行这些状态转换需要耗费很多的处理器时间。尤其是对于代码很简单的同步块，例如被synchronized修饰的getter和setter方法，状态转换消耗的时间甚至比用户代码本身执行的时间还要长。因此才说synchronized是Java中的一个重量级操作，不过Java之后也进行了相关的锁优化措施。</p><p>除了synchronized关键字之外，自JDK5起Java类库新提供了juc包，其中的Lock接口成为了另一种全新的互斥同步手段。基于Lock接口，用户能够以非块结构来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面上去实现同步。</p><p>重入锁ReentrantLock是Lock接口最常见的一种实现，它与synchronized一样是可重入的，在基本用法上与synchronized也很相似，不过它增加了一些高级功能，主要包括以下三项：</p><ul><li><strong>等待可中断：</strong>是指持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待而处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li><li><strong>公平锁：</strong>是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。<strong>synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带有布尔值的构造器要求使用公平锁</strong>。不过一旦使用了公平锁，将会导致性能急剧下降，明显影响吞吐量。</li><li><strong>锁绑定多个条件：</strong>是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联时就不得不额外添加一个锁，而ReentrantLock无须这样做，可以多次调用newCondition()方法。</li></ul><p>在JDK5时ReentrantLock比synchronized性能有显著优势，而在JDK6中进行锁优化之后，二者的性能基本能够持平。</p><p>当synchronized和ReentrantLock都可以满足要求时可以优先考虑使用synchronized：</p><ul><li>synchronized是Java语法层面的同步，足够清晰也足够简单。</li><li>Lock应该确保在finally中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话可以由Java虚拟机来确保即使出现异常锁也能被正常释放。</li><li>尽管在JDK5时ReentrantLock的性能领先于synchronized，但从长远来看Java虚拟机更容易针对synchronized进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用Lock的话，Java虚拟机很难得知具体哪些锁对象是由特定线程持有的。</li></ul></li><li><p><strong>非阻塞同步</strong></p><p>互斥同步面临的主要问题是进行线程阻塞和唤醒带来的性能开销，因此这种同步也被称为阻塞同步。从解决方式来看，互斥同步属于一种悲观的并发策略，其总是认为只要不去做正确的同步措施那就肯定会出现问题，无论共享的数据是否真的会发生竞争，它都会进行加锁，这会导致用户态到核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。</p><p>随着硬件指令集的发展，我们已经有了其他选择：基于冲突检测的乐观并发策略，通俗地说就是不管风险，先进行操作，如果没有其他线程竞争共享数据操作就直接成功了；如果共享数据的确存在竞争，那再进行其他措施，例如不断重试直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步，使用这种措施的代码也被称为无锁编程。</p><p>之所以说乐观并发策略需要“硬件指令集的发展”，是因为我们必须要求操作和冲突检测这两个步骤具备原子性。如果在使用互斥同步来保证原子性就完全失去意义了，因此只能考硬件来实现这件事，硬件保证某些从语义上看起来需要多次操作的行为可以通过一条处理器指令就能完成，这类指令常用的有：测试并设置、获取并增加、交换、比较并交换（CAS）、加载链接/条件存储（LL/SC）。</p><p>其中测试并设置、获取并增加、交换这三条是20世纪就已经存在于大多数指令集中的处理器指令，后面两条是现代处理器新增的，而且这两条指令的目的和功能也是类似的。Java中最终暴露出来的是CAS操作。</p><ul><li><p><strong>CAS</strong></p><p>CAS指令需要有三个操作数，分别是内存位置（在Java中可以理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是不管是否更新了V的值都会返回V的旧值，上述的处理过程是原子操作，执行期间不会被其他线程打断。</p></li></ul><p>在JDK5之后，Java类库中才开始使用CAS操作，该操作由sun.misc.Unsafe类里面的<code>compareAndSwapInt()</code>和<code>compareAndSwapLong()</code>等几个方法包装提供。HotSpot虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件地内联进去了。不过由于Unsafe类设计时就不是给用户程序调用的类（Unsafe的getUnsafe方法限制了只有启动类加载器加载的Class才能访问它），因此在JDK9之前只有Java类库可以使用CAS，譬如juc包里的AtomicInteger类，其中的<code>compareAndSet()</code>和<code>getAndIncrement()</code>等方法都使用了Unsafe类的CAS操作来实现。如果用户程序也有使用CAS操作的需求，要么就采用反射手段突破Unsafe的访问限制，要么只能通过Java类库API来间接使用它。直到JDK9之后，Java类库才在VarHandle类中开放了面向用户程序使用的CAS操作。</p><p>AtomicIntegr的<code>incrementAndGet()</code>方法在一个无限循环中，不断尝试将一个比当前值大1的新值赋值给自己，如果失败了就说明执行CAS操作的时候旧值已经发生了变化，于是再次循环进行下一次操作直到成功为止。</p><p>尽管CAS既简单又高效，但这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是完美的，它存在一个逻辑漏洞：如果一个变量V初次读取的时候是A，并且在准备赋值的时候检查到它的值仍为A，这依旧不能说明它的值没有被其他线程更改过，因为这段时间内假设它的值先改为了B又改回了A，那么CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的ABA问题，juc包为了解决这个问题提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值得版本来保证CAS的正确性。不过目前这个类并不常用，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p></li><li><p><strong>无同步方案</strong></p><p>要保证线程安全，也并非一定要进行阻塞同步或非阻塞同步，同步与线程安全没有必然联系。同步只是保障存在共享数据竞争时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性，因此有一些代码天生就是线程安全的。</p><ul><li><p><strong>可重入代码：</strong>这种代码又称纯代码，是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。在特指多线程的上下文语境里，可以认为可重入代码是线程安全代码的一个真子集，这意味着相对线程安全来说，可重入性是更为基础的特性，它可以保证代码线程安全，即所有可重入的代码都是线程安全的，但并非所有线程安全的代码都是可重入的。</p><p>可重入代码有一些共同特征，例如不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数传入，不调用非可重入方法等。如果一个方法的返回结果是可预测的，只要输入了相同的数据就都能返回同样的结果，那它就满足可重入性的要求，当然也就是线程安全的。</p></li><li><p><strong>线程本地存储：</strong>如果一段代码中所需要的数据必须与其他代码共享，那就判断这些共享数据的代码能否保证在同一线程中执行，如果可以就把共享数据的可见性限制在一个同一线程之内，这样无须同步也能保证线程之间不出现数据竞争的问题。</p><p>符合这种特定的应用并不少见，大部分使用消费队列的架构模式（如生产者-消费者模式）都会将产品的消费过程限制在一个线程中消费完，其中最重要的一种应用实例就是Web交互模型中的“一个请求对应一个服务器线程”的处理方式，这种处理方式的广泛使用使很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>在Java中可以使用ThreadLocal类来实现线程本地存储的功能，每个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以<code>ThreadLocal.threadLocalHashCode</code>为键，本地线程变量为值的K-V键值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的<code>threadLocalHashCode</code>值，使用这个值就可以在线程K-V键值对中找到对应的本地线程变量。</p></li></ul></li></ul><hr><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul><li><p><strong>锁的内存语义和实现</strong></p><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</p><p>锁的释放与volatile写具有相同的内存语义，锁获取与volatile读具有相同的内存语义。线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。线程A释放这个锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</p><p>公平锁和非公平锁释放时，最后都要写一个volatile变量state。公平锁获取锁时，首先会去读volatile变量，非公平锁获取锁时，首先会用CAS更新volatile变量的值，这个操作同时具有volatile读和volatile写的内存语义。因此锁的释放-获取内存语义的实现方式为：①利用volatile变量的写-读具有的内存语义。②利用CAS所附带的volatile读和volatile写的内存语义。</p></li></ul><p>高效并发是从JDK5升级到JDK6后的一项重要的改进项，HotSpot虚拟机开发团队在这个版本上花费了大量资源去实现各种锁优化技术，如适应性自旋、锁消除、锁膨胀、轻量级锁、偏向锁等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序地执行效率。</p><ul><li><p><strong>自旋锁与自适应自旋</strong></p><p>互斥同步对性能最大地影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。同时虚拟机开发团队也注意到了在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂机和恢复线程并不值得。现在绝大多数的个人电脑和服务器都是多核心处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p><p>自旋锁在JDK1.4.2中就已经引入，只不过默认是关闭的，可以使用<code>-XX:+UseSpinning</code>参数来开启，在JDK6中就已经改为默认开启了。自旋等待不能代替阻塞，不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。<strong>自旋次数的默认次数是十次</strong>，用户可以使用<code>-XX:PreBlockSpin</code>来指定。</p><p>不过无论是默认值还是用户指定的自旋次数，对整个Java虚拟机中所有的锁来说都是相同的。在JDK6中对自旋锁的优化，引入了<strong>自适应的自旋。自适应意味着自旋的时间不再是固定的了</strong>，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能之间省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行时间的增长以及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准。</p><blockquote><p><strong>自旋锁总结：</strong></p><p><strong>当锁被其他线程持有，当前线程开始自旋，等持有锁的线程释放锁后即可立即获取锁，这样就避免了线程阻塞挂起，消耗性能（自旋的消耗&lt;&lt;阻塞的消耗）。但是线程自旋是需要消耗CPU的，如果持有锁的线程执行的时间超过自旋等待的最大时间仍没有释放锁（默认是自旋10次，后来自适应自旋），就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</strong></p></blockquote></li><li><p><strong>锁消除</strong></p><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上的数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</p></li><li><p><strong>锁粗化</strong></p><p>原则上我们在编写代码时，总是推荐将同步块的作用范围限制得尽量小，只在共享数据得实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁得线程也能尽可能快拿到锁。</p><p>大多数情况下这种原则是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之外的，那么即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能消耗。</p><p>如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p></li><li><p><strong>偏向锁</strong></p><p>偏向锁也是JDK6中引入的一项锁优化措施，<strong>它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都去掉，连CAS操作都不去做了。</strong></p><p><strong>偏向锁的意思就是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。</strong></p><p>假设当前虚拟机启用了偏向锁（启用参数<code>-XX:UseBiasedLocking</code>，这是自JDK6起HotSpot虚拟机的默认值），那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为”01“，把偏向模式设置为”1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。</p><p>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式马上就宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照轻量级锁那样去执行。</p><p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的，有时使用参数<code>-XX:UseBiasedLocking</code>来禁止偏向锁优化反而能提升性能。</p><p><strong>当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。</strong></p><p>偏向锁在 JDK 6 及之后版本的 JVM 里是默认启用的。可以通过 JVM 参数关闭偏向锁：</p><p><strong>-XX:-UseBiasedLocking=false</strong>，关闭之后程序默认会进入轻量级锁状态。</p><blockquote><p>偏向锁的实现总结：</p><p><strong>偏向锁获取过程：</strong></p><p>①访问Mark World中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态；</p><p>②如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤⑤，否则进入③；</p><p>③如果线程ID并未指向当前线程，则通过CAS操作竞争锁，如果竞争成功，则将Mark World中线程ID设置为当前线程ID，然后执行⑤，如果竞争失败，执行④；</p><p>④如果CAS获取偏向锁失败，则表示有竞争，当到达全局安全点时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码；</p><p>⑤执行同步代码。</p><p><strong>偏向锁的释放过程：</strong></p><p>偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p><strong>偏向锁的适用场景：</strong></p><p>始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作；<br>在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用；</p></blockquote></li><li><p><strong>轻量级锁</strong></p><p>轻量级锁是JDK6时加入的新型锁机制，它名字中的“轻量级”是相对于操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为“重量级”锁。不过需要强调的是，轻量级锁并不是用来代替重量级锁的，它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p>要理解轻量级锁以及偏向锁的原理和运作过程，就必须要对HotSpot虚拟机对象的内存布局（尤其是对象头部分）有所了解。HotSpot虚拟机的对象头分为两部分，第一部分是用于存储对象自身的运行时数据的，如哈希码、GC分代年龄等。这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特，官方称为”Mark Word“。这部分是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象数据类型的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。</p><p>由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到Java虚拟机的空间使用效率，Mark Word被设计成一个非固定的动态数据结构，以便在极小的空间内存储尽量多的信息。它会根据对象的状态复用自己的存储空间。对象除了未被锁定的正常状态外，还有轻量级锁定、重量级锁定、GC标记、可偏向等几种不同的状态。</p><ul><li><p><strong>轻量级锁的工作过程</strong></p><p>在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为01状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的Mark Word的拷贝。</p><p>然后虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向锁记录的指针，如果这个更新操作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位将转变为”00“，表示此对象处于轻量级锁定状态。</p><p>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程以及拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态变为”10”，此时Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也必须进入阻塞状态。</p></li><li><p><strong>轻量级锁的解锁过程</strong></p><p>它的解锁操作也同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程复制的Mark Word替换回来。假如能够替换成功，那整个同步过程就顺利完成了，如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时唤醒被挂起的线程。</p></li></ul><p>轻量级锁能提升程序同步性能的依据是”对于绝大部分的锁，在整个同步周期内都是不存在竞争的“这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销，但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。</p></li><li><p><strong>锁优化问题总结</strong></p><ul><li><p><strong>锁优化</strong></p><p>JDK1.6为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，<strong>在JDK1.6中，锁一共有4个状态，级别从低到高依次是：无锁状态(01)、偏向锁状态(01)、轻量级锁状态(00)和重量级锁状态(10)<strong>，这几个状态会随着竞争情况逐渐升级。</strong>锁可以升级但不能降级，如果偏向锁升级成轻量级锁后就不能降级成偏向锁，这种只能升级不能降级的锁策略是为了提高获得锁和释放锁的效率。锁的膨胀不可逆</strong></p></li><li><p><strong>偏向锁的获得原理</strong></p><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步代码块并获取锁时，会在对象头和帧栈中的锁记录里存储锁偏向的线程ID，以后该线程再进入和退出同步代码块不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头（synchronized用的锁存在Java的对象头里）的Mark Word里是否存储着指向当前线程的偏向锁。</p><p>如果测试成功表示线程已经获得了锁，如果测试失败则需要再测试一下Mark Word（主要存储锁状态、对象的hashCode、对象的分代年龄、是否是偏向锁、锁标志位）中偏向锁的标识是否设置成了1（表示当前是偏向锁），如果设置了就尝试使用CAS将对象头的偏向锁指向当前线程，否则使用CAS竞争锁。 </p></li><li><p><strong>偏向锁的撤销原理</strong></p><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（该时间点上没有正在执行的字节码），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态则将对象头设为无锁状态；如果线程还活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 </p></li><li><p><strong>偏向锁的打开和关闭</strong></p><p>偏向锁在Java6和Java7中默认是开启的，但是它在应用程序启动几秒后才激活，如果有必要可以使用JVM参数来关闭延迟：-XX：BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况处于竞争状态，可以通过JVM参数来关闭偏向锁：-XX：UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。</p></li><li><p><strong>轻量级锁的加锁原理</strong></p><p>线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针，如果成功那么当前线程获得锁，如果失败表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 </p></li><li><p><strong>轻量级锁的解锁原理</strong></p><p>轻量级锁解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功则表示没有竞争发生。如果失败则表示当前存在锁竞争，锁就会膨胀为重量级锁。</p><p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞了），一旦锁升级为重量级锁，就不会再恢复到轻量级锁的状态。在这种情况下，其他线程视图获取锁时都会被阻塞，当持有锁的线程释放锁后才会唤醒这些线程，被唤醒的线程就会对锁资源进行新一轮的争夺。</p></li><li><p><strong>偏向锁、轻量级锁和重量级锁的区别</strong></p><p>①偏向锁的优点是加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距，缺点是如果线程间存在锁竞争会带来额外锁撤销的消耗，适用于只有一个线程访问同步代码块的场景。</p><p>②轻量级锁的优点是竞争的线程不会阻塞，提高了程序的响应速度，缺点是如果线程始终得不到锁会自旋消耗CPU，适用于追求响应时间和同步代码块执行非常快的场景。</p><p>③重量级锁的优点是线程竞争不使用自旋不会消耗CPU，缺点是线程会被阻塞，响应时间很慢，适应于追求吞吐量，同步代码块执行较慢的场景。</p></li></ul></li></ul><hr><h3 id="锁优化的几种方式"><a href="#锁优化的几种方式" class="headerlink" title="锁优化的几种方式"></a>锁优化的几种方式</h3><ul><li><p>减少锁的持有时间</p><p>对一个方法加锁，不如对方法中需要同步的几行代码加锁；</p></li><li><p>减少锁的粒度</p><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。</p><p><strong>最最典型的减小锁粒度的案例就是ConcurrentHashMap。</strong></p></li><li><p>使用读写分离锁代替独占锁</p><p>用ReadWriteLock将读写的锁分离开来, 尤其在读多写少的场合, 可以有效提升系统的并发能力.</p></li><li><p>锁分离  读写锁</p></li><li><p>锁粗化</p><p>锁粗化与减少锁的持有时间, 两者是截然相反的。</p><p>锁粗化是指：在一个间隔性地需要执行同步语句的线程中，如果在不连续的同步块间频繁加锁解锁是很耗性能的，因此把加锁范围扩大，把这些不连续的同步语句进行一次性加锁解锁。虽然线程持有锁的时间增加了，但是总体来说是优化了的。</p></li></ul><h3 id="AQS相关问题"><a href="#AQS相关问题" class="headerlink" title="AQS相关问题"></a>AQS相关问题</h3><p><strong>概念</strong></p><p>AQS是抽象队列同步器Abstract Queued Synchronizer，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者期望它成为实现大部分同步需求的基础。</p><p>AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch…。</p><p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:</p><ul><li>getState()</li><li>setState()</li><li>compareAndSetState()</li></ul><p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p><p>不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p><p><strong>AQS的主要实现方式</strong></p><p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState、setState和compareAndSetState）来进行操作，因为它们能够保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型地同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLacth等）。</p><p><strong>基于AQS实现的同步器有什么共同点</strong></p><p>①至少有一个acquire操作，这个操作阻塞调用线程，直到AQS的状态允许这个线程继续执行。FutureTask中的acquire操作为get方法调用。②至少有一个release操作，这个操作改变AQS的状态，改变后的状态可允许一个多多个阻塞线程解除阻塞。FutureTask中的release操作包括run方法和cancel方法。</p><p><strong>同步器和锁的联系</strong></p><p>同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面对的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所关注的领域。</p><p><strong>AQS的实现包括哪些方面</strong></p><p>队列同步器的从实现角度分为多方面，主要包括同步队列、独占式同步状态的获取与释放、共享式同步状态的获取与释放，以及超时获取同步状态等同步器的核心数据与模板方法。</p><p><strong>同步队列的原理</strong></p><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等构造成一个节点并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p><p><strong>同步队列的节点保存哪些信息</strong></p><p>同步队列中的节点用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。节点是构成同步队列的基础，同步器拥有首节点和尾节点，没有成功获取同步状态的线程将会成为节点加入该队列的尾部。</p><p><strong>同步队列节点的等待状态有哪些类型</strong></p><p>①CANCELLED，值为1，由于在同步队列中等待的线程等待超时或者被中断需要从同步队列中取消等待，节点进入该状态将不会变化。②SIGNAL，值为-1，后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行。③CONDITION，值为-2，节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal方法后该节点将会从等待队列转移到同步队列中，加入到对同步状态的获取中。④PROPAGATE，值为-3，表示下一次共享式同步状态获取将会无条件地被传播下去。⑤INITIAL，值为0，初始状态。</p><p><strong>独占式同步状态的获取和释放流程</strong></p><p>在获取同步状态时，同步器调用acquire方法，维护一个同步队列，使用tryAcquire方法安全地获取线程同步状态，获取状态失败的线程会构造同步节点并通过addWaiter方法被加入到同步队列的尾部，并在队列中进行自旋。之后会调用acquireQueued方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞节点被中断实现，移出队列或停止自旋的条件是前驱节点是头结点并且成功获取了同步状态。</p><p>在释放同步状态时，同步器调用tryRelease方法释放同步状态，然后调用unparkSuccessor方法（该方法使用LockSupport唤醒处于等待状态的线程）唤醒头节点的后继节点，进而使后继节点重新尝试获取同步状态。</p><p><strong>为什么只有当前驱节点是头节点时才能够尝试获取同步状态</strong></p><p>头节点是成功获取到同步状态的节点，而头节点的线程释放同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。</p><p>维护同步队列的FIFO原则，节点和节点在循环检查的过程中基本不相互通信，而是简单地判断自己的前驱是否为头节点，这样就使得节点的释放规则符合FIFO，并且也便于对过早通知的处理（过早通知是指前驱节点不是头结点的线程由于中断而被唤醒）。</p><p><strong>共享式同步状态的获取和释放流程</strong></p><p>在获取同步状态时，同步器调用acquireShared方法，该方法调用tryAcquireShared方法尝试获取同步状态，返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。因此在共享式获取锁的自旋过程中，成功获取到同步状态并退出自旋的条件就是该方法的返回值大于等于0。</p><p>释放同步状态时，调用releaseShared方法，释放同步状态之后将会唤醒后续处于等待状态的节点。对于能够支持多线程同时访问的并发组件，它和独占式的主要区别在于tryReleaseShared方法必须确保同步状态（或资源数）线程安全释放，一般通过循环和CAS来保证，因为释放同步状态的操作会同时来自多个线程。</p><p><strong>独占式超时获取同步状态的流程</strong></p><p>通过调用同步器的doAcquireNanos方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则返回false。该方法提供了传统Java同步操作（例如synchronized关键字）所不具备的特性。</p><p><strong>响应中断的同步状态获取过程</strong></p><p>在JDK1.5之前当一个线程获取不到锁而被阻塞到synchronized之外时，对该线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧阻塞在synchronized上等待着获取锁。在JDK1.5中，同步器提供了acquireInterruptibly方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立即返回并抛出InterruptedException。</p><p><strong>独占式超时获取同步状态的原理</strong></p><p>超时获取同步状态的过程可以被视为响应中断获取同步状态过程的“增强版”，doAcquireNanos方法在支持响应中断的基础上增加了超时获取的特性，针对超时获取，主要需要计算出需要睡眠的时间间隔nanosTimeout，为了防止过早通知，nanosTimeout的计算公式为nanosTimeout-=now-lastTime，其中now为当前唤醒时间，lastTime为上次唤醒时间，如果nanosTimeout大于0则表示超时时间未到，需要继续睡眠nanosTimeout纳秒，否则表示已经超时。</p><p><strong>独占式超时获取同步状态和独占式获取同步状态的区别</strong></p><p>在独占式超时获取同步状态的过程的doAcquireNanos中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功则从该方法返回，这个过程和独占式同步获取的过程类似，但是在同步状态获取失败的处理上有所不同。</p><p>如果当前线程获取同步状态失败，独占式超时获取同步状态中会判断是否超时，如果没有超时就重新计算超时间隔，然后使当前线程等待该间隔时间，如果在该时间内没有获取到同步状态就会从等待逻辑中自动返回。而独占式获取同步状态的过程中如果没有获取到同步状态就会使当前线程一直处于等待状态。</p><p><strong>超时时间过小时对超时等待的影响</strong></p><p>nanosTimeout过小时（小于等于1000纳秒），将不会使线程进行超时等待，而是进入快速自旋过程。因为非常短的超市等待无法做到精确，如果这时再进行超时等待相反会让nanosTimeout的超时从整体上表现得反而不精确，因此在超市非常短的情况下同步器会进入无条件的快速自旋。</p><hr><h3 id="Synchronized相关问题"><a href="#Synchronized相关问题" class="headerlink" title="Synchronized相关问题"></a>Synchronized相关问题</h3><p>把代码块声明为 synchronized，通常是指该代码具有 <strong>原子性、可见性、有序性</strong>。</p><p>synchronize的限制：</p><ol><li>当线程尝试获取锁的时候，如果获取不到锁会一直阻塞, 它无法中断一个正在等候获得锁的线程；</li><li>如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待,也无法通过投票得到锁，如果不想等下去，也就没法得到锁。</li></ol><p>从语法上讲，Synchronized可以把任何一个非null对象作为”锁”，在HotSpot JVM实现中，<strong>锁有个专门的名字：对象监视器（Object Monitor）</strong>。</p><p>Synchronized总共有三种用法：</p><ol><li>当synchronized作用在实例方法时，监视器锁（monitor）便是对象实例（this）；</li><li>当synchronized作用在静态方法时，监视器锁（monitor）便是对象的Class实例，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁；</li><li>当synchronized作用在某一个对象实例时，监视器锁（monitor）便是括号括起来的对象实例；</li></ol><blockquote><p>注意，synchronized 内置锁 是一种 对象锁（锁的是对象而非引用变量），<strong>作用粒度是对象 ，可以用来实现对 临界资源的同步互斥访问 ，是 可重入 的。其可重入最大的作用是避免死锁</strong>，如：<strong>子类同步方法调用了父类同步方法，如没有可重入的特性，则会发生死锁；</strong></p></blockquote><h3 id="Lock相关问题"><a href="#Lock相关问题" class="headerlink" title="Lock相关问题"></a>Lock相关问题</h3><ul><li><p><strong>可重入锁</strong></p><p>重入锁就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁，除此之外该锁还支持获取锁的公平和非公平性选择。synchronized关键字隐式地支持重进入，ReentrantLock虽然不能像synchronized关键字一样支持隐式的重进入，但是在调用lock方法时已经获取到锁的线程能够再次调用lock方法获取锁而不被阻塞。</p></li><li><p><strong>锁的公平性</strong></p><p>如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反正就是不公平的。公平的获取锁也就是等待时间最长的线程优先获取锁，也可以说锁的获取是顺序的，<strong>ReentrantLock的构造方法中可以通过设置参数控制锁的公平性。</strong></p><p>公平锁机制往往没有非公平锁的效率高，非公平锁地吞吐量更大，但是公平锁能够减少饥饿发生的概率，保证了锁地获取按照FIFO顺序，等待越久的请求越是能优先得到满足。</p></li><li><p><strong>重进入</strong></p><p>重进入指的是任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决两个问题：①线程再次获取锁，锁需要去识别获取锁的线程是否为当前占有锁的线程，如果是则再次获取成功。②锁的最终释放，线程重复n次获取了锁，随后在第n次释放该锁后，其他现场能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而被锁释放时，技术自减，当计数为0时表示锁已经成功释放。</p></li><li><p><strong>ReentrantLock的可重入的实现</strong></p><p>以非公平锁为例，通过nonfairTryAcquire方法获取锁，该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求则将同步状态值进行增加并返回true，表示获取同步状态成功。</p><p>成功获取锁的线程再次获取锁，只是增加了同步状态值，这就要求ReentrantLock在释放同步状态时减少同步状态值。如果该锁被获取了n次，那么前（n-1）次tryRelease方法必须都返回fasle，只有同步状态完全释放了才能返回true，可以看到该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p><p>对于非公平锁只要CAS设置同步状态成功则表示当前线程获取了锁，而公平锁则不同。公平锁使用tryAcquire方法，该方法与nonfairTryAcquire的唯一区别就是判断条件中多了对同步队列中当前节点是否有前驱节点的判断，如果该方法返回true表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。 </p></li><li><p><strong>读写锁</strong></p><p>像Mutex和ReentrantLock都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读写锁使得并发性相比一般的排他锁有了很大提升。</p></li><li><p><strong>读写锁的特点</strong></p><p>除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。只需要在读操作时获取读锁，写操作时获取写锁即可，当写锁被获取时后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后所有操作继续执行，编程方式相对于使用等待/通知机制的实现方式而言变得简单明了。</p></li><li><p><strong>读写锁ReentrantReadWriteLock的特性</strong></p><ul><li>公平性选择：支持非公平（默认）和公平的锁获取方式吞吐量还是非公平性优于公平。</li><li>重进入：该锁支持重进入，以读写线程为例：读线程在获取了读锁之后能够再次获得读锁。而写线程在获取了写锁之后能再次获得写锁，同时也可以获取读锁。</li><li>锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级为读锁。</li></ul></li><li><p><strong>读写锁的状态的设计</strong></p><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步状态（一个整形变量）上维护多个读线程和一个写线程的状态。如果在一个int型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。</p><p>假设同步状态值为S，写状态等于S&amp;0x0000FFFF（将高17位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号右移16位），当写状态增加1时，等于S+1，当读状态增加1时，等于S+（1&lt;&lt;16）。根据状态的划分能得出一个推论：S不等于0时，当写状态等于0时，则读状态大于0，即读锁已被获取。</p></li><li><p><strong>写锁的获取和释放过程</strong></p><p>写锁是一个支持重进入的排他锁，如果当前线程已经获得了写锁则增加写状态，如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获得写锁的线程则当前线程进入等待状态。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p></li><li><p><strong>为什么存在读锁时写锁会阻塞</strong></p><p>读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取则其他读写线程的后续访问均被阻塞。</p></li><li><p><strong>读锁的获取和释放过程</strong></p><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写线程为0）时，读锁总会被成功地获取，而所做的只是线程安全地增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取则进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。</p><p>读锁的每次释放均会减少读状态，减少的值是（1&lt;&lt;16），读锁的每次释放是线程安全的，可能有多个读线程同时释放读锁。</p></li><li><p><strong>JDK1.6对读锁的改动</strong></p><p>获取读锁的实现从JDK1.5到JDK1.6变得复杂许多，主要原因是新增了一些功能，例如getReadHoldCount方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护，这使获取读锁的实现变得复杂。</p></li><li><p><strong>锁降级</strong></p><p>锁降级指的是写锁降级成为读锁，如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级指的是把持住（当前拥有的）写锁，再获取到读锁，随后释放先前拥有的写锁的过程。</p></li><li><p><strong>锁降级中读锁的获取是否有必要</strong></p><p>是必要的，主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程A获取了写锁修改了数据，那么当前线程是无法感知线程A的数据更新的。如果当前线程获取读锁，即遵循锁降级的步骤，线程A将会被阻塞，直到当前线程使用数据并释放读锁之后，线程A才能获取写锁并进行数据更新。</p></li></ul><hr><h3 id="Synchronized与lock的区别"><a href="#Synchronized与lock的区别" class="headerlink" title="Synchronized与lock的区别"></a>Synchronized与lock的区别</h3><p>1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；<br>2）当synchronized块结束时，会自动释放锁，lock一般需要在finally中自己释放。synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；<br>3）lock等待锁过程中可以用interrupt来终端等待，而synchronized只能等待锁的释放，不能响应中断。<br>4）lock可以通过trylock来知道有没有获取锁，而synchronized不能； </p><p>5） 当synchronized块执行时，只能使用非公平锁，无法实现公平锁，而lock可以通过new ReentrantLock(true)设置为公平锁，从而在某些场景下提高效率。</p><p>6、Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）<br>7、synchronized 锁类型 可重入 不可中断 非公平 而 lock 是： 可重入 可判断 可公平（两者皆可）<br>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。 </p><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><ul><li><p><strong>Condition的作用</strong></p><p>Condition接口提供了类似Object监视器方法，与Lock配合可以实现等待/通知模式。Condition对象是由Lock对象创建出来的，因此Condition是依赖Lock对象的。一般会将Condition对象作为成员变量，当调用await方法后当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal方法，通知当前线程后，当前线程才从await方法返回并且在返回前已经获取了锁。</p></li><li><p><strong>Condition的实现</strong></p><p>ConditionObject是同步器AQS的内部类，因为Condition的操作需要获取相关的锁，所以作为同步器的内部类也较为合理。每个Condition对象都包含着一个等待队列，该等待队列是Condition对象实现等待/通知功能的关键。Condition的实现主要包括了等待队列、等待和通知。</p></li><li><p><strong>等待队列的原理</strong></p><p>等待队列是一个FIFO队列，在队列中的每个节点都包含了一个线程引用，该线程就是在ConditionObject对象上等待的线程，如果一个线程调用了await方法，那么该线程会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步其中节点的定义，也就是说同步队列和等待队列中的节点类型都是同步器的静态内部类Node。</p><p>一个ConditionObject包含一个等待队列，ConditionObject拥有首节点和尾节点。Object拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。节点引用更新的过程并没有用CAS保证，因为调用await方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p></li><li><p><strong>await方法的原理</strong></p><p>如果从队列的角度看await方法，当调用await方法时相当于同步队列的首节点（获取了锁的节点）移动到Condition对象的等待队列中，首节点不会直接加入等待队列，而是通过addConditionWaiter方法把当前线程构造成一个新的节点并将其加入等待队列中。加入等待队列后，释放同步状态，唤醒同步队列中的后继节点然后进入等待状态。如果不是通过其他线程调用signal方法唤醒而是对await线程进行中断，会抛出InterruptedException。</p></li><li><p><strong>signal方法的原理</strong></p><p>该方法会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。调用该方法的前置条件是当前线程必须获取了锁，signal方法进行了检查，判断当前线程是否是获取了锁的线程，接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。被唤醒后的线程将从await方法中的while循环退出，进而调用同步器的acquireQueued方法加入到获取同步状态的竞争中。成功获取同步状态（或者说锁）后，被唤醒的线程将从先前调用的await方法返回，此时该线程已成功获取了锁。signalAll方法相当于对等待队列中的每个节点执行一次signal方法，效果就是将等待队列中的节点全部移到到同步队列中并唤醒每个节点的线程。</p></li><li><p><strong>阻塞队列</strong></p><p>阻塞队列是一个支持两个附加操作的队列，这两个附加的操作支持阻塞的插入和移除方法。当队列满时，队列会阻塞插入元素的线程，直到队列不满。当队列为空时，获取元素的线程会等待队列变为非空。阻塞队列常用于生产者和消费者的场景，生产者向队列里添加元素，消费者从队列中获取元素，阻塞队列就是生产者用来存放元素，消费者用来获取元素的容器。</p><ul><li><p><strong>Java中的阻塞队列</strong></p><ul><li><p>ArrayBlockingQueue，一个由数组结构组成的有界阻塞队列，按照FIFO的原则对元素排序，默认情况下不保证线程公平地访问队列，有可能先阻塞地线程最后才访问队列。</p></li><li><p>LinkedBlockingQueue，一个由链表结构组成的有界阻塞队列，队列的默认和最大长度为Integer的最大值，按照FIFO原则排序。</p></li><li><p>PriorityBlockingQueue，一个支持优先级排序的无界阻塞队列，默认情况下元素按照顺序升序排序。也可以自定义compareTo方法指定元素排序规则，或者初始化时指定构造方法的参数Comparator对元素排序，不能保证同优先级元素的顺序。</p></li><li><p>DelayQueue，一个支持延时获取元素的无界阻塞队列，使用优先级队列实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有延时期满时才能从队列中获取元素。适用于以下场景：①缓存系统的设计，一旦能从延迟队列获取元素说明缓存有效期到了。②定时任务调度，保存当天将要执行的任务和执行时间，一旦获取到任务就立刻开始执行。</p></li><li><p>SynchronousQueue，一个不存储元素的阻塞队列，每一个put操作必须等待一个take操作，否则不能继续添加元素。默认使用非公平策略，也支持公平策略，适用于传递性场景，吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p></li><li><p>LinkedTransferQueue，一个由链表结构组成的无界阻塞队列，相对于其他阻塞队列多了tryTransfer和transfer方法。transfe方法：如果当前有消费者正在等待接收元素，transfer方法可以把生产者传入的元素立刻传输给消费者，如果没有，会将元素放在队列的尾节点等到该元素被消费者消费了才返回。tryTransfer方法：用来试探生产者传入的元素能否直接传给消费者，如果没有消费者等待接收元素返回false，和transfer的区别时无论消费者是否接受都会立即返回，transfer是等到消费者消费了才返回。</p></li><li><p>LinkedBlockingDeque，一个由链表结构组成的双向阻塞队列，可以从队列的两端插入和移除元素，多了一个操作队列的入口，在多线程同时入队时就少了一半竞争。</p></li></ul></li><li><p><strong>阻塞队列的实现原理</strong></p><p>使用通知模式实现，所谓通知模式就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。JDK中使用了Condition条件对象来实现。当往队列里插入一个元素，如果队列不可用，那么阻塞生产者主要通过LockSupport.park(this)实现。</p></li></ul></li></ul><hr><h3 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h3><ul><li><p><strong>CountDownLatch</strong></p><p>允许一个或多个线程等待其他线程完成操作，构造方法接收一个int类型的参数作为计数器，如果要等待n个点就传入n。每次调用countDown方法时n就会减1，await方法会阻塞当前线程直到n变为0，由于countDown方法可用在任何地方，所以n个点既可以是n个线程也可以是1个线程里的n个执行步骤。用在多线程时，只需要把这个CountDownLatch的引用传递到线程里即可。</p></li><li><p><strong>CyclicBarrier</strong></p><p>CyclicBarrier是同步屏障，它的作用是让一组线程到达一个屏障（或同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被拦截的线程才会继续运行。构造方法中的参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier自己已到达屏障，然后当前线程被阻塞。还支持在构造方法中传入一个Runable类型的任务，当线程到达屏障时会优先执行该任务。适用于多线程计算数据，最后合并计算结果的应用场景。</p><ul><li><p><strong>CountDownLacth和CyclicBarrier的区别</strong></p><p>CountDownLacth的计数器只能用一次，而CyclicBarrier的计数器可使用reset方法重置，所以CyclicBarrier能处理更为复杂的业务场景，例如计算错误时可用重置计数器重新计算。CyclicBarrier还提供了其他有用的方法，例如getNumberWaiting可以获取CyclicBarrier阻塞的线程数量，isBroken方法用来了解阻塞的线程是否被中断。</p></li></ul></li><li><p><strong>Semaphore</strong></p><p>Semaphore是信号量，用来控制同时访问特定资源的线程数量，它通过协调各个线程以保证合理的使用公共资源。信号量可以用于流量控制，特别是公共资源有限的应用场景，比如数据库连接。Semaphore的构造方法参数接收一个int型数字，表示可用的许可证数量，即最大并发数。使用acquire获得一个许可证，使用release方法归还许可证，还可以用tryAcquire尝试获得许可证。</p></li><li><p><strong>Exchanger</strong></p><p>Exchanger交换者是用于线程间协作的工具类，用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange方法它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时这两个线程就可以交换数据，将本线程生产出的数据传递给对方。应用场景包括遗传算法、校对工作等。</p></li></ul><hr><h2 id="线程池和Executor框架"><a href="#线程池和Executor框架" class="headerlink" title="线程池和Executor框架"></a>线程池和Executor框架</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li><p><strong>线程池的好处</strong></p><ul><li>降低资源消耗，通过重复利用已创建的线程降低线程创建和消耗的开销。</li><li>提高响应速度，当任务到达时，任务可以不需要等到线程创建就可以立即执行。</li><li>提高线程的可管理性，线程是稀缺资源，如果无限制地创建不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li></ul></li><li><p><strong>线程池的工作流程</strong></p><ul><li>线程池判断核心线程池是否已满，如果不是则创建一个新的工作线程来执行任务（工作线程数&lt;corePoolSize，这一步需要获取全局锁）。</li><li>如何核心线程池已经满了，判断工作队列是否已满，如果没有就将任务存储在工作队列中（工作线程数&gt;=corePoolSize）。</li><li>如果工作队列满了，判断线程池是否已满，如果没有就还是创建一个新的工作线程来执行任务（工作线程数&lt;maximumPoolSize）。</li><li>如果线程池已满，就按照线程池的拒绝执行策略来处理无法执行的任务（工作线程数&gt;maximumPoolSize）。</li></ul><p>线程池采取这种设计思路是为了在执行execute方法时尽可能地避免获取全局锁，在线程池完成预热之后，即当前工作线程数&gt;=corePoolSzie时，几乎所有的execute方法都是执行步骤2，不需要获取全局锁。</p></li><li><p><strong>工作线程的任务</strong></p><p>线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务之后，还会循环获取工作队列中的任务来执行。线程池中的线程执行任务分为两种情况：①在execute方法中创建一个线程时会让这个线程执行当前任务。②这个线程执行完任务之后，就会反复从阻塞工作队列中获取任务并执行。</p></li><li><p><strong>ThreadPoolExecutor创建参数</strong></p><ul><li>corePoolSize：线程池的基本大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池的基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有的基本线程。</li><li>workQueue：工作队列，用于保存等待执行任务的阻塞队列，可以选择以下的阻塞队列：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockQueue等。</li><li>maximumPoolSize：线程池允许的最大线程数，如果工作队列已满，并且创建的线程数小于最大线程数，则线程池还会创建新的线程执行任务，如果使用的时无界阻塞队列该参数是无意义的。</li><li>threadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li><li>handler：拒绝策略，当队列和线程池都满了说明线程池处于饱和状态，那么必须采取一种拒绝策略处理新提交的任务，默认情况下使用AbortPolicy直接抛出异常，CallerRunsPolicy表示重新尝试提交该任务，DiscardOldestPolicy表示抛弃队列里最近的一个任务并执行当前任务，DiscardPolicy表示直接抛弃当前任务不处理。也可以自定义该策略。</li><li>keepAliveTime：线程活动的保持时间，线程池工作线程空闲后保持存活的时间，所以如果任务很多，且每个任务的执行时间较短，可以调大时间提高线程的利用率。</li><li>unit：线程活动保持时间的单位，有天、小时、分钟、毫秒、微秒、纳秒。</li></ul><p><strong>当线程池的核心线程数量过大或者过小的影响</strong></p><p>当线程池中核心线程数量过大时，线程与线程之间会争取CPU资源，这样就会导致上下文切换。过多的上下文切换会增加线程的执行时间，影响了整体执行的效率；</p><p>当线程池中的核心线程数量过少时，如果统一时间有大量任务需要处理，可能会导致大量任务在任务队列中排队等待执行，甚至会出现队列满了之后任务无法执行的情况，或者大量任务堆积在任务队列导致内存溢出（OOM）。</p></li><li><p><strong>如何向线程池提交任务</strong></p><p>可以使用execute和submit方法向线程池提交任务。execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功了。submit方法用于提交需要返回值的任务，线程池会返回一个Future类型的对象，通过该对象可以判断任务是否执行成功，并且可以通过该对象的get方法获取返回值，get方法会阻塞当前线程直到任务完成，带超时参数的get方法会在指定时间内返回，这时任务可能还没有完成。</p></li><li><p><strong>关闭线程池的原理</strong></p><p><strong>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，</strong>它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。<strong>区别是shutdown只是将线程池的状态设置为SHUTWDOWN状态，正在执行的任务会继续执行下去，没有被执行的则中断。而shutdownNow则是将线程池的状态设置为STOP，正在执行的任务则被停止，没被执行任务的则返回。</strong></p><p>只要调用了这两个方法中的一个，isShutdown方法就会返回true，当所有任务都已关闭后才表示线程池关闭成功，这时调用isTerminated方法会返回true。通常调用shutdown方法来关闭线程池，如果任务不一定要执行完则可以调用shutdownNow方法。</p></li><li><p><strong>合理设置核心线程数</strong></p><p>首先可以从以下角度分析：①任务的性质：CPU密集型任务、IO密集型任务和混合型任务。②任务的优先级：高、中和低。③任务的执行时间：长、中和短。④任务的依赖性：是否以来其他系统资源，如数据库连接。</p><p>性质不同的任务可以用不同规模的线程池分开处理，CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型任务如果可以拆分将其拆分为一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大那么分解后的吞吐量将高于串行执行的吞吐量，如果相差太大则没必要分解。</p><p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue处理。</p><p>执行时间不同的任务可以交给不同规模的线程池处理，或者使用优先级队列。</p><p>以来数据库连接池的任务，由于线程提交SQL后需要等待数据库返回的结果，等待的时间越长CPU空闲的时间就越长，因此线程数应该尽可能地设置大一些提高CPU的利用率。</p><p>建议使用有界队列，能增加系统的稳定性和预警能力，可以根据需要设置的稍微大一些。</p><p><strong>总结：</strong></p><p>由于CPU密集型任务的性质，导致CPU的使用率很高，如果线程池中的核心线程数量过多，会增加上下文切换的次数，带来额外的开销。</p><p>CPU密集型：核心线程数=CPU核心数(或 核心线程数=CPU核心数+1)</p><p>对于I/O密集型任务，由于I/O密集型任务CPU使用率并不是很高，可以让CPU在等待I/O操作的时去处理别的任务，充分利用CPU。</p><p>I/O密集型：核心线程数=2*CPU核心数（或 核心线程数=CPU核心数/（1-阻塞系数））</p></li><li><p>线程池的监控</p><ul><li>taskCount，线程池需要执行的任务数量。</li><li>completedTaskCount，线程池在运行过程中已经完成的任务数量，小于或等于taskCount。</li><li>largestPoolSize，线程池里曾经创建过的最大线程数量，通过这个数据可以知道线程池是否曾经满过，如果该数值等于线程池的最大大小表示线程池曾经满过。</li><li>getPoolSize，获取线程池的线程数量，如果线程池不销毁的化线程池里的线程不会自动销毁，所以这个数值只增不减。</li><li>getActiveCount，获取活动的线程数。</li></ul><p>通过扩展线程池进行监控，可以继承线程池来自定义，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前来执行一些代码进行监控，例如监控任务的平均执行时间、最大执行时间和最小执行时间。</p></li><li><p><strong>使用无界阻塞队列对线程池的影响</strong></p><p>①当线程池中的线程数达到corePoolSize之后新任务将在无界队列中等待，因此线程池中的数量不会超过corePoolSize。②因此使用无界队列时maximumPoolSize和keepAliveTime均是无效参数。③由于使用无界队列，线程池不会拒绝任务。</p></li></ul><hr><h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><ul><li><p><strong>Executor框架的调度模型</strong></p><p>在HotSpot VM的线程模型中，Java线程被一对一映射为本地操作系统线程，Java线程启动时会创建一个本地操作系统线程，当该Java线程终止时，这个操作系统线程也会被回收，操作系统会调度所有线程并将它们分配给可用的CPU。</p><p>Executor框架的调度模型是一种两级调度模型。在上层，Java多线程程序通常把应用分解为若干任务，然后使用用户级的调度器即Executor框架将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。</p></li><li><p><strong>Executor框架的结构</strong></p><p>主要由以下三部分组成：</p><p>①任务，包括被执行任务需要实现的接口，Runnable或Callable接口。</p><p>②任务的执行，包括任务执行机制的核心接口Executor（Executor框架的基础，将任务的提交和执行分离开来），以及继承自Executor的ExecutorService接口（ThreadPoolExecutor和ScheduledThreadPoolExecutor）。</p><p>③异步计算的结果，包括接口Future和实现Future接口的FutureTask类。当我们把Runnable接口或Callable接口的实现类提交（submit）给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会向我们返回一个FutureTask对象。</p></li><li><p><strong>ThreadPoolExecutor</strong></p><p>ThreadPoolExecutor是Executor框架最核心的类，是线程池的实现类，主要有三种。</p><p>①FixedThreadPool，可重用固定线程数的线程池，corePoolSize和maximumPoolSize都被设置为创建时的指定参数nThreads，当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止，这里将其设置为0L表示多余空闲线程将被立即终止。该线程池使用的工作队列是无界阻塞队列LinkedBlockingQueue（队列容量为Integer的最大值）。适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，适用于负载比较重的服务器。</p><p>②SingleThreadExecutor，使用单个线程的线程池，corePoolSize和maximumPoolSize都被设置为1，其他参数和FiexedThreadPool相同。适用于需要保证顺序执行各个任务，并且在任意时间点不会有多个线程是活动的的应用场景。</p><p>③CachedThreadPool，一个根据需要创建线程的线程池，corePoolSize被设置为0，maximumPoolSize被设置为Integer的最大值，将keepAliveTime设为60L，意味着空闲线程等待时间最长为1分钟。该线程池使用的工作队列是没有容量的SynchronousQueue，但是maximumPoolSize设为Integer最大值，如果主线程提交任务的速度高于线程处理的速度，线程池会不断创建新线程，极端情况下会创建过多线程而耗尽CPU和内存资源。适用于执行很多短期异步任务的小程序，或者负载较轻的服务器。</p></li><li><p><strong>ScheduledThreadPoolExecutor</strong></p><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，主要用来在给定的延迟之后运行任务，或者定期执行任务。其功能与Timer类似，但是功能更加强大、更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造方法中指定多个后台线程数。为了实现周期性的执行任务，使用DelayQueue作为工作队列，获取任务和执行周期任务后的处理都不同，主要有两种。</p><p>①ScheduledThreadPool：包含若干线程的ScheduledThreadPoolExecutor，创建固定线程个数的线程池。适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程数量的应用场景。</p><p>②SingleThreadScheduledExecutor：只包含一个线程的ScheduledThreadPoolExecutor，适用于单个后台线程执行周期任务，同时需要保证顺序执行各个任务的应用场景。</p><ul><li><p><strong>ScheduledThreadPoolExecutor的原理</strong></p><p>将待调度任务放入一个DelayQueue中，调度任务主要有三个参数，long类型的time表示这个任务将要被执行的具体时间，long类型的sequenceNumber表示这个任务被添加到线程池的序号，long类型的period表示任务执行时间间隔。DelayQueue封装了一个PriorityQueue，队列按照time进行排序，如果time相同则比较sequenceNumber，越小的排在前面，即如果两个任务的执行时间相同，先提交的任务先被执行。</p></li></ul></li><li><p><strong>Runnable接口和Callable接口的区别</strong></p><p>两个接口的相同点是Runnable接口和Callable接口的实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行，不同点是Runnable不会返回结果，Callable可以返回结构。除了可以自己创建Callable接口的对象外，还可以使用工厂类Executors将一个Runnable对象包装为一个Callable对象。</p></li><li><p><strong>FutureTask</strong></p><p>FutureTask除了实现了Future接口之外，还实现了Runnable接口。因此FutureTask可以交给Executor执行，也可以由调用线程直接执行即调用FutureTask对象的run方法，根据run方法被执行的时机，FutureTask可以处于三种状态：①未启动，当FutureTask对象被创建，且没有执行run方法之前的状态。②已启动，当run方法处于被执行过程中，FutureTask对象处于已启动状态。③已完成，当run方法执行后正常完成或执行run方法中抛出异常或调用，cancel方法取消时，FutureTask对象处于已完成状态。</p><p>当处于未启动或已启动状态时，get方法将阻塞线程，当处于已完成状态时会立即返回结果或抛出异常。当处于未启动状态时，cancel方法会导致此任务永远不会执行，当处于已启动状态时，执行cancel(true)方法，将以中断执行此任务的方式来试图停止该任务，执行cancel(false)方法，将不会对正在执行此任务的线程产生应用，当处于已完成状态时，cancel方法返回false。</p><ul><li><p><strong>FutureTask的实现原理</strong></p><p>FutureTask的实现基于AQS，基于合成复用的设计原则，FutureTask声明了一个内部私有的继承于AQS的子类Sync，对Future的所有公有方法的调用都会委托给这个内部的子类。AQS被作为模板方法模式的基础类提供给FutureTask的内部子类Sync，这个内部的子类只需要实现状态检查和更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared和tryReleaseShared方法来检查和更新同步状态。</p></li><li><p><strong>FutureTask的get方法原理</strong></p><p>①调用AQS的acquireSharedInterruptibly方法，首先回调在子类Sync中实现的tryAcquireShared方法来判断acquire操作是否可以成功。acquire操作成功的条件为：state为执行完成状态或取消状态，且runner不为null。②如果成功get方法立即返回，如果失败则到线程等待队列中去等待其他线程执行release操作。③当其他线程执行release操作唤醒当前线程后，当前线程再次执行tryAcquireShared将返回1，当前线程将理课线程等待队列并唤醒它的后继线程。④返回最终结果或抛出异常。</p></li><li><p><strong>FutureTask的run方法原理</strong></p><p>①执行在构造方法中的指定任务。②以原子方式更新同步状态，如果操作成功就设置代表计算结果的变量result的值为Callable的call方法的返回值，然后调用AQS的releaseShared方法。③AQS的releaseShared方法首先回调子类Sync中实现的tryReleaseShared来执行release操作（设置运行任务的线程runner为null，然后返回true），然后唤醒线程等待队列的第一个线程。④调用FutureTask的done方法。</p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
            <tag> 同步 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="2021/03/16/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/03/16/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>JMM的设计是为了屏蔽各种硬件和操作系统的内存方法差异，以实现Java程序在各种平台下都能达到一直的内存访问效果。在此之前的主流程序语言，例如C、C++等直接使用物理硬件和操作系统的内存模型，因此不同平台上内存模型的差异可能导致程序在一套平台上并发正常运行，而在另一套平台经常出错。</p><p>JMM必须定义得足够严谨，才能让Java的并发内存访问操作不会产生歧义；但又必须定义得足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性来获取更好的执行执行速度。直到JDK5，即实现了JSR-133之后，Java内存模型才算成熟完善了起来。</p><hr><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a><strong>主内存与工作内存</strong></h3><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。此处的变量和Java语言中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为局部变量和方法参数是线程私有的，不会被共享，也就自然不存在竞争问题。为了获得更好的执行效率，Java内存模型没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器是否要进行调整代码执行顺序这类优化措施。</p><p>Java内存模型规定了所有变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作空间中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><ul><li><p><strong>内存间的交互操作</strong></p><p>关于主内存与工作内存之间的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型定义了以下8种操作来完成。Java虚拟机实现时必须保证这些操作是原子性的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台有例外）。</p><ul><li><strong>lock（锁定）：</strong>作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li><strong>unlock（解锁）：</strong>作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定。</li><li><strong>read（读取）：</strong>作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load操作使用。</li><li><strong>load（载入）：</strong>作用于工作内存的变量，它把read操作从主存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use（使用）：</strong>作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码执行时会执行这个操作。</li><li><strong>assign（赋值）：</strong>作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store（存储）：</strong>作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li><strong>write（写入）：</strong>作用于主内存的变量，它把store操作从工作内存取到的变量值放入主内存的变量中。</li></ul><p>如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。注意Java内存模型只要求这两种操作必须按顺序执行，但不要求是连续执行，也就是说read与load之间、store和write之间是可插入其他指令的，如对主内存的变量a、b进行访问时，一种可能的顺序是read a、read b、load b、load a。</p><p>除了这8种操作外，Java内存模型还规定了必须满足的一些规则：</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主存读取出来了但工作内存不接受，或者工作内存发起了回写但主内存不接受的情况。</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程在没有发生过任何assign操作的情况下把数据从线程的工作内存同步回主内存。</li><li>一个新的变量只能在主内存中诞生，但不允许在工作内存中直接使用一个未被初始化（load和assign）的变量，即对一个变量实施use或store操作之前，必须先执行assign和load。</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定就不允许对其执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）。</li></ul><p>这8种内存访问的操作和这些规则，加上针对volatile的一些特殊规定，就能准确地描述出Java程序中哪些内存访问操作在并发下才是安全的。这种定义十分严谨但是过于复杂，之后Java将内存操作简化为lock、unlock、read和write四种，但这只是语言描述上的等价化简，Java内存模型的基础设计并未改变。</p></li></ul><hr><h3 id="针对volatile的特殊规则"><a href="#针对volatile的特殊规则" class="headerlink" title="针对volatile的特殊规则"></a>针对volatile的特殊规则</h3><ul><li><p><strong>作用：</strong></p><p>关键字volatile是Java虚拟机提供的最轻量级的同步机制，Java内存模型为volatile定义了一些特殊的访问规则。当一个变量被定义为volatile之后，它具备两种特性：</p><ul><li><p><strong>保证此变量对所有线程的可见性</strong></p><p>可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是立即可以得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。</p><p>volatile变量在各个线程的工作内存中不存在一致性问题（从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但是由于每次使用前都要刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java中的运算操作符并非原子操作，这导致volatile变量的运算在并发下仍是不安全的。</p><ul><li><p><strong>静态变量i执行多线程i++的不安全问题</strong></p><p>通过反编译会发现一个自增语句是由4条字节码指令构成的，按顺序依次为getstatic、iconst_1、iadd、putstatic，当getstatic把i的值取到操作栈顶时，volatile关键字保证了i的值在此刻是正确的，但是在执行iconst_1、iadd这些指令时，其他线程可能已经改变了i的值，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的i值同步回了主内存之中。 </p></li></ul><p>注意：即使编译出来只有一条字节码指令也不能意味着这条指令就是一个原子操作，一条字节码指令在解释执行时，解释器要运行很多行代码才能实现它的语义。如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令。</p><p>​    由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，仍然需要使用锁（synchronized、juc中的锁或原子类）来保证原子性：</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他状态变量共同参与不变约束。</li></ul></li><li><p><strong>禁止指令重排序优化</strong></p></li></ul><p>普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。在同一个线程的方法执行过程中无法感知到实际顺序与代码顺序的不同，这就是Java内存模型中描述的”线程内as-if-serial语义“。</p><p>使用volatile的变量进行写操作，汇编指令操作是带有lock前缀的，这个操作的作用相当于一个内存屏障，后面的指令不能重排到内存屏障之前的位置。只有一个处理器时不需要使用内存屏障，但如果有两个或更多的处理器访问同一块内存，且其中有一个在观测另一个，就需要使用内存屏障来保证一致性了。</p><p>使用lock前缀的指令在多核处理器中会引发两件事：</p><ul><li>将当前处理器缓存行的数据写回到系统内存</li><li>这个写回内存的操作会使其他在CPU里缓存了该内存地址的数据无效。</li></ul><p>这种操作相当于对缓存中的变量做了一次store和write操作，可以让volatile变量的修改对其他处理器立即可见。</p></li><li><p><strong>volatile的内存语义</strong></p><p>从JSR-133开始，volatile变量的写-读可以实现线程之间的通信。从内存语义的角度来说，volatile的写-读与锁的释放-获取具有相同的内存效果。</p><ul><li><p><strong>volatile写的内存语义：</strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p></li><li><p><strong>volatile读的内存语义：</strong>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</p></li></ul><p>线程A写一个volatile变量，实质上是线程A向接下来要读这个volatile变量的某个线程发出了（其对共享变量所修改的）消息。线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。线程A写一个volatile变量，线程B读一个volatile变量，实质上是线程A通过主内存向线程B发送消息。</p></li><li><p><strong>volatile指令重排序的特点</strong></p><ul><li>当第二个操作是volatile写时，不管第一个操作是什么都不能重排序，这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li></ul></li><li><p>当第一个操作是volatile读时，不管第二个操作是什么都不能重排序，这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p></li><li><p>当第一个操作是volatile写，第二个操作是volatile读时不能重排序。</p></li><li><p><strong>volatile的内存屏障插入策略</strong></p><ul><li><p>在每个volatile写操作之前插入一个Store Store屏障,禁止之前的普通写和之后的volatile写重排序。</p></li><li><p>在每个volatile写操作之后插入一个Store Load屏障，防止之前的volatile写与之后可能有的volatile读/写重排序，也可以在每个volatile变量读之前插入该屏障，考虑到一般是读多于写所以选择用这种方式提升执行效率，也可以看出JMM在实现上的一个特点：首先确保正确性，然后再去追求效率。</p></li><li><p>在每个volatile读操作之后插入一个Load Load屏障，禁止之后的普通读操作和之前的volatile读重排序。</p></li><li><p>在每个volatile读操作之后插入一个Load Store屏障，禁止之后的普通写操作和之前的volatile读重排序。</p></li></ul></li><li><p><strong>关于volatile的优化</strong></p><p>可以通过追加字节的方式优化性能，例如JDK7中的队列集合类LinkedTransferQueue就是使用了追加字节的方式来优化队列出队和入队的性能。由于一些处理器的高速缓存行是64个字节宽，不支持部分填充缓存行，如果队列的头节点和尾节点都不足64字节，当一个处理器试图修改头节点时就会将整个缓存行锁定，那么在缓存一致性的作用下会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队又会频繁修改头节点和尾节点，因此多处理器情况下会严重影响队列的入队和出队效率。追加到64字节后就可以填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使它们的操作不会互相锁定。    </p><p>但以下两种场景不应该使用这种方式：①缓存行非64字节宽的处理器。②共享变量不会被频繁地写，因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定性能消耗。如果共享变量不被频繁写，锁的几率很小没有必要避免互相锁定。不过这种追加字节的方式在Java7可能不生效，因为Java7可以淘汰或重新排列无用字段，需要使用其他追加字节的方式。</p></li><li><p><strong>JSR-133增强volatile语义的原因</strong></p><p>在旧的内存模型中，虽然不允许volatile变量之间重排序，但允许volatile变量与普通变量重排序，可能导致内存不可见问题。在旧的内存模型中volatile的写-读没有锁的释放-获取所具有的内存语义，为了提供一种比锁更轻量级的线程通信机制，严格限制了编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语义这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p></li><li><p>关于指令重排序的补充</p><ul><li><p><strong>指令重排序的概念</strong></p><p>重排序指从源代码到指令序列的重排序，在执行程序时为了提高性能，编译器和处理器通常会对指令进行重排序，重排序分为三种类型：</p><ul><li><p>编译器优化的重排序：编译器在不改变单线程程序语义的前提下可以重新安排语句的执行顺序。</p></li><li><p>指令级并行的重排序：现代处理器才以来指令级并行技术ILP来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li><li><p>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作操作看上去可能是乱序执行。</p></li></ul></li><li><p><strong>指令重排序的问题</strong></p><p>从Java源代码到最终实际执行的指令序列，会分别经历编译器优化重排序、指令级并行重排序和内存系统重排序，这些重排序可能会导致多线程程序出现内存可见性问题。</p><ul><li>对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令（一组用于实现对内存操作顺序限制的处理器指令），通过内存屏障指令来禁止特定类型的处理器重排序。</li></ul><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的可见性内存保证。</p></li></ul></li></ul><hr><h3 id="针对long和double类型变量的特殊规则"><a href="#针对long和double类型变量的特殊规则" class="headerlink" title="针对long和double类型变量的特殊规则"></a>针对long和double类型变量的特殊规则</h3><p>Java内存模型要求lock、unlock、read、load、assign、use、store、write这八种操作都具有原子性，但是对于64位的数据类型（long和double），在模型中定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read和write四个操作的原子性，这就是”long和double的非原子性协定“。</p><p>如果有多个线程共享一个未声明为volatile的long或double类型变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既不是原值，也不是其他线程修改值的代表了”半个变量“的数值。这种情况很罕见，但带对于一些32位的Java虚拟机确实存在非原子性访问的风险。</p><hr><h3 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h3><ul><li><p><strong>原子性</strong></p><p>由Java内存模型直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，基本数据类型的访问读写都是具备原子性的（例外就是long和double的非原子性协定）。</p><p>如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足需求，尽管虚拟机还没有把lock和unlock开放给用户使用，但却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块synchronized关键字，因此synchronized具有原子性。</p><ul><li><p><strong>原子操作</strong></p><p>原子操作即不可被中断的一个或一系列操作，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p><ul><li><p>通过总线锁定保证原子性：如果多个处理器同时对共享变量进行读改写操作（例如i++），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子性的，操作完之后共享变量的值会和期望的不一样。例如i=1，进行两次i++操作，但是结果可能为2。这是因为多个处理器同时从各自的缓存读取变量i，分别进行加1操作，然后分别写入系统内存中。如果想要保证读改写操作的原子性，就必须保证CPU1读改写共享变量时CPU2不能操作缓存了该共享变量内存地址的缓存。处理器使用总线锁来解决这个问题，总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞，该处理器就可以独占共享内存。</p></li><li><p>通过缓存锁定来保证原子性：同一时刻只需要保存对某个内存地址的访问是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间其他处理器不能操作其他内存地址的数据，开销比较大，目前的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。频繁使用的内存会缓存在处理器的高速缓存里，原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁。缓存锁定是指内存区域如果被缓存在处理器的缓存行中并且在Lock操作期间被锁定，那么当它执行锁操作回写内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作原子性，因为缓存一致性会阻止同时修改由两个以上处理器缓存的内存区域，当其他处理器回写已被锁定的缓存行数据时会使缓存行无效。</p></li></ul></li><li><p><strong>Java中的原子操作实现</strong></p><p>Java中可以通过锁和循环CAS的方式来实现原子操作。</p><ul><li><p>锁机制保证了只有获得锁的线程才能操作锁定的内存区域，JVM内部实现了很多锁，除了偏向锁JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步代码块时使用循环CAS方式获取锁，退出时使用循环CAS释放锁。</p></li><li><p>JVM中的CAS操作利用了处理器提供的交换指令CMPXCHG实现，自旋CAS的基本思路就是循环进行CAS操作直到成功为止。从Java1.5开始JDK的并发包里提供了一些类来支持原子操作，例如AtomicBoolean（用原子方式更新的boolean值），AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值），这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。</p></li></ul></li></ul></li><li><p><strong>可见性</strong></p><p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新，因此volatile保证了多线程操作时变量的可见性。</p><p>除了volatile之外，Java还有两个关键字能实现可见性，分别是synchronized和final。</p><ul><li><p><strong>synchronized：</strong>同步块的可见性是指”对一个变量执行unlock之前，必须先把此变量同步回主内存中（执行store、write操作）。</p></li><li><p><strong>final：</strong>final的可见性是指被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this的引用传递出去（this引用逃逸是一件很危险的事，其他线程有可能通过这个引用访问到初始化了一般的对象），那么在其他线程中就能看见final字段的值。</p><ul><li><p><strong>final域的重排序规则</strong></p><p>对于final域，编译器和处理器要遵守两个重排序规则：①在构造方法内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。②初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。 </p></li><li><p><strong>写final域重排序的实现原理</strong></p><p>写final域的重排序规则禁止把final域的写重排序到构造方法之外，这个规则的实现包含以下两方面：①JMM禁止编译器把final域的写重排序到构造方法之外。②编译器会在final域的写之后，构造方法的return之前，插入一个Store Store屏障，这个屏障禁止把final域的写重排序到构造方法之外。</p><p>写final域的重排序可以确保在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</p></li><li><p><strong>读final域重排序的实现原理</strong></p><p>读final域的重排序规则是，在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（仅针对处理器）。编译器会在读final域操作的前面插入一个Load Load屏障。</p><p>初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（例如alpha处理器），因此该规则就是专门针对这种处理器的。</p><p>读final域的重排序规则可以确保在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</p></li><li><p><strong>final域为引用对象时重排序的特点</strong></p><p>对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在构造方法内对一个final引用的对象的成员域的写入，与随后在构造方法外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。 </p></li><li><p><strong>final语义在X86处理器的实现原理</strong></p><p>写final域的重排序规则是要求编译器在final域的写之后，构造方法return之前插入一个Store Store屏障，读final域的重排序规则是要求编译器在读final域的操作前插入一个Load Load屏障。</p><p>由于X86处理器不会对写-写操作重排序，所以写final域需要的Store Store屏障会被省略。同样，由于X86处理器不会对存在间接依赖关系的操作做重排序，所以在X86处理器中读final域需要的Load Load屏障也会被省略掉。也就是说，X86处理器不会对final域的读/写插入任何内存屏障。</p></li><li><p><strong>JSR133增强final语义的原因</strong></p><p>在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如一个线程看到一个int类型final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值会发现值变为1（被某个线程初始化之后的值）。最常见的例子就是旧的Java内存模型中String的值可能会改变。</p><p>为了修复该漏洞，JSR-133通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造方法中没有逸出），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造方法中被初始化之后的值。</p></li></ul></li></ul></li><li><p><strong>有序性</strong></p><p>Java内存模型的有序性可以总结为：在本线程内观察所有操作是有序的，在一个线程内观察另一个线程，所有操作都是无序的。前半句是指”线程内的as-if-serial语义“，后半句是指“指令重排序”和”工作内存与主内存同步延迟“现象。</p><p>Java提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由”一个变量在同一个时刻只允许一条线程对其进行lock操作“这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p></li></ul><hr><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><ul><li><p><strong>数据依赖性</strong></p><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时两个操作之间就存在数据依赖性。数据依赖分为以下三种类型：①写后读，写一个变量之后再读这个位置。②读后写，读一个变了之后再写这个变量。③写后写，写一个变量之后再写这个变量。</p><p>上述三种情况只要重排序两个操作的执行顺序，程序的执行结果就会被改变。编译器和处理器为了性能优化可能会对操作重排序，在重排序时会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序。这里说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p></li><li><p><strong>as- if-serial</strong></p><p>as-if-serial指不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵循该语义。为了遵循该语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但如果操作之间不存在数据依赖关系，这些操作就可能被重排序。</p><p>as-if-serial语义将单线程保护了起来，遵循as-if-serial语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按照程序的顺序执行的。as-if-serial使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p><p>as-if-serial实例：例如计算一个圆的面积，A操作给半径赋值，B操作给圆周率赋值，C操作计算圆的面积。由于C依赖于A和B因此不会被重排到A和B的前面，但A和B之间没有数据依赖关系，所以程序的执行顺序可以是ABC或BAC，结果是一样的。</p></li><li><p><strong>控制依赖关系对指令重排序的影响</strong></p><p>当代码中存在控制依赖性时（例如A操作判断某标志位，B操作根据A的结果执行对应逻辑），会影响指令序列执行的并行度。为此编译器和处理会采用猜测执行来克服控制相关性对并行度的影响，可以提前计算出值保存到名为重排序缓冲的硬件缓存中，如果之前的控制条件满足就执行对应操作。</p><p>在单线程程序中，对存在控制依赖的操作重排序并不会改变程序的执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）。但在多线程程序中，对存在控制依赖的操作从排序可能会改变程序的执行结果。</p></li></ul><hr><h3 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h3><p>如果Java内存模型中所有有序性都依靠volatile和synchronized来完成，许多操作会变得过于繁杂，Java语言中有一个先行发生原则（happens-before），这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，可以通过几条简单规则解决并发环境下两个操作之间可能存在冲突的所有问题。</p><p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，其实就是说发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改内存中共享变量的值、发送了消息、调用了方法等。</p><p>Java内存模型存在一些天然的happens-before关系，这些happens-before关系无需任何同步器协助，可以在编码中直接使用。如果两个操作的关系不在此列，并且无法从这些规则推导出来，它们就没有顺序性保障，虚拟机可以对它们随意进行重排序。</p><ul><li><strong>程序次序规则</strong>：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。</li><li><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。</li><li><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。</li><li><strong>线程启动规则</strong>：线程对象的start方法先行发生于此线程的每一个动作。</li><li><strong>线程终止规则</strong>：线程中的所有操作都先行发生于对此线程的终止检测，可以通过join方法是否结束或isAlive方法的返回值等手段检测线程是否已经终止执行。</li><li><strong>线程中断规则</strong>：对线程interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过interruptted方法检测是否有中断发生。</li><li><strong>对象终结规则</strong>：一个对象的初始化完成先行发生于它的finalize方法的开始。</li><li><strong>传递性</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那么可以得出操作A先行发生于操作C的结论。</li></ul><p><strong>happens-before的重排序策略：</strong></p><p>JMM将happens-before要求禁止的重排序分为了下面两类：会改变程序执行结果的重排序和不会改变程序执行结果的重排序。JMM对这两种不同性质的重排序采取了不同的策略，对于会改变程序执行结果的重排序JMM要求编译器和处理器必须禁止这种重排序；对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种重排序）。</p><p>JMM向程序员提供happens-before规则能满足程序员的需求，其规则不但简单易懂而且也向程序员提供了足够强的内存可见性保证（有些内存保证性不一定真实存在，例如不改变执行结果的指令重排序对程序员是透明的）。</p><p>JMM对编译器和处理器的束缚已经尽可能地少，JMM遵循一个基本原则：只要不改变程序执行结果，编译器和处理器怎么优化都行。例如编译器分析某个锁只会单线程访问就消除该锁，某个volatile变量只会单线程访问就把它当作普通变量。</p><p><strong>happens-before的具体含义：</strong></p><p>①如果一个操作happens-before另一个操作，那么第一个操作的执行结果对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。这是JMM对程序员的承诺。</p><p>②两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序执行，如果重排序之后的执行结果与按照happens-before关系的执行结果一致，那么这种重排序是可以允许的。这是JMM对编译器和处理器的约束规则，JMM遵循一个基本原则：只要不改变程序执行结果，编译器和处理器怎么优化都行。JMM这么做的原因是程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行的语义不能被改变（即执行结果不能被改变）。因此happens-before关系的本质和as-if-serial一样。</p><p><strong>happens-before和as-if-serial的区别：</strong></p><p>as-if-serial语义保证单线程程序的执行结果不被改变，happens-before保证正确同步的多线程程序的执行结果不被改变。</p><p>as-if-serial语义给编写单线程程序的程序员创造了一种单线程程序是顺序执行的幻觉，happens-before关系给编写正确同步的多线程程序员创造了一种多线程程序是按照happens-before指定顺序执行的幻觉。</p><p>这两种语义的目的都是为了在不改变程序执行结果的前提下尽可能提高程序执行的并行度。</p><hr><h3 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h3><ul><li><p><strong>JMM内存屏障分类</strong></p><ul><li>Load Load，确保Load1的数据装载先于Load2及所有后续装载指令的装载。</li><li>Store Store，确保Store1数据对其他处理器可见（刷新到内存）先于Store2及所有后续存储指令的存储。</li><li>Load Store，确保Load1数据装载先于Store2及所有后续存储指令刷新到内存。</li><li>Store Load，确保Store1数据对其他处理器变得可见（刷新到内存）先于Load2及所有后续装载指令的装载。</li></ul><p>Store Load会使该屏障之间的所有内存访问指令（存储和装载指令）完成之后才执行该屏障之后的内存访问指令。该指令是一个“全能型”屏障，同时具备其他三个屏障的效果，现代的多处理器大多支持该屏障，执行该屏障的开销很昂贵，因为当前处理器通常要把写缓冲区的数据全部刷新到内存中。</p></li><li><p><strong>数据竞争和顺序一致性</strong></p><p>当程序未正确同步时就可能存在数据竞争。JMM规范对数据竞争的定义如下：在一个线程中写一个变量，在另一个线程中读同一个变量，而且写和读没有通过同步来排序。当代码中包含数据竞争时程序的执行往往产生违反直觉的结果，如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。</p><p>JMM对正确同步的多线程程序的内存一致性做了如下保证：如果程序是正确同步的，程序的执行将具有顺序一致性，即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。这里的同步是指广义上的同步，包括对常用同步用语（synchronized、volatile和final）的正确使用。</p><ul><li><p><strong>顺序一致性内存模型的特点</strong></p><p>顺序一致性内存模型是一个理想化的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：①一个线程中的所有操作必须按照程序的顺序来执行。②不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序，在顺序一致性的内存模型中，每个操作都必须原子执行并且立即对所有线程可见。</p><p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读/写操作。在任意时间点最多只能有一个线程可以连接到内存，当多个线程并发执行时，开关装置能把线程的所有内存读/写操作串行化（即在顺序一致性模型中所有操作之间具有全序关系）</p></li></ul></li><li><p><strong>未同步程序</strong></p><ul><li><p><strong>未同步程序的问题</strong></p><p>未同步程序在顺序一致性模型中虽然整体执行顺序无序但是所有线程都能看到一个一致的整体执行顺序。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p><p>JMM中没有这个保证，未同步程序在JMM中不但整体的执行顺序无序，并且所有线程看到的操作执行顺序也可能不一致。比如当前线程把写过的数据缓存到本地内存，在没有刷新到主内存前，这个写操作仅对当前线程可见。从其他线程的角度会认为这个写操作并没有执行，只有当前线程把本地内存中写过的数据刷新回主内存之后这个写操作才对其他线程可见，这种情况下当前线程和其他线程看到的操作执行顺序不一致。</p></li><li><p><strong>未同步程序的执行特性</strong></p><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值要么是之前某个线程写入的值，要么是默认值，JMM保证线程读操作读取到的值不会无中生有。为了实现最小安全性，JVM在堆上分配对象时首先会对内存空间进行清零，然后才会在上面分配对象（JVM内部同步这两个操作）。因此在已清零的内存空间分配对象时，域的默认初始化已经完成了。</p><p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型的执行结果一致，因为如果想要保证一致需要禁止大量的处理器和编译器优化，这对程序执行性能会有很大影响。而且未同步程序在顺序一致性模型中执行时整体是无序的，结果无法预知，因此保证未同步执行程序在两个模型的执行结果一致没什么意义。</p></li><li><p><strong>未同步程序在JMM和顺序一致性模型的执行区别</strong></p><ul><li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行。</li><li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。</li><li>JMM不保证对64位的long类型和double类型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</li></ul></li></ul></li><li><p><strong>总线的工作机制和好处</strong></p><p>在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称为总线事务。总线事务包括读事务和写事务。读事务从内存中传输数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中的一个或多个物理上连续的字，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其他的处理器和IO设备执行内存的读/写。</p><p>总线的工作机制可以把所有处理器对内存的访问以串行化的方式来执行，在任意时间点最多只能有一个处理器访问内存，这个特性确保了单个总线事务之中的内存读/写操作具有原子性。</p></li><li><p><strong>处理器内存模型的分类以及JMM对不同处理器的处理</strong></p><ul><li><p><strong>处理器分类</strong></p><ul><li>放松程序中写-读操作的顺序，由此产生了TSO内存模型。</li><li>在TSO的基础上继续放松程序中写-写操作的顺序，由此产生了PSO内存模型。</li><li>在TSO和PSO的基础上，继续放松程序中读-写（以两个操作之间不存在数据依赖性为前提）和读-读操作的顺序，由此产生了RMO和PowerPC内存模型。</li></ul></li><li><p><strong>JMM对不同处理器模型的处理</strong></p><p>不同的处理器模型，性能越好，内存模型的设计越弱，因为处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。由于常见的处理器内存模型比JMM要弱，Java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时由于各种处理器内存模型的强弱不同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不同。JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。</p></li></ul></li><li><p><strong>Java程序内存可见性保证的分类</strong></p><ul><li><p>单线程程序：单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在一致性模型中的执行结果相同。</p></li><li><p>正确同步的多线程程序：正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在一致性模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</p></li><li><p>未同步/未正确同步的多线程程序：JMM为它们提供了最小安全性保证，线程执行读取到的值要么是之前某个线程写入的值，要么是默认值，但不保证该值是正确的。</p></li></ul></li><li><p><strong>JSR-133对旧内存模型的修补</strong></p><ul><li>增强volatile的内存语义，旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。</li><li>增强final的内存语义，旧内存模型中多次读取同一个final变量的值可能会不相同，为此JSR-133为final增加了两个重排序规则。在保证final引用不会从构造方法逸出的情况下，final具有了初始化安全性。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JMM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合笔记</title>
      <link href="2021/03/15/Java%E9%9B%86%E5%90%88%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/15/Java%E9%9B%86%E5%90%88%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p><img src="https://img-blog.csdn.net/20180807200307368?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MzczMjg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>Java中的容器可以分为两类，Collection和Map。</p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>Collection用来存储独立的元素，其中包括List、Set和Queue。</p><ul><li><p><strong>List</strong></p><p>List是一种线性的列表结构，是一种有序集合，List中的元素可以根据索引进行查找、插入或删除。</p><ul><li><p><strong>ArrayList</strong></p><p>ArrayList是用数组实现的List，它与数组有很多同样的特点：①随机访问（相对顺序访问）效率高。②读快写慢，由于写操作涉及元素的移动，因此写操作效率低。</p><p>ArrayList的父类是AbstractList，该抽象类是大部分List的共同父类，它提供了一些基本的方法封装以及通用的迭代器实现。</p><p>ArrayList实现了RandomAcess接口，这是一个标记接口，没有提供任何方法。如果一个类实现了该接口，那么表示这个类使用索引遍历比迭代器更快。</p><p><strong>ArrayList有三个重要的成员变量和两个常量：</strong></p><ul><li><pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span></code></pre><p>elementData是ArrayList的数据域，transient表示它不会被序列化，但是ArrayList的序列化和反序列化都是可以成功的，这是因为ArrayList实现了Serializable接口的writeObject方法，该方法是private的，当ArrayList对象被序列化时，序列化方法会反射调用该方法来替代默认的序列化方式。</p><p>不使用elementData直接序列化是因为elementData是一个缓存数组，出于性能考虑，它通常会预留一些容量，当容量不足时会扩充容量，因此可能会有大量空间没有存储元素，采用这样的方式可以保证只序列化实际有值的那些元素而不需要序列化整个数组。</p></li><li><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span></code></pre><p>size表示当前List的长度，elementData的长度是大于等于size的，因为elementData是缓存数组，size变量标识了真正的List大小。</p></li><li><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>该成员变量继承自AbstractList，记录了ArrayList结构性变化的次数。在ArrayList中所有涉及结构变化的方法都会增加modCount的值，包括add()、remove()、addAll()、removeRange()及clear()。</p></li><li><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 8683452581122892189L<span class="token punctuation">;</span></code></pre><p>序列化版本UID，提供给序列化接口使用，该UID是为了维持序列化版本一致的。</p></li><li><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ARRAY_SIZE <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span></code></pre><p>数组长度的上限，Integer的最大值减8。</p></li></ul><p><strong>ArrayList有三个重载的构造器：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> </code></pre><p>其中<code>initialCapacity</code>表示初始化的elementData的长度，如果使用无参构造器，那么默认长度为10，当构造器的参数为集合时，它会把elementData的长度设置为集合的大小，然后再复制所有集合的元素到elementData。</p><p><strong>ArrayList的一些常用方法：</strong></p><ul><li><p><strong>indexOf/lastIndexOf/contains</strong></p><p>indexOf方法用于查询指定对象的索引index，实现的方式是对数组顺序遍历，调用指定元素的equals方法来比较，如果查询不到返回-1。</p><p>lastIndexOf与indexOf相反，是对数组倒序遍历。</p><p>contains方法直接调用indexOf方法，根据返回值是否为-1来判断查找的元素是否存在。</p></li><li><p><strong>set/add/addAll</strong></p><p>set方法的实现很简单，即替换数组里的对应索引处的值。</p><p>add和addAll方法实现相对复杂，首先要检查当前elementData的长度，如果添加后的大小超出了elementData的长度，那么需要对其容量进行修正。</p><p>修正的主要方法是两个：多余和不足。涉及的关键方法是grow(int)，该方法的int参数制定了“本次扩容所允许的最小容量”。grow的逻辑很简单，首先找出当前容量，把新容量设置为旧容量的1.5倍，如果新容量比可用最小容量要小，那么设置新容量为最小容量；如果新容量比极限容量常量要大，那么设置为极限容量常量和最大的整形数的较大值，接着使用该新容量初始化一个新的数组，将原有的elementData中的元素等位复制过去。</p></li><li><p>remove/removeAll/retainAll</p><p>remove方法有两种重载形式，当参数为int类型时表示移除位于指定index的数组，如果移除的不是最后一位，会调用System.arraycopy方法把index之后的数据向前移动一位，该方法的返回值指向被删除的元素，效率较低。当参数为Object类型时，表示移除指定的对象，该方法会遍历整个数组找到第一个与之相等的对象，该方法的返回值表示删除是否成功。</p><p>removeAll方法用于移除指定集合里的所有元素，与之相对的retainAll则是保留指定集合里存在的元素，这两个方法调用的都是batchRemove方法，区别是传入的参数一个为false一个为true。</p></li></ul><p>在使用迭代器遍历ArrayList时，不能修改元素，modCount是统计ArrayList修改的次数的，expectedModCount则是在迭代器初始化时记录modCount的值，每次访问新元素时都会调用检查方法检查modCount的值和expectedModCount是否相等，如果发现ArrayList被修改了就会抛出异常。</p></li><li><p><strong>LinkedList</strong></p><p>LinkedList的两个主要特性为：顺序访问和写快读慢。</p><p>LinkedList的父类是AbstractSequentialList，该抽象类继承自AbstractList，提供了顺序方法存储结构，它提供了get/set/add/addAll/remove等方法的迭代器实现，前提是必须实现Iterator接口。</p><p>LinkedList实现了Deque双向队列接口，因为队列的特性是FIFO，因此LinkedList可在尾部增加数组，在头部获取数据，还能操作头尾之间任意节点。</p><p><strong>LinkedList的主要成员变量和常量：</strong></p><ul><li><pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>用于标记序列的大小，因为链表由单个节点组成，除了统计节点个数以外没有方法获取size，所以提供了标识量来做记录，提高效率。</p></li><li><pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first<span class="token punctuation">;</span></code></pre><p>链表的头节点。</p></li><li><pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span></code></pre><p>链表的尾节点，同时提供头尾节点是为了实现Deque双向队列接口要求的功能。</p><p>可以发现所有成员变量都被transient修饰，序列化原理和ArrayList类似。</p></li><li><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 876323262645176354L<span class="token punctuation">;</span></code></pre><p>序列化版本UID。</p></li></ul><p><strong>LinkedList有两个重载的构造器：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> </code></pre><p>与ArrayList不同，链表无需初始化任何对象，所以无参构造器没有做任何操作，带参构造器调用了addAll方法。</p><p><strong>双向队列的实现：</strong></p><p>LinkedList是一个在双向队列基础上搭建的双向链表，双向链表的关键方法有：addFirst队首添加元素、addLast队尾添加元素、removeFirst队首移除元素、removeLast队尾移除元素。这些方法都是操作成员变量first和last来实现的，first和last都是Node类型。</p><p>Node的实现很简单：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        E item<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数据域，存储数据</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向后继节点</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向前驱节点</span>        <span class="token function">Node</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">,</span> E element<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>例如addLast方法，新建一个Node节点n，然后将前驱设置为当前的last，将last.next设置为n，即可完成需求，其他方法类似。</p><p><strong>getFirst/getLast/get方法：</strong></p><p>getFirst和getLast这两个方法分别用于取出队首或队尾的数据，直接返回fisrt.item和last.item即可实现。</p><p>get方法则不同，LinkedList是顺序存储结构，时间复杂度为O(n)。具体实现时进行了优化，如果index小于size的一半就正序变量，否则倒序遍历。</p><p><strong>set/add/addAll方法：</strong></p><p>与ArrayList不同，LinkedList的add方法比set方法更迅速，add方法的本质是在尾部增加一个节点，根据last指针很快就能实现，而set则需要遍历查找到指定节点并替换，addAll等价于调用多次add。</p><p><strong>removeFirst/removeLast/remove方法：</strong></p><p>removeFirst和removeLast方法用于移除首尾节点并返回数据，remove则是遍历到指定节点然后移除。remove方法的删除操作只需要修改待删除节点后继节点的pre和前驱节点的next指向，而不需要像ArrayList一样移动数据因此删除操作更高效。</p></li><li><p><strong>Vector和Stack</strong></p><p>Vector的实现和ArrayList基本一致，底层使用的也是数组，它和ArrayList的区别主要在于：</p><ul><li>Vector是线程安全的，Vector的所有public方法都是用了synchronized修饰。</li><li>Vector多了一个成员变量capacityIncrement，用于标明扩容的增量。</li></ul><p>Stack是Vector的子类，它的实现和Vector基本一致，与之相比它多提供了以下方法表达栈的含义：</p><ul><li>E push：入栈，相等于在末尾增加一个元素</li><li>E pop：出栈，移除末尾元素并返回</li><li>E peek：查看栈顶，返回最末尾元素</li><li>empty：用于检查栈是否空</li><li>search：查找元素的栈深度，栈顶元素深度为1，当找不到时返回-1。</li></ul></li><li><p><strong>总结</strong></p><ul><li>ArrayList是用数组实现的，数组本身是随机访问的结构。</li><li>LinkedList是顺序访问结构，在双向队列应用中得到体现。</li><li>Vector与ArrayList相比是线程安全的，而且容量增长策略不同。</li><li>Stack是Vector的子类，提供了一些具有栈特性的方法。</li></ul></li></ul></li><li><p><strong>Set</strong></p><p>Set是一个接口，这个接口约定了在其中的数据是不能重复的，主要的实现类有三个：</p><ul><li><p><strong>HashSet</strong></p><p>HashSet中不允许有重复的元素，HashSet中最多只能有一个null。</p><p>HashSet的内部是通过HashMap实现的，HashSet的部分源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>5024744406713321676L<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//底层使用HashMap来实现</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> HashMap<span class="token operator">&lt;</span>E<span class="token punctuation">,</span>Object<span class="token operator">></span> map<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义一个虚拟的Object对象作为HashMap的value值</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化一个空的HashMap，并使用默认初始容量16和加载因子0.75</span>    <span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>HashSet的底层是通过HashMap实现的，只是对于HashMap来说每个key有自己对应的value，而在HashSet中之关系key，所以所有的key都使用相同的value即PRESENT。由于PRESENT被定义为静态的，因此会被所有变量共享，节约空间。</p><p>HashSet是非线程安全的，如果想使用线程安全的Set，可以使用CopyOnWriteArraySet、Collections.synchronizedSet等。</p><p>HashSet不会维护数据插入的顺序，如果想维护插入顺序可以使用LinkedHashSet。</p><p>HashSet不会对数据排序，如果想对数据排序可以使用TreeSet。</p></li><li><p><strong>LinkedHashSet</strong></p><p>LinkedHashSet是对HashSet的扩展，可以维护数据插入的顺序，内部通过LinkedHashMap实现。</p></li><li><p><strong>TreeSet</strong></p><p>有HashSet的所有特性，而且支持排序，默认使用的是数据的自然顺序，可以在创建TreeSet时指定Comparator来对数据进行排序。</p><p>底层使用TreeMap来存储数据，将数据有序的功能交给了TreeMap。当使用add方法添加一个元素时，如果新增key是唯一会返回null，如果新增key已经存在了会返回对应的value值。</p></li></ul></li></ul><hr><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map用来存储key-value键值对，通过键来查找值，其中key是不能重复的。</p><ul><li><p><strong>HashMap</strong></p><ul><li><p><strong>Java8之前的HashMap</strong></p><p>在Java8之前，HashMap的底层实现是数组和链表，HashMap的主要成员变量包括：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//存储数据的核心成员变量</span><span class="token keyword">transient</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//键值对数量</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加载因子，用于决定table的扩容量</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span></code></pre><p>table是HashMap和核心成员变量，该数组用于记录HashMap的所有数据，它的每一个下标都对应一条链表，所有哈希冲突的数组都会被存放到同一条链表中，Entry&lt;K,V&gt;则是该链表的节点元素，包含以下成员变量：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//存放键值对中的key</span><span class="token keyword">final</span> K key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存放键值对中的value</span>V value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向下一个节点的引用</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//key对应的hashCode</span><span class="token keyword">int</span> hash<span class="token punctuation">;</span></code></pre><p>HashMap的核心实现是一个单向链表数组，所有方法都是通过操作该数组来完成的，HashMap规定了该数组的两个特性：</p><ul><li>在特定的时刻，根据需要来扩容。</li><li>长度始终保持为2的幂次方。</li></ul><p>在HashMap中，数据都是以键值对的形式存在的，键值所对应的hashCode将会作为其在数组里的下标，如果两个元素key的hashCode一样，就会被放到同一个下标中的相同链表上，为了使HashMap的查询效率尽可能高，要使键值的hashCode尽可能分散。</p><p><strong>HashMap的常量：</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认的初始化容量，必须为2的幂次方</span><span class="token keyword">static</span> <span class="token keyword">final</span> DEFAULT_INITIAL_CAPACITY<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最大容量，在构造器指定HashMap容量时做比较</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//默认加载因子，如果没有指定就会使用该常量</span><span class="token keyword">static</span> <span class="token keyword">final</span> DEFAULT_LOAD_FACTOR<span class="token operator">=</span><span class="token number">0.75f</span><span class="token punctuation">;</span></code></pre><p><strong>put方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果关键字为null，就存入table[0]</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//关键字不为null，就计算key的hash值</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据hash值和table的长度来计算下标</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存入table[i]</span>        Object k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果key已经存在，就更新其value值然后返回旧的value值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>           <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果key不存在，将集合修改值加1，然后添加节点</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>计算键值的hash方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object k<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> h <span class="token operator">&amp;&amp;</span> k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Hashing<span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>当处理String类型的数据时，直接调用对应方法来获取最终的hash值。</p><p>当处理其他类型数据时，提供一个相对于HashMap事例唯一不变的随机值hashSeed作为计算的初始量。</p><p>执行的异或和无符号右移操作是为了使hash值更加离散，减小哈希冲突。</p><p><strong>计算元素下标的indexFor方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h<span class="token operator">&amp;</span><span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>h是目标key的hash值，要根据该值计算下标，和数组的长度-1进行与操作可以保证计算后的index不会超过table的长度范围。</p><p>使用addEntry添加键值对时，如果键值对将要占用的位置不是null，并且size&gt;threshold，那么就会调用扩容方法<code>resize(2*table.length)</code>将长度扩大为原来的2倍，扩容之后会重新计算hash值和下标。</p><p><strong>扩容的resize方法：</strong></p><p>据新的容量newCapacity来确定新的扩容阈值threshold</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果当前容量已经达到了最大容量，就将阈值设置为Integer的最大值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//当阈值被设置为Integer最大值后，扩容就不会再触发</span>        threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//否则用新计算的容量×加载因子，和最大容量+1进行比较，取较小值作为新的扩容阈值</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//使用transfer方法重写计算当前节点转移到新数组后的下标</span>    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>重新计算下标的transfer方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历所有键值对，根据键的hash值和新的数组长度重新确定下标</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//判断是否需要哈希重构，如果key值不为null则重写计算hash值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>get方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//key为null就返回table[0]的数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token function">getForNullKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//根据key值找到对应节点，找到就返回value，否则返回null</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> entry <span class="token operator">=</span> <span class="token function">getEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null <span class="token operator">==</span> entry <span class="token operator">?</span> null <span class="token operator">:</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//key为null的get方法</span><span class="token keyword">private</span> V <span class="token function">getForNullKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//size为0代表链表为空，返回null</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历table[0]的链表，如果key为null返回对应value值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//没有找到，返回null</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据key的hash值获取value的get方法</span><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getEntry</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//size为0表示链表为空，返回null</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//key不为null提供hash方法计算hash值，否则hash值为0</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历该下标下链表的所有节点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>e <span class="token operator">!=</span> null<span class="token punctuation">;</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Object k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果hash值和key值都相同，找到了对应元素，返回其value值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token operator">==</span>hash<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token operator">=</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token operator">==</span> key<span class="token operator">||</span><span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//没有找到就返回null值</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>性能优化：</strong></p><p>HashMap执行写操作（put）时，比较消耗资源的是遍历链表，扩容数组；HashMap执行读操作（get）时，比较消耗资源的是遍历链表。</p><p>影响遍历链表的因素是链表的长度，在HashMap中，链表的长度由哈希冲突的频率决定。哈希冲突的频率又受数组长度决定，长度越长则冲突概率越小，但同时闲置的内存空间也越多。所以需要在时间和空间取得一个平衡点。哈希冲突的概率也受key的hash值影响，所以计算的hash值越离散，冲突概率越低。链表遍历中需要调用key值得equals方法，不合理的equals方法会导致HashMap效率低下甚至异常。</p><p>因此提高HashMap的效率可以从以下方面入手：</p><ul><li>根据业务需求测试出合理的加载因子，否则使用默认的0.75。</li><li>合理重写键值对象的equals方法和hashCode方法。</li></ul></li><li><p><strong>Java8之后的HashMap</strong></p><p>Java8的HashMap数据结构发生了较大的变化，之前的HashMap使用的是数组+链表的形式，新的HashMap使用的是数组+链表/红黑树的形式，虽然使用的依旧是table数组，但数据类型发生了变化，代表节点的Entry换成了Node：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//hash值</span>    <span class="token keyword">final</span> K key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//key值</span>    V value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//value值</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下一个Node节点的引用</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>put方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//调用putvalue方法</span><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过hash方法计算出key的hash值，作为参数传递</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据key的hash值存放元素</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span>     <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果table为空或没有元素时就进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//元素下标位置依旧通过hash和数组长度-1进行与操作得出，如果不存在就新创建一个节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果首节点和待插入元素得hash值和key值都一样，记录下来</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash<span class="token operator">==</span>hash<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果首节点是红黑树类型，使用putTreeVal方法增加一个树节点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//每一次都比较插入节点和当前节点的大小，待插入节点小就往左子树查找，否则往右子树查找，找到空位后执行两个方法：1 balanceInsert方法，平衡插入，一方面把节点插入红黑树，一方面对红黑树进行调整使之平衡。2 moveRootToFront，由于红黑树调整平衡后root节点可能变化，table里记录的节点不再是根节点，需要重置。</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果是链表节点，就遍历链表，根据hash值和key判断是否重复，决定是更新值还是新增节点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//遍历到了链表末尾，添加链表元素</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//如果达到了建树阈值，把链表重构位红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>                         <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//找到了和待插入元素相同key值的元素，记录下类并退出</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//说明待插入元素已在HashMap中，更新其value值就可以</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>             V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//修改次数增加1</span>    <span class="token comment" spellcheck="true">//如果节点数+1大于阈值，就要进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>计算hash值的方法：</strong></p><p>Java8也进行了哈希分散，但是计算过程简单了许多，如果key非空就将key的hashCode值的高低16位进行异或操作，这主要是为了让尽可能多的位参与运算，让结果中的0和1分布得更加均匀，从而降低哈希冲突的概率。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>resize方法：</strong></p><p>重新规划长度和阈值，如果长度发生了变化，部分数据节点也要重新排列。</p><ul><li><p><strong>重新规划长度</strong></p><p>如果size超出扩容阈值，进行扩容，把table的容量增加为之前的2倍。</p><p>如果新的table容量小于默认的初始化容量16，那么将table容量重置为16。</p><p>如果新的table容量大于等于最大容量，那么将阈值设为Integer的最大值，并且return终止resize过程，由于size不可能超过Integer最大值因此之后不会再发生扩容。</p></li><li><p><strong>重新排列数据节点</strong></p><p>如果节点为null，则不进行处理。</p><p>如果节点不为null且没有next节点，那么重新计算其hash值然后存入新的table中。</p><p>如果节点为树节点，那么调用树节点的split方法进行处理，该方法用于对红黑树调整，如果太小会退化回链表。</p><p>如果节点是链表节点，需要将链表拆分为hashCode超出旧容量的链表和未超出容量的链表。对于    <code>hash&amp;oldCap==0</code>的部分不需要做处理，反之需要放到新的下标位置上，新下标=旧下标+旧容量。</p></li></ul></li></ul></li><li><p><strong>LinkedHashMap</strong></p><ul><li><p><strong>Java8之前的LinkedHashMap</strong></p><p>存储结构是数组+链表，并维护了一个环形链表来实现有序访问的目的，该链表的表头header既是头又是尾，但它本身只是一个标记，不包含数据域。</p><p>LinkedHashMap中的createEntry方法除了创建Hash桶中的链表节点，还需要把该链表的引用插入环形链表中。</p></li><li><p><strong>Java8之后的LinkedHashMap</strong></p><p>有3个关键的成员变量：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//双向链表的表头，最旧的节点</span><span class="token keyword">transient</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//双向链表的表尾，最新的节点</span><span class="token keyword">transient</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//迭代顺序，true表示顺序，false表示逆序</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span></code></pre><p>存储结构是数组+链表/红黑树，并维护了一个双向链表实现有序访问。</p><p>newNode方法和newTreeNode方法继承自HashMap，LinkedHashMap重写了这两个方法，负责在创建节点的同时将其插入双向链表，实现了保存数据节点副本到双向链表的功能。</p></li></ul></li><li><p><strong>TreeMap</strong></p><p>TreeMap是完全由红黑树实现的。</p><p><strong>有四个构造器：</strong></p><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//无参构造器，初始化比较器为null</span> <span class="token keyword">public</span> <span class="token function">TreeMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//使用外部传入的比较器作为TreeMap的比较器</span> <span class="token keyword">public</span> <span class="token function">TreeMap</span><span class="token punctuation">(</span>Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token operator">></span> comparator<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//使用外部传入的Map初始化TreeMap</span> <span class="token keyword">public</span> <span class="token function">TreeMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//使用外部传入的SortedMap初始化TreeMap，并且用其比较器初始化TreeMap比较器</span> <span class="token keyword">public</span> <span class="token function">TreeMap</span><span class="token punctuation">(</span>SortedMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span></code></pre><p><strong>put方法原理：</strong></p><ul><li>如果TreeMap为空，那么使用指定数据作为根节点。</li><li>TreeMap非空，使用比较器来决定插入位置，如果比较器为空，那么默认key实现了Comparable接口，调用其compareTo方法来决定插入位置，如果没有实现该接口会抛出类型转换异常。</li><li>插入完成后调整红黑树的平衡。</li></ul></li><li><p><strong>HashTable</strong></p><p>HashTable的实现和HashMap很类似，方法被synchronized修饰，是线程安全的，但是效率很低。此外，HashTable中不能存放键值为null的元素。</p></li><li><p><strong>补充：红黑树</strong></p><p>红黑树是一种自平衡的二叉查找树。</p><ul><li><p><strong>特性</strong></p><ul><li>红黑树的每个节点只能是红色或者黑色。</li><li>根节点是黑色的。</li><li>每个叶子节点都是黑色的。</li><li>如果一个叶子节点是红色的，它的子结点必须是黑色的。</li><li>从一个节点到该节点的叶子节点的所有路径都包含相同数目的黑色节点。</li></ul></li><li><p><strong>左旋和右旋</strong></p><ul><li><strong>左旋：</strong>对a节点进行左旋，指将a节点的右节点作为a的父节点，即将a变成一个左节点，因此左旋意味着被旋转的节点变成一个左节点。</li><li><strong>右旋：</strong>对a节点进行右旋，指将a节点的左节点作为a的父节点，即将a变成一个右节点，因此右旋意味着被旋转的节点变成一个右节点。</li></ul></li><li><p><strong>添加</strong></p><p>红黑树的添加分为3步：①将红黑树看作一颗二叉查找树，并以二叉树的插入规则插入新节点。②将插入的节点设为红色或黑色。③通过左旋、右旋或变色，使之重新成为一棵红黑树。</p><p>根据被插入节点的父节点情况，可以将插入分为3种情况处理：</p><ul><li>被插入的节点是根节点，直接将其涂为黑色。</li><li>被插入节点的父节点是黑色的，不做处理，节点插入后仍是红黑树。</li><li>被插入节点的父节点是红色的，一定存在非空祖父节点，进一步分为三种情况处理：<ul><li>叔叔节点是红色的，将父节点设为黑色，叔叔节点设为黑色，祖父节点设为红色，将祖父节点作为当前节点。</li><li>叔叔节点是黑色的且当前节点是右节点，则将父节点设为当前节点，以新节点为支点左旋。</li><li>叔叔节点是黑色的且当前节点是左节点，则将父节点设为黑色，祖父节点设为红色，以祖父节点为支点右旋。</li></ul></li></ul></li><li><p><strong>删除</strong></p><p>红黑树的添加分为3步：①将红黑树看作一颗二叉查找树，并以二叉树的删除规则删除新节点。②通过左旋、右旋或变色，使之重新成为一棵红黑树。</p><p>根据被删除节点的情况，可以将删除分为3种情况处理：</p><ul><li>被删除的节点没有子节点，直接将其删除。</li><li>被删除节点只有一个子节点，直接删除该节点，并用其唯一子节点替换其位置。</li><li>被插入节点有两个子节点，先找出该节点的替换节点，然后把替换节点的数值复制给该节点，删除替换节点。</li></ul><p>通过左旋、右旋或变色使其重新成为红黑树。如果当前节点的子节点是一红一黑，直接将该节点设为黑色。如果当前节点的子结点都是黑色，且当前节点是根节点，则不做处理。如果当前节点的子节点都是黑色且当前节点不是根节点，分为以下几种情况：</p><ul><li>当前节点的兄弟节点是红色的，就将当前节点的兄弟节点设为黑色，将父节点设为红色，对父节点左旋，重新设置当前节点的兄弟节点。</li><li>当前节点的兄弟节点是黑色的，兄弟节点的两个子节点也都是黑色的，则将当前节点的兄弟节点设为红色，将当前节点的父节点作为新节点。</li><li>当前节点的兄弟节点是黑色的，兄弟节点的左节点是红色右节点是黑色，将当前节点的左子结点设为黑色，将兄弟节点设为红色，对兄弟节点右旋、重新设置兄弟节点。</li><li>当前节点的兄弟节点是黑色的，兄弟节点的右节点是红色的，将当前节点的父节点赋给兄弟节点，将父节点设为黑色，将兄弟节点的右子节点设为黑色，对父节点左旋，设置当前节点为根节点。</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础入门</title>
      <link href="2021/03/15/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
      <url>2021/03/15/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Java的特性"><a href="#Java的特性" class="headerlink" title="Java的特性"></a>Java的特性</h3><ul><li><p><strong>简单性</strong></p><p>为了便于系统理解，Java语法在设计时尽可能地接近C++，但Java语法是C++语法的一个“纯净”版本，剔除了C++中许多很少使用、难以理解、容易混淆的特性。不过设计者没有试图清除C++中所有的特性，例如switch语句的语法在Java中就没有改变。</p><p>“简单”的另一方面是小，Java的目标之一是支持开发能够在小型机器上独立运行的软件。</p></li><li><p><strong>面向对象</strong></p><p>面向对象设计是一种程序设计技术，它将重点放在数据（即对象）和对象的接口上。用木匠打一个比方，“面向对象的”木匠始终首先关注的是所制作的椅子，其次才是所使用的工具；“非面向对象的”木匠主要 关注的是所用的工具。在本质上Java的面向对象能力和C++是一样的。</p></li><li><p><strong>分布式</strong></p><p>Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java应用程序能够通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。</p></li><li><p><strong>健壮性</strong></p><p>Java的设计目标之一在于使得Java编写的程序具有多方面的可靠性。Java特别强调进行早期的问题检查、后期动态的（运行时）检测，以及消除容易出错的情况。Java编译器能够检测许多在其它语言中仅在运行时才能检测出的问题，Java与C/C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性。</p></li><li><p><strong>安全性</strong></p><p>Java要适用于网络/分布式环境，为了实现这个目标，安全性颇受重视。从一开始，Java就设计成能够防范各种攻击的语言，包括：运行时堆栈溢出，这是蠕虫和病毒的常用攻击手段；破坏自己的进程空间之外的内存；未经授权读写文件。</p></li><li><p><strong>体系结构中立</strong></p><p>编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要有Java运行时系统，这些编译后的代码可以在许多处理器上运行。Java编译器通过生成与特定计算机体系结构无关的字节码指令来实现这一特性，精心设计的字节码不仅可以很容易地在任何机器上解释执行，而且还可以动态地转换成本地机器代码。</p><p>解释型虚拟机指令肯定比全速运行机器指令慢很多，但虚拟机有一个选项，可以将执行最频繁的字节码序列转换成机器码，这一过程称为即时编译。Java虚拟机还有一些其他优点，可以检查指令序列的行为，从而提高安全性。</p></li><li><p><strong>可移植性</strong></p><p>与C/C++不同，Java规范中没有“依赖具体实现”的地方，基本数据类型的大小以及有关运算的行为都有明确的说明。例如Java中的int永远是32位整数，而C/C++中可能是16位，32位，也可能是编译器开发商指定的其他任何大小。</p><p>在Java中，数值类型有固定的字节数，这消除了代码移植时一个主要问题，二进制数据以固定格式进行存储和传输，消除了字节顺序的困扰，字符串则采用标准的Unicode格式存储。</p><p>除了与用户界面有关的部分外，所有其他Java库确实能很好地支持平台独立性。你可以处理文件、正则表达式、XML、日期和时间、数据库、网络连接、线程等，而不用关心底层操作系统。不仅程序是可移植的，Java API往往也比原生API质量更高。</p></li><li><p><strong>解释型</strong></p><p>Java解释器可以在任何移植了解释器的机器上直接执行Java字节码，由于连接是一个增量式且轻量级的过程，所以开发过程也变得更加快捷，更加具有探索性。</p></li><li><p><strong>高性能</strong></p><p>尽管对解释后的字节码性能已较为满意，但在有些场合下还需要更高的性能。字节码可以（在运行时）动态地转换成对应运行这个应用地特定CPU的机器码。</p><p>现在的即时编译器已经非常出色，可以与传统编译器相媲美，在某些情况下甚至超越了传统编译器，原因是它们有更多的可用信息。例如即时编译器可以监控哪些代码频繁执行，并优化这些代码以提高速度。更为复杂的优化是消除函数调用（内联）。即时编译器知道哪些类已经加载，基于当前加载的类集合，如果一个特定函数不会被覆盖就可以使用内联，必要时还可以撤销这种优化。</p></li><li><p><strong>多线程</strong></p><p>多线程可以带来更快的交互响应和实时行为。在当时，Java是第一个支持并发程序设计的主流语言。</p></li><li><p><strong>动态性</strong></p><p>从很多方面看，Java相比C/C++更具有动态性，它能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在Java中找出运行时类型信息十分简单。</p></li></ul><hr><h3 id="Java发展史"><a href="#Java发展史" class="headerlink" title="Java发展史"></a>Java发展史</h3><table><thead><tr><th>版本</th><th>年份</th><th>新语言特性</th></tr></thead><tbody><tr><td>1.0</td><td>1996</td><td>语言本身</td></tr><tr><td>1.1</td><td>1997</td><td>内部类</td></tr><tr><td>1.2</td><td>1998</td><td>strictfp修饰符</td></tr><tr><td>1.3</td><td>2000</td><td>无</td></tr><tr><td>1.4</td><td>2002</td><td>断言</td></tr><tr><td>5</td><td>2004</td><td>泛型类、for each循环、可变参数、自动装箱、元数据、枚举、静态导入</td></tr><tr><td>6</td><td>2006</td><td>无</td></tr><tr><td>7</td><td>2011</td><td>基于字符串的选择语句、菱形运算符、二进制字面量、异常增强处理</td></tr><tr><td>8</td><td>2014</td><td>lambda表达式、包含默认方法的接口、流和日期/时间库</td></tr><tr><td>9</td><td>2017</td><td>模块、其他的语言和类库增强</td></tr></tbody></table><hr><h2 id="基本程序设计结构"><a href="#基本程序设计结构" class="headerlink" title="基本程序设计结构"></a>基本程序设计结构</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Java是一种强类型语言，因此必须为每一个变量声明一种类型。在Java中一共有8种基本类型，其中有4种整形、2种浮点类型、1种字符类型char和1种用于表示真值的boolean类型。</p><ul><li><p>整形</p><p>整形用于表示没有小数部分的数值，允许是负数，Java提供了4种整形。</p><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>byte</td><td>1字节</td><td>-128~127</td></tr><tr><td>short</td><td>2字节</td><td>-32767~32767</td></tr><tr><td>int</td><td>4字节</td><td>-2147483648~2147483647（刚刚超过20亿）</td></tr><tr><td>long</td><td>8字节</td><td>-9223372036854775808~9223372036854775807</td></tr></tbody></table><p>int类型最常用，数量很大时需要使用long。byte和short类型主要用于特定场合，例如底层的文件处理或者存储空间很宝贵时的大数组。</p><p>在Java中，整形的范围与运行Java代码的机器无关，这就解决了软件从一个平台移植到另一个平台，或者在同一个平台的不同操作系统之间进行移植给程序员带来的诸多问题。与此相反，C/C++程序会针对不同处理器选择最为高效的整形，这样就会造成在32位处理器上运行的程序在16位系统上运行时却发生整数溢出。由于Java程序必须保证在所有机器上都得到相同的运行结果，所以各种数据类型的取值范围必须固定。</p><p>长整型数值有一个后缀L或者l，十六进制数有一个前缀0x或0X，八进制有一个前缀0，很显然八进制数容易混淆所以尽量不要使用八进制常数。</p><p>从Java7开始，加上前缀0b或0B就可以表示二进制数，还可以为数字字面量加下划线，例如1_000，这些下划线只是为了易读性，编译器会去除这些下划线。</p></li><li><p><strong>浮点类型</strong></p><p>浮点类型用于表示有小数部分的数值，Java中有2种浮点型。</p><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>大约±3.40282347E+38F</td></tr><tr><td>double</td><td>8字节</td><td>大约±1.79769313486231570E+308</td></tr></tbody></table><p>double这种类型的精度是float的2倍，因此也称为双精度数值，很多情况下float类型的精度（6~7位有效数字）并不能满足需求，只有很少的情况下适合float，例如需要单精度的库或者需要存储大量数据时。</p><p>float类型的数值有一个后缀F或f，如果没有后缀的浮点数总认为是double类型，当然也可以在浮点数值后面添加后缀D或d。</p><p>常量Double.POSITIVE_INFINITY、DoubleNEGATIVE_INFINITY和Double.NaN分别表示正无穷大、负无穷大和NaN（不是一个数字）。</p><p>浮点数值不适用于无法接受舍入误差的金融计算，舍入误差的主要原因是浮点数值采用二进制系统表示，在二进制系统中无法精确地表示分数。如果在数值计算中不允许有任何舍入误差就应该使用BigDecimal类。</p><p>可移植性是Java语言的设计目标之一，无论在哪个虚拟机上执行，同一运算应该得到同样的结果。对于浮点数而言，实现这样的可移植性是十分困难的。Java虚拟机的最初规范要求所有中间计算必须进行截断，之后改进为默认情况下允许对中间计算采用扩展精度，但是对于使用了strictfp关键字标记的方法必须使用严格的浮点计算。</p></li><li><p><strong>char类型</strong></p><p>char类型（2字节）原本用于表示单个字符，不过现在情况有所变化，有些Unicode字符需要1个char值描述，有些Unicode字符需要2个char值描述。char类型的值可以表示为16进制值，范围从\u0000到\uFFFF。</p><p>一些特殊字符的转义序列：</p><table><thead><tr><th>转义序列</th><th>名称</th><th>Unicode值</th></tr></thead><tbody><tr><td>\b</td><td>退格</td><td>\u0008</td></tr><tr><td>\t</td><td>制表</td><td>\u0009</td></tr><tr><td>\n</td><td>换号</td><td>\u000a</td></tr><tr><td>\r</td><td>回车</td><td>\u000d</td></tr><tr><td>\“</td><td>双引号</td><td>\u0022</td></tr><tr><td>\‘</td><td>单引号</td><td>\u0027</td></tr><tr><td>\\</td><td>反斜杠</td><td>\u005c</td></tr></tbody></table></li><li><p><strong>boolean类型</strong></p><p>boolean类型（1字节）有两个值：false和true，用来判断逻辑条件。整型值和布尔值之间不能相互转换。</p></li></ul><hr><h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><ul><li><p><strong>变量</strong></p><p>变量名必须是一个以字母开头并由字母或数字构成的序列，与大多数语言相比，Java中的字母和数字的范围更大，字母包括’A’<del>‘Z’，’a’</del>‘z’，’_’，’$’或在某种语言中表示字母的任何Unicode字符。同样数字也包括’0’~’9’和在某种语言中表示数字的任何Unicode字符。不可使用空格，并且变量名是大小写敏感的，长度基本没有限制。</p><p>从Java10开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不再需要声明它的类型，只需要使用关键字var而无需指定类型。</p></li><li><p><strong>常量</strong></p><p>利用关键字final指示常量，final表示这个变量只能被赋值一次，一旦赋值之后就不能再更改了，习惯上变量名使用全大写。如果希望某个常量可以在一个类的多个方法使用，通常将这些常量称为类常量，使用关键字static final修饰。</p></li></ul><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><p><strong>算术运算符</strong></p><p>当参与/运算的两个操作数都是整数时表示整数除法，否则表示浮点除法。整数被0除会产生一个异常，浮点数被0除会得到无穷大或NaN结果。</p></li><li><p><strong>数学函数</strong></p><p>计算平方根：<code>Math.sqrt(double a)</code></p><p>计算幂运算：<code>Math.pow(doube a,double b)</code></p><p>如果计算溢出，数学运算符只是返回一个错误结果而不做任何提醒，但如果是Math中的方法就会生成异常。</p></li><li><p><strong>数值类型转换</strong></p><p>无信息丢失的转换：byte-&gt;short、short-&gt;int、char-&gt;int、int-&gt;long、int-&gt;double、float-&gt;double</p><p>可能有精度损失的转换：int-&gt;float、long-&gt;float、long-&gt;double</p><p>当用二元运算符连接两个值时，先要将两个操作数转换为同一种类型再进行计算，如果两个操作数有一个是double类型，另一个操作数就转为double；否则如果有一个是float类型，另一个操作数就转为float；否则如果有一个操作数是long类型，另一个操作数就转为long；否则两个操作数都转为int。</p></li><li><p><strong>强制类型转换</strong></p><p>可能丢失信息的转换要通过强制类型转换完成，如果想对浮点数进行舍入运算，以便得到最接近的整数，可以使用Math.round(float/double a)方法。</p></li><li><p><strong>结合赋值和运算符</strong></p><p>可以在赋值时使用二元运算符，例如<code>x+=4</code>，等价于<code>x=x+4</code>，如果运算符右边的值类型和左边不一致就会发生强制类型转换，例如x是int类型，<code>x+=3.5</code>等价于<code>x=(int)(x+3.5)</code>。</p></li><li><p><strong>自增和自减运算符</strong></p><p>自增和自减运算符改变的是变量的值，不能应用于数值本身，因此1++不是一个合法的语句。</p><p>后缀和前缀形式都会使变量值加1或减1，不同的是前缀形式会先完成运算，后缀形式会先使用变量原来的值。</p></li><li><p><strong>关系和boolean运算符</strong></p><p>Java沿用了C++的做法，使用&amp;&amp;表示逻辑“与”运算符，使用||表示逻辑”或”运算符，感叹号！就是逻辑非运算符。&amp;&amp;和||是按照”短路”方式来求值的，如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。</p></li><li><p><strong>位运算符</strong></p><p>位运算符包括<code>&amp;</code>（与）、<code>|</code>（或）、<code>^</code>（异或）、<code>~</code>（非）。</p><p><code>&gt;&gt;</code>和<code>&lt;&lt;</code>可以将位模式左移或右移，<code>&gt;&gt;&gt;</code>会用0填充高位，<code>&gt;&gt;</code>会用符号位填充高位，不存在<code>&lt;&lt;&lt;</code>运算符。移位运算符的右操作数要完成模32的运算（除非左操作数是long类型，这种情况下需要模64），例如1&lt;&lt;35的值等于1&lt;&lt;3或者8。</p></li><li><p><strong>括号与运算符级别</strong></p><p>不使用括号就按照运算符优先级次序计算，同一级别的运算符按照从左到右的次序计算（右结合运算符除外）。</p></li></ul><hr><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>从概念上讲，Java字符串就是Unicode字符序列。Java没有内置的字符串类型，而是在标准Java类库中提供了一个与定义类，叫做String，每个用双引号引起来的字符串都是String类的一个实例。</p><ul><li><p><strong>子串</strong></p><p>String类的substring方法可以从一个较大的字符串提取出一个字串。</p><p>substring方法的第一个参数是要复制的第一个位置，第二个参数是不想复制的第一个位置，例如substring(0,3)复制了0，1和2，不包括3。</p><p>substring的工作方式有一个优点：容易计算字串的长度，substring(a,b)的长度为b-a。</p></li><li><p><strong>拼接</strong></p><p>与绝大多数程序设计语言一样，Java语言允许使用+号连接（拼接）两个字符串。</p><p>当将一个字符串与一个非字符串的值拼接起来时，后者会转换成字符串（任何一个Java对象都可以转换成字符串）。例如<code>int age=13</code>，<code>String rating=&quot;PG&quot;+age</code>，将rating设置为”PG13”。</p><p>如果需要把多个字符串放在一起，用一个界定符分隔，可以使用静态方法join，例如<code>String str=String.join(&quot;/&quot;,&quot;S&quot;,&quot;M&quot;,&quot;L&quot;)</code>将str设置为”S/M/L”。</p><p>在Java11中，还提供了repeart方法，例如<code>String str=&quot;Java&quot;.repeat(3)</code>将str的值设为”JavaJavaJava”。</p></li><li><p><strong>不可变字符串</strong></p><p>String类没有提供修改字符串中某个字符的方法，由于不能修改Java字符串中的单个字符，所以Java文档中将String类对象称为不可变的，不过可以修改字符串变量，让它引用另一个字符串，就如同可以让原本存3的数值变量改成存放4一样。</p><p>通过拼接两个字符串来创建一个新字符串的效率确实不高，但是不可变字符串有一个优点：编译器可以让字符串共享。可以想象将各种字符串存放在公共的存储池中，字符串变量指向存储池中相应的位置，如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。Java认为共享带来的高效率远胜于提取字串、拼接字符串所带来的低效率。</p></li><li><p><strong>检查字符串是否相等</strong></p><p>可以使用equals方法比较两个字符串的值是否相等，如果不区分大小写，可以使用equalsIgnoreCase方法。</p><p>==运算符只能确定两个字符串是否存放在同一个位置上，如果虚拟机始终将相同的字符串共享，就可以使用==运算符检测是否相等。但实际上只有字符串字面量是共享的，而+或substring等操作得到的字符串并不共享，不要使用==运算符测试字符串的相等性。</p></li><li><p><strong>空串与Null串</strong></p><p>空串””是长度为0的字符串，空串是一个Java对象，有自己的串长度(0)和内容(空)，不过String变量还可以存放一个特殊的值，名为null，表示目前没有任何对象与该变量关联。</p></li><li><p><strong>String类常用API</strong></p><p><code>int compareTo(String other)</code>:按字典顺序比较，在other之前返回负数，之后返回正数，相等返回0。</p><p><code>boolean equals(String other)</code>:比较两个字符串值是否相等。</p><p><code>boolean startWith(String prefix)</code>:是否以prefix开头。</p><p><code>boolean endsWith(String suffix)</code>:是否以suffix结尾。</p><p><code>int indexOf(String str[,int fromIndex])</code>:返回与字符串str匹配的第一个子串的开始位置，从索引0或者fromIndex开始，不存在返回-1。</p><p><code>int indexOf(int cp[,int fromIndex])</code>:返回与码点cp匹配的第一个子串的开始位置，从索引0或者fromIndex开始，不存在返回-1。</p><p><code>int length()</code>:返回字符串代码单元的长度。</p><p><code>String replace(CharSequence old,CharSequence new)</code>:返回新字符串，用new代替所有的old。</p><p><code>String substring(int begin[,int end])</code>:返回新字符串，包含原始字符串从begin到末尾或end-1的所有代码单元。</p><p><code>String trim()</code>:返回一个新字符串，删除原始字符串头部和尾部小于等于U+0020的字符。</p></li><li><p><strong>构建字符串</strong></p><p>有时候需要由较短的字符串构建字符串，如果采用字符串拼接的方式来达到目的，效率会比较低。每次拼接字符串时都会构建一个新的String对象，既耗时又浪费空间。可以使用StringBuilder来解决该问题。</p><p>StringBuilder在Java5中引入，这个类的前身是StringBuffer，它的效率低但是线程安全。如果所有字符串编辑操作都在单个线程中执行（通常都是这样），则应该使用StringBuilder。</p></li></ul><hr><h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><ul><li><p><strong>读取输入</strong></p><p>读取标准输入流首先需要构造一个与标准输入流关联的Scanner对象，<code>nextLine()</code>方法将读取一整行输入；如果想要读取一个单词（以空白符作为分隔符），可以使用<code>next()</code>方法；如果想要读取一个整数，可以使用<code>nextInt()</code>方法；如果想要读取下一个浮点数就是要<code>nextDouble()</code>方法；<code>hasNext()</code>可以检测输入中是否还有其他单词，<code>hashNextInt()</code>和<code>hashNextDouble()</code>检测是否还有下一个表示整数或浮点数的字符序列。</p></li><li><p><strong>格式化输出</strong></p><p>可以使用printf方法实现格式化输出，例如x的值为10000.0/3.0调用printf(“%8.2f”,x)将输出<code> 3333.33</code>，8代表输出的字符宽度，精度是小数点后2个字符，由于3333.33只有7个字符宽，所以还会打印一个前导的空格。</p><p>每一个以%后面的转换符都说明了要格式化的数值类型，除了f表示浮点数，还有s表示字符串，d表示十进制整数，c表示字符，b表示布尔等。除了printf也可以用静态方法<code>String.format</code>创建一个格式化的字符串。</p></li></ul><hr><h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><p>与任何程序设计语言一样，Java使用条件语句和循环结构确定控制流程。</p><ul><li><p><strong>块作用域</strong></p><p>块（即复合语句）是指由若干条Java语句组成的语句，并用一对大括号括起来。块确定了变量的作用域，一个块可以嵌套在另一个块中。不能在嵌套的两个块中声明同名的变量。</p></li><li><p><strong>条件语句</strong></p><p>if中的条件为true时会执行对应语句，else是可选的，总是与最近的if构成一组。</p></li><li><p><strong>for循环</strong></p><p>for循环语句是支持迭代的一种通用结构，由一个计数器或类似的变量控制迭代次数，每次迭代后这个变量将会更新。for语句的第1部分通常是对计数器初始化，第2部分给出每次新一轮循环执行前要检测的循环条件，第3部分指定如何更新计数器。</p><p>for语句内部定义的变量，不能在循环体之外使用。因此如果希望在for循环体之外使用循环计数器的最终值，就要确保这个变量在循环之外声明。</p></li><li><p><strong>while循环</strong></p><p>while语句在最前面检测循环条件，因此循环体中的代码有可能一次都不执行。如果希望循环体至少执行一次可以使用do-while循环，这种循环语句先执行语句再检测循环条件。</p></li><li><p><strong>多重选择：switch语句</strong></p><p>在处理多个选项时，使用if/else会显得有些笨拙，Java有一个和C/C++完全相同的switch语句。switch语句将从选项值相匹配的case标签开始执行，直到遇到break语句，或者执行到switch语句的结束处为止。如果没有匹配的case语句而有default语句就执行这个default子句。</p><p>case标签可以是char、byte、short、或int的常量表达式，枚举常量，从Java7开始，还可以支持字符串字面量。当使用枚举常量时，不必在每个标签中指明枚举名，可以由switch的表达式值推导得出。</p></li><li><p><strong>中断控制流程的语句</strong></p><p>不带标签的break语句，和用于退出swicth语句的break语句一样，可以用于直接退出循环。</p><p>还可以使用带标签的break语句，可以用于跳出多重循环的嵌套语句。标签必须放在最外层循环之前，并且紧跟一个冒号。</p><p>continue语句将中断正常的控制流程，将控制转移到最内层循环的首部，如果continue用于for循环，就可以跳到for循环的更新部分，还有一种带标签的continue，将跳到与标签匹配的循环的首部。</p></li></ul><hr><h3 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h3><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类：BigInteger和BigDecimal，这两个类可以处理包含任意长度数字序列的数值。BigInteger类实现任意精度的整数运算，BigDecimal类实现任意精度的浮点数运算。</p><p>使用静态的<code>valueOf</code>方法可以将普通的数值转换为大数，对于更大的数，可以使用一个带字符串参数的构造器。不能使用算术运算符处理大数，例如+和*，而需要大数类的add和multiply方法。除此之外的其他方法：substract求差，divide求商，mod求余，sqrt求平方根，compareTo比较两个数。</p><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><p><strong>声明</strong></p><p>数组是一种数据结构，用来存储同一类型值的集合。通过一个整形下标（index，或称索引）可以访问数组中的每一个值。在声明数组变量时，需要指出数组类型和数组变量的名字。</p><p>一旦创建了数组就不能再改变它的长度，如果程序运行中需要经常扩展数组的大小，就应该使用另一种数据结构：数组列表ArrayList。</p></li><li><p><strong>访问元素</strong></p><p>创建一个数字数组时，所有元素都初始化为0，boolean数组的元素会初始化为false，对象数组的元素则初始化为一个特殊值null，表示这些元素还未存放任何对象。</p><p>Java可以使用增强for循环来依次处理数组（或者其他元素集合）中的每一个元素，而不必考虑指定下标值。可以使用的必须是一个数组或者一个实现了Iterable接口的类对象。如果想打印数组中的所有值可以调用静态的<code>Arrays.toString</code>方法。</p></li><li><p><strong>数组拷贝</strong></p><p>如果希望将一个数组的所有值拷贝到一个新的数组中去，可以使用<code>Arrays.copyOf(int[] arr,int len)</code>方法，第2个参数是新数组的长度，这个方法通常用于增加数组的大小，如果数组元素是数值型那么额外的元素将被赋值0，如果数组元素是布尔型则赋值false。相反如果长度小于原始数组的长度，则只拷贝前面的值。这个方法实际上调用了<code>System.arraycopy</code>方法，效率一般。</p><p>使用<code>System.arraycopy(Object src,int srcPos,Object dest,int destPos,int length)</code>拷贝数组，前2个参数是原数组和拷贝位置，之后2个参数是目标数组和拷贝位置，最后一个参数代表拷贝长度，这是一个本地方法，效率最高，尤其在数组很大时尤为明显。也可以使用for循环和clone方法拷贝数组，for循环适合于小数组的拷贝，数组越大效率越低。</p></li><li><p><strong>数组排序</strong></p><p>可以使用Arrays类中的sort方法，这个方法使用了优化的快速排序，快速排序算法对于大多数数据集合来说都是效率比较高的。</p></li></ul><hr><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>面向对象程序涉设计（OOP）是当今主流的程序设计泛型，面向对象的程序是由对象组成的，每个对象包含对用户公开的特定部分和隐藏的实现部分。传统的结构化程序通过设计一系列算法求解问题，首先考虑的是如何操作数据，然后再考虑组织数据的结构，而面向对象中数据是第一位的，然后再考虑操作数据的算法。对于规模较小的问题，面向过程开发比较理性，面向对象更加适合解决规模较大的问题。</p><hr><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是构造对象的模板或蓝图，由类构造对象的过程称为创建类的实例。</p><p>封装是处理对象的一个重要概念，从形式上看封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。对象中的数据称为实例字段，操作数据的过程称为方法。作为一个类的实例，特定对象都有一组特定的实例字段值，这些值的集合就是这个对象的当前状态。</p><p>封装给予了对象黑盒特征，这是提高重用性和可靠性的关键。这意味着一个类完全可以改变数据存储的方式，只要仍使用同样的方法操作数据，其他对象就不会知道也不用关心这个类的变化。</p><p>类之间的关系：</p><ul><li>依赖，即uses-a关系，如果一个类的方法使用或操纵另一个类的对象，我们就说一个类依赖于另一个类。</li><li>聚合，即has-a关系，即一个对象包含另一个对象。</li><li>继承，即is-a关系，表示一个更特殊的类与一个更一般的类之间的关系。</li></ul><hr><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>Java语言中要使用构造器用来构造新实例，构造器是一种特殊的方法，用来构造并初始化对象。</p><p>构造器的名字与类名相同，想要构造一个新实例需要在构造器前加上new操作符。在Java中，任何对象变量的值都是对存储在另一个地方的某个对象的引用，new操作符返回值也是一个引用。</p><p>每个类可以有一个以上的构造器，构造器可以0或多个参数，构造器没有返回值，构造器总是伴随new操作符一起使用。</p><p><strong>构造器可以重载但不可以重写。</strong> 重写是指子类重写父类方法，子类与父类的类名不一样，谈不上重写。</p><p><strong>重写发生在运行时，重载发生在编译时。</strong></p><hr><h3 id="静态字段和方法"><a href="#静态字段和方法" class="headerlink" title="静态字段和方法"></a>静态字段和方法</h3><p>如果将一个字段定义为static，每个类只有一个这样的字段，而对于非静态的实例字段，每个对象都有自己的一个副本。</p><p>静态方法是用static修饰的方法，静态方法不在对象上指向，可以认为静态方法是没有this参数的方法（在一个非静态方法中，this参数指示这个方法的隐式参数）。可以使用对象调用静态方法，但容易造成混淆，建议使用类名调用。</p><p>可以使用静态方法的情况：</p><ul><li>方法不需要方法对象的状态，因为它所需要的所有参数都通过显示参数提供。</li><li>方法只需要访问类的静态字段。</li></ul><p>静态方法还有一种常见用途，就是使用静态工厂方法来构造对象。</p><hr><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>按值调用表示方法接收的是调用者提供的值，按引用调用表示方法接收的是调用者提供的变量地址。方法可以修改按引用传递的变量的值，而不能修改按值传递的变量的值。Java中总是采用按值调用，也就是说方法得到的是所有参数值的一个副本，方法不能修改传递给它的任何参数变量的内容，实际上对象引用是按值传递的。</p><hr><h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><ul><li><p><strong>重载</strong></p><p>如果多个方法具有相同的名字、不同的参数，便出现了重载。如果编译器找不到匹配的参数就会产生编译时错误，查找匹配的过程叫做重载解析。</p><p>Java允许重载任何方法，要完整描述一个方法需要指定方法名和参数类型，这叫做方法的签名。返回类型不是方法签名的一部分，因此不能有两个名字相同、参数类型也相同却有不同返回类型的方法。</p></li><li><p><strong>默认字段初始化</strong></p><p>如果在构造器中没有显示地为字段设置初值，那么就会被自动赋为默认值：数值为0、布尔值为false、对象引用为null。</p><p>方法中的局部变量必须明确地初始化，不能不设置初始值。</p></li><li><p><strong>无参构造器</strong></p><p>很多类都包含无参构造器，由无参构造器创建对象时，对象的状态会设置为适当的默认值。如果没有为一个类编写构造器，就为为你提供一个无参构造器，这个构造器将所有字段设置为默认值。</p><p>如果类中至少提供了一个构造器，但是没有提供无参构造器，那么构造对象时就不能使用无参构造器。</p></li><li><p><strong>调用构造器</strong></p><p>关键字this指代一个方法的隐式参数，除此之外，还可以使用this来调用同一个类的其他构造器。</p></li><li><p><strong>初始化块</strong></p><p>除了在构造器中赋值和在声明中赋值，还可以使用初始化块，即类中的代码块。</p><p>构造器调用的具体处理步骤：</p><ul><li>如果构造器的第一行调用了另一个构造器，则基于所提供的参数执行第二个构造器。</li><li>否则将所有数据字段初始化为默认值，按照在类声明中出现的顺序，执行所有字段初始化方法和初始化块。</li><li>执行构造器主体代码。</li></ul></li><li><p><strong>finalize方法</strong></p><p>该方法在垃圾回收器清理对象之前调用，不要使用该方法来回收资源，因为并不能知道它什么时候调用而且它已被废弃。</p></li></ul><hr><h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><ul><li>保证数据私有</li><li>一定要对数据进行初始化</li><li>不要在类中使用过多基本类型</li><li>不是所有字段都需要单独的字段访问器和字段更改器</li><li>分解有过多职责的类</li><li>类名和方法名要能体现它们的职责</li><li>优先使用不可变类</li></ul><hr><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="子类和父类"><a href="#子类和父类" class="headerlink" title="子类和父类"></a>子类和父类</h3><p>关键字extends表示正在构造的新类派生于一个已存在的类，这个已存在的类称为超类、基类或父类；新类称为子类、派生类或孩子类。Java中不支持多继承。</p><ul><li><p><strong>方法重写</strong></p><p>子类可以重写父类的方法，也可以通过关键字super调用父类的方法。</p><p>重写方法的方法签名必须和父类一致，返回值小于等于父类方法，抛出的异常类型小于等于父类方法，访问修饰符大于等于父类方法。</p></li><li><p><strong>子类构造器</strong></p><p>可以使用super调用父类的构造器，使用super调用构造器的语句必须是子类构造器的第一条语句。</p><p>如果子类的构造器没有显式地调用父类构造器，将自动调用父类无参构造器。如果父类没有无参构造器，在子类的构造器又没有显式调用父类的其他构造器，Java编译器就会报告错误。</p><p>this的两个作用：①隐式参数的引用。②调用该类的其他构造器。</p><p>super的两个作用：①调用父类的方法。②调用父类的构造器。</p></li><li><p><strong>多态</strong></p><p>在Java中对象变量是多态的，既可以引用本类型的对象，也可以引用子类的对象。</p><p>方法调用的过程：</p><ul><li>编译器查看对象的声明类型和方法名。</li><li>编译器确定方法调用中提供的参数类型，这个过程称为重载解析。</li><li>如果是private、static或final修饰的方法或者构造器，编译器可以准确地知道要调用哪个方法，这称为静态绑定，与此对应地是如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时动态绑定。</li><li>程序运行并采用动态绑定调用方法时，虚拟机必须调用引用对象的实际类型对应的方法。</li></ul><p>每次调用都要完成时间开销很大的搜素，因此虚拟机预先为每个类计算了一个方法表，其中列出了所有方法的签名和要调用的实际方法，当真正调用方法时虚拟机仅查找这个表就可以了。</p><p>动态绑定有一个重要特性：无须对现有的代码进行修改就可以对程序进行扩展。</p></li><li><p><strong>阻止继承：final类和方法</strong></p><p>不允许扩展的类称为final类，不允许子类重写的方法称为final方法。</p><p>将类或方法声明为final的主要原因是：确保它们不会在子类中改变语义。</p></li><li><p><strong>强制类型转换</strong></p><p>将一个类强制转换成另外一个类型的过程称为强制类型转换。</p><p>进行强制类型转换的唯一原因是：要在暂时忽视对象的实际类型之后使用对象的全部功能。将子类的引用赋值给父类变量，编译器是允许的。但如果将一个父类引用赋值给子类变量，就必须进行强制类型转换，这样才能通过运行时的检查。</p><p>只能在继承层次内使用强制类型转换，并且强制转换前应该是有instance of进行检查。</p></li><li><p><strong>抽象类</strong></p><p>使用abstract修饰抽象类，抽象类更具有一般性。</p><p>抽象类不能实例化，但抽象类的非抽象子类可以实例化，一个抽象类对象变量只能引用非抽象子类对象。</p><p>抽象类可以不含抽象方法，但有抽象方法的类一定是抽象类。</p><p>扩展抽象类有两种选择：</p><ul><li>在子类中保留抽象类中的部分或所有抽象方法，将子类也标记为抽象类。</li><li>实现全部方法，子类是非抽象类。</li></ul></li><li><p><strong>受保护访问</strong></p><p>如果希望限制父类的某个方法只允许子类访问，或者希望允许子类的方法能访问父类的某个字段，就可以将这些类方法或字段声明为protected。</p><p>Java中有4个访问修饰符：①public，对外部完全可见。②protected，对本包和所有子类可见。③默认，不需要修饰符，对本包可见。④private，仅对本类可见。</p></li></ul><hr><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>Object类是所有类的父类，可以使用Object类型的变量引用任何类型的对象。</p><ul><li><p><strong>equals方法</strong></p><p>Object类中的equals方法用于检测一个对象是否等于另一个对象，它将确定两个对象的引用是否相等。</p><p>当使用equals比较字符串和基本数据数据类型时，比较的是值而不是引用，因为重写了equals方法。</p><p>如果要比较两个数组的值，可以使用Arrays.euqals方法。</p></li><li><p><strong>hashCode方法</strong></p><p>哈希值是由对象导出的一个整型值，哈希值是没有规律的，两个不同的对象调用hashCode方法，结果基本不会相同。每个对象都有一个默认的哈希值，由对象的存储地址得出，而字符串的哈希值由内容导出。</p><p>如果重写了equals方法，就必须为可能插入HashMap或HashSet的对象重写hashCode方法。如果equals方法返回true，hashCode就必须相同；但是如果hashCode相同，equals未必相等。</p></li><li><p><strong>toString方法</strong></p><p>它返回表示对象值的一个字符串，直接打印某个对象就是打印了它的toString方法结果。如果要打印数组的内容可以使用Arrays.toString方法，如果是多维数组可以使用Arrays.deepToString方法。</p></li></ul><hr><h3 id="对象包装器和自动拆装箱"><a href="#对象包装器和自动拆装箱" class="headerlink" title="对象包装器和自动拆装箱"></a>对象包装器和自动拆装箱</h3><p>所有的基本类型都有一个与之对应的类，例如int对应Integer类，这些类称为包装器。这些包装器类见名知意，包括Short、Byte、Integer、Long、Float、Double、Character和Boolean（前6个派生自公共父类Number）。</p><p>包装器类是不可变的，一旦构造了包装器，就不允许更改包装器在其中的值，并且包装器类是final类，因此不能被继承。将一个基本类型的值赋给包装器类会自动将其包装为一个包装器类的对象，这叫做自动装箱，将一个包装器类对象赋值给一个基本类型变量时，就会自充拆箱。</p><p>如果要比较包装器类的值要使用equals方法，如果使用==会比较对象的地址。</p><p>常用API：</p><ul><li><code>int intValue()</code>：将Integer对象作为int值返回</li><li><code>static String toString(int i)</code>：将i的十进制字符串形式返回</li><li><code>static String toString(int i,int radix)</code>：将i的radix进制字符串形式返回</li><li><code>static int parseInt(String s)</code>：将字符串s表示的整数转换为10进制整数</li><li><code>static int parseInt(String s,int radix)</code>：将字符串s表示的整数转换为radix进制</li><li><code>static Integer valueOf(String s)</code>：将parseIntt(String s)的结果封装为包装器对象</li><li><code>static Integer valueOf(String s,int radix)</code>：将parseIntt(String s,int radix)的结果封装为包装器对象</li></ul><hr><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>在比较两个枚举类型的值时，不需要调用equals，直接使用==就可以了。</p><p>枚举的构造器总是私有的，如果将enum的构造器声明为public或protected，就会报语法错误。所有枚举类型都是Enum类的子类。</p><p>常用API：</p><ul><li><code>static Enum valueOf(Class enumClass,String name)</code>：返回给定类中有指定名字的枚举常量。</li><li><code>String toString()</code>：返回枚举常量名。</li><li><code>int ordinal()</code>：返回枚举常量在enum声明中的为止，从0开始计数。</li><li><code>int compareTo(E other)</code>：如果枚举常量出现在other之前，返回一个负整数；如果this==other，返回0；否则返回一个正整数。枚举常量出现次序在enum声明中给出。</li></ul><hr><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射库提供了一个丰富且精巧的工具集，可以用来编写能够动态操纵Java代码的程序。能够分析类能力的程序称为反射，反射机制的功能很强大，主要包括：</p><ul><li><strong>在运行时分析类的能力</strong>。</li><li><strong>在运行时检查对象</strong>。</li><li><strong>实现泛型数组操作代码。</strong></li><li><strong>利用Method对象。</strong></li></ul><p>在程序运行期间，Java运行时系统始终为所有对象维护一个运行时类型标识，这个信息会跟踪每个对象所属的类，虚拟机利用运行时类型信息选择要执行的正确方法。也可以使用一个特殊的Java类方法这些信息，保存这些信息的类名为Class。</p><p>获取Class对象的三种方法：</p><ul><li>使用Object类中的<code>getClass()</code>方法，该方法返回一个Class类型的实例。</li><li>使用静态方法<code>Class.forName(String className)</code>获得类名对应的Class对象。</li><li>如果T是Java类型，T.class将代表匹配的类对象。</li></ul><p>Class类实际上是一个泛型类，例如Student.class的类型是<code>Class&lt;Student&gt;</code>，虚拟机为每个类型管理一个唯一的Class对象，因此可以利用==运算符实现两个类对象的比较。</p><p>如果有一个Class类型的对象，可以使用它来构造类的实例。调用getConstructor()方法将得到一个Constructor类型的对象（相当于获取该类的无参构造器），然后使用newInstance方法来构造一个实例。如果这个类没有无参构造器就会抛出一个异常。</p><ul><li><p><strong>利用反射分析类的能力</strong></p><p>java.lang.reflect包中有三个类Field、Method和Constructor分别用于描述类的字段、方法和构造器。这三个类都有一个getName()方法，用来返回字段、方法或构造器的名称。Field类有一个getType方法，用来返回描述字段类型的一个对象，这个对象的类型同样是Class。</p><p>Method和Constructor类有报告参数类型的方法，Method类还有一个报告返回类型的方法。这三个类都有一个getModifiers方法，它将返回一个整数，用不同的0/1位描述所使用的修饰符，如public和static。另外还可以使用Modifier类的静态方法分析getModifiers返回的这个整数，例如可以使用isPublic、isPrivate或isFinal判断方法或构造器是否是public、private、final修饰的。</p><p>Class类中的getFields、getMethods和getConstructors方法将分别返回这个类支持的公有字段、方法和构造器的数组，其中包括父类的公共成员（父类字段和方法可以获得，但不包含父类公有构造器）。</p><p>Class类中的getDeclaredFields、getDeclaredMethods和getDeclaredConstructors方法将分别返回这个类中声明的全部字段、方法和构造器的数组，其中包括私有成员、包成员和受保护成员，但不包括父类成员。</p></li><li><p><strong>在运行时分析对象</strong></p><p>反射机制的默认行为受限于Java的访问控制，不过可以调用Field、Method或Constructor对象的setAccessible方法覆盖Java的访问控制。</p></li><li><p><strong>调用方法和构造器</strong></p><p>Method类有一个invoke方法，可以调用包装在当前Method对象中的方法，可以使用方法名获取对应的Method对象。类似的，可以使用构造器的参数类型获取对应的构造器对象，然后利用newInstance方法构建对象实例。</p></li><li><p><strong>注解</strong></p><ul><li>注解是一种标记，可以使类或接口附加额外的信息，是帮助编译器和JVM完成一些特定功能的。</li><li>元注解是自定义注解的注解，包括<ul><li><code>@Target</code>：用来约束注解的位置，值是ElementType枚举类，包括METHOD方法、VARIABLE变量、TYPE类/接口、PARAMETER方法参数、CONSTRUCTORS构造器和LOACL_VARIABLE局部变量；</li><li><code>@Rentention</code>：用来约束注解的生命周期，值是RetentionPolicy枚举类，包括：SOURCE源码、CLASS字节码和RUNTIME运行时。</li><li><code>@Documented</code>：表明这个注解应该被javadoc工具记录。</li><li><code>@Inherited</code>：表明某个被标注的类型是被继承的。</li></ul></li></ul></li></ul><hr><h3 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h3><ul><li>将公共操作和字段放在父类中。</li><li>不要使用受保护的字段。</li><li>使用继承实现is-a的关系。</li><li>除非所有继承的方法都有意义，否则不要使用继承。</li><li>在重写方法时，不要改变预期的行为。</li><li>使用多态，而不要使用类型信息。</li><li>不要滥用反射。</li></ul><hr><h2 id="接口、lambda表达式和内部类"><a href="#接口、lambda表达式和内部类" class="headerlink" title="接口、lambda表达式和内部类"></a>接口、lambda表达式和内部类</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口不是类，而是对希望符合这个接口的类的一组需求。</p><p>接口中的所有方法都默认是public的，因此在接口中声明方法时不必提供关键字public。</p><p>接口还可以定义常量，但接口不能提供实例字段，也不能实例化，只有接口的实现类可以实例化。</p><p>每个类只能有一个父类，但是可以实现多个接口，这为定义类的行为提供了极大的灵活性。</p><ul><li><p><strong>接口与抽象类</strong></p><p>使用抽象类表示通用属性存在一个严重的问题，每个类只能扩展一个类。Java选择了不支持多重继承，主要原因是多重继承会让语言变得非常复杂，或者效率会降低。接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p><p>接口和抽象类都不能被实例化，但抽象类具有构造器而接口没有构造器。</p><p>抽象类中定义变量和方法没有限制，接口中只能定义常量，在Java8前只能定义public方法，Java8开始支持默认方法和静态方法，Java9开始支持私有方法，私有方法可以是静态方法或实例方法，由于私有方法只能在接口本身的方法中使用，所以其用法很有限，只能作为接口中其他方法的辅助方法。</p></li><li><p><strong>默认方法</strong></p><p>默认方法的一个重要用法是接口演化，假如为接口增加了一个新的方法，其实现类将不能编译，因为它没有实现这个新方法，为接口增加一个非默认方法不能保证源代码兼容。将方法实现为一个默认方法就可以解决该问题。</p><p>如果在接口中定义了默认方法，父类中也有方法签名一样的具体方法，会优先使用父类方法，接口中的方法会被忽略。</p><p>如果两个接口提供了相同的默认方法，就必须在实现类重写来解决二义性问题，否则会编译报错。</p></li></ul><hr><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。</p><p>即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样。如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。如果方法只有一个参数，而且这个参数的类型可以推导得出，那么可以省略小括号。</p><p>无须指定lambda表达式的返回类型，lambda表达式的返回类型总会是由上下文推导得出。</p><p>如果一个lambda表达式只在某些分支返回一个值，而另外一些分支不返回值，就是不合法的。</p><ul><li><p><strong>函数式接口</strong></p><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口称为函数式接口。通过<code>@FunctionalInterface</code>标识一个接口为函数式接口，如果不满足有且仅有一个抽象方法的要求就会报错。</p></li><li><p><strong>方法引用</strong></p><p>可以直接把某个方法作为参数传递，主要有三种情况：</p><ul><li>传递某个对象的实例方法，例如<code>System.out::println</code>，对象是System.out。</li><li>传递某个类的实例方法，第一个参数作为隐式参数，例如<code>String::compareTo</code>。</li><li>传递某个类的静态方法，例如<code>Math::pow</code>。</li></ul><p>只有当lambda表达式只调用一个方法而不进行其他操作时，才能把lambda表达式重写为方法引用。</p><p>一个常用转换，List数组转换为int数组：<code>list.stream().mapToInt(Integer::intValue).toArray()</code></p></li><li><p><strong>构造器引用</strong></p><p>构造器引用和方法引用很类似，只不过方法名为new。例如<code>Person::new</code>是Person构造器的一个引用，具体是哪个构造器取决于上下文。</p></li><li><p><strong>变量作用域</strong></p><p>在lambda表达式中，只能引用值不会改变的变量。因为如果在lambda表达式中更高变量，并发执行时就会不安全。另外如果在lambda表达式中引用一个变量，而这个变量可能在外部更改，也是不合法的，例如for循环中的计数器不能在lambda表达式中引用，lambda表达式中捕获的值必须实际上是最终变量，即这个变量初始化后就不会再为它赋新值。</p><p>lambda表达式的体与嵌套块具有相同的作用域，在lambda表达式中声明与一个局部变量同名的参数或局部变量是不合法的。</p><p>在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数。</p></li><li><p><strong>处理lambda表达式</strong></p><p>使用lambda表达式的重点是延迟执行，之所以希望之后再执行代码，有很多原因，如：</p><ul><li>在一个单独的线程中运行代码</li><li>多次运行代码</li><li>在算法的适当位置运行代码</li><li>发生某种情况时执行代码</li><li>只在必要时运行代码</li></ul></li></ul><hr><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类是定义在另一个类中的类，使用内部类的原因主要有两个：</p><ul><li>内部类可以对同一个包中的其他类隐藏。</li><li>内部类方法可以访问定义这个类的作用域中的数据，包括原本私有的数据。</li></ul><p>内部类的分类：</p><ul><li><p><strong>成员内部类</strong></p><p>普通的内部类，可以自由引用外部类的字段和方法，无论这些字段和方法是静态还是非静态的。成员内部类属于外部类实例对象，只有外部类被实例化后这个内部类才能被实例化。</p><p>成员内部类的构造语法：<code>new Outer().new Inner()</code></p></li><li><p><strong>静态内部类</strong></p><p>被声明为static的内部类，属于外部类本身，不依赖于外部类的实例对象。静态内部类只能访问外部类中静态成员和方法。</p><p>有时使用内部类只是为了把一个类隐藏在另一个类内部，并不需要内部类有外部类对象的一个引用，为此可以将内部类声明为静态内部类。</p><p>静态内部类的构造语法：<code>new Outer.Inner()</code></p></li><li><p><strong>局部内部类</strong></p><p>局部内部类是定义在一个代码块中的累，作用范围仅在其所在代码块。局部内部类就像局部变量一样，不能被访问修饰符修饰。</p><p>局部内部类有一个很大的优势，即对外部世界完全隐藏。</p></li><li><p><strong>匿名内部类</strong></p><p>没有类名的内部类，没有构造器，必须继承或实现其他接口，一般使用lambda表达式实现。</p></li></ul><hr><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><p>在Java中所有异常对象都是派生自Throwable类的一个实例，Throwable分为Error和Exception。</p><ul><li><p><strong>Error</strong></p><p>Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误，如果出现了这样的内部错误，一般是无力解决的。</p></li><li><p><strong>Exception</strong></p><ul><li><p><strong>RuntimeException</strong></p><p>由编程错误导致的异常属于RuntimeException，常见的RuntimeException包括：错误的强制类型转换、数组访问越界、空指针异常。</p></li><li><p><strong>其他异常</strong></p><p>程序本身没有问题，但由于像IO错误这类问题导致的异常属于其他异常，常见的非RuntimeException包括：试图超越文件末尾继续读取数据、试图打开一个不存在的文件、根据字符串查找Class对象而这个字符串表示的类并不存在。</p></li></ul></li></ul><p>派生自Error和RuntimeException的异常称为非检查型异常，所有其他的异常称为检查型异常，检查型异常必须全部声明，否则编译器会报错。</p><hr><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li><p><strong>异常抛出</strong></p><p>可以在方法上使用throws关键字抛出异常给上层调用者，或者在方法中使用throw语句抛出异常。</p></li><li><p><strong>异常捕获</strong></p><p>使用try-catch代码块，如果try代码块中出现了异常，程+序会跳过try中的剩余语句并执行catch代码块，如果没有出现异常会跳过catch代码块。</p><p>可以在try-catch代码块中使用finally代码块，用于资源的清理，从Java7开始可以使用try-with-resources，资源是指实现了Closeable接口的类，try块退出时会自动调用资源的close方法来释放资源。</p><p>无论try中是否遇到了异常，finally代码块都会执行。</p></li></ul><p>一般经验是捕获那些你知道如何处理的异常，而继续传播那些你不知道如何处理的异常交给调用者来处理。</p><hr><h3 id="使用异常的技巧"><a href="#使用异常的技巧" class="headerlink" title="使用异常的技巧"></a>使用异常的技巧</h3><ul><li>异常处理不能替代简单的测试。</li><li>不要过分地细化异常。</li><li>充分利用异常的层次结构。</li><li>不要压制异常。</li><li>在检测错误时，苛刻比放任更好，异常应该尽早抛出。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
